/*
#ifndef USERS_ZUNGER_OS_KEYS_H__
#define USERS_ZUNGER_OS_KEYS_H__
#include QMK_KEYBOARD_H
#include <assert.h>

// OS mode keys. To use these:
//
enum os_modes {
  OS_WINDOWS = 0,
  OS_MAC = 1,
  NUM_OS_MODES = 2,
};
extern uint8_t os_mode;

void set_os_mode(uint8_t new_mode);
void toggle_os_mode(void);  // Cycle through them
bool process_os_key(uint16_t keycode, keyrecord_t *record);

// Accent management, all in one function.
bool process_accent_key(uint16_t keycode, keyrecord_t *record);

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Key maps

enum custom_keycodes {
  // OS-dependent macros
  KC_PLATFORM = SAFE_RANGE,  // Platform select
  KC_VC_MUTE,  // Video conference mute
  KC_VC_HAND,  // Video conference hand-raise
  KC_SCRNSHT,  // Screenshot (gui-shift-S on Windows, gui-shift-4 on Mac)

  // These are the keycodes generated by the various "accent request" keystrokes.
  KC_ACCENT_START,
  KC_CGRV = KC_ACCENT_START,  // Grave accent
  KC_CAGU,  // Acute accent
  KC_CDIA,  // Diaresis / umlaut / trema
  KC_CCIR,  // Circumflex
  KC_CCED,  // Cedilla
  KC_CTIL,  // Tilde
  KC_ACCENT_END,
};

tap_dance_action_t tap_dance_actions[] = {
    [L_GREEK] = LANGUAGE_TAP_DANCE(L_GREEK),
    [L_CADET] = LANGUAGE_TAP_DANCE(L_CADET),
    [L_YIDDISH] = LANGUAGE_TAP_DANCE(L_YIDDISH)
};

enum layers_keymap {
  _QWERTY,
  _FUNCTION,
};

// This is so that H(xxxx) has the same width as _______, which makes the grids more legible.
#define H(x) UC(0x##x)
#define MO_FN MO(_FUNCTION)

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
	[_QWERTY] = LAYOUT_all(
		KC_ESC,      XXXXXXX,       KC_GRAVE,KC_1,    KC_2,    KC_3,    KC_4,    KC_5,    KC_6,    KC_7,    KC_8,    KC_9,    KC_0,    KC_MINS, KC_EQL,  KC_BSPC,          KC_HOME,
		KC_PLATFORM, KC_MPLY,       KC_TAB,  KC_Q,    KC_W,    KC_E,    KC_R,    KC_T,    KC_Y,    KC_U,    KC_I,    KC_O,    KC_P,    KC_LBRC, KC_RBRC, KC_BSLS,          KC_PGUP,
		KC_SCRNSHT,  TD(L_YIDDISH), KC_LCTL, KC_A,    KC_S,    KC_D,    KC_F,    KC_G,    KC_H,    KC_J,    KC_K,    KC_L,    KC_SCLN, KC_QUOT, KC_ENT,                    KC_PGDN,
		TD(L_GREEK), TD(L_CADET),   KC_LSFT, KC_Z,    KC_X,    KC_C,    KC_V,    KC_B,    KC_N,    KC_M,    KC_COMM, KC_DOT,  KC_SLSH, KC_RSFT,                   KC_UP,   KC_END,
		KC_VC_HAND,  KC_VC_MUTE,    KC_LCTL, KC_LGUI, KC_LALT,                            KC_SPC,                                      MO_FN,            KC_LEFT, KC_DOWN, KC_RGHT),
    // The function layer mostly contains the accent marks, but also has a few meta-control
    // operations. The accent marks are placed by analogy with Mac OS.
	[_FUNCTION] = LAYOUT_all(
		QK_BOOT,     KC_TRNS,       KC_CGRV, KC_F1,   KC_F2,   KC_F3,   KC_F4,   KC_F5,   KC_F6,   KC_F7,   KC_F8,   KC_F9,   KC_F10,  KC_F11,  KC_F12,  XXXXXXX,          XXXXXXX,
		KC_TRNS,     KC_TRNS,       KC_TRNS, XXXXXXX, XXXXXXX, KC_CAGU, XXXXXXX, XXXXXXX, XXXXXXX, KC_CDIA, KC_CCIR, XXXXXXX, XXXXXXX, H(200e), H(200f), XXXXXXX,          XXXXXXX,
		KC_TRNS,     KC_TRNS,       KC_TRNS, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX,                   XXXXXXX,
		KC_TRNS,     KC_TRNS,       KC_TRNS, XXXXXXX, XXXXXXX, KC_CCED, XXXXXXX, XXXXXXX, KC_CTIL, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, KC_TRNS,                   XXXXXXX, XXXXXXX,
		KC_TRNS,     KC_TRNS,       KC_RCTL, KC_RGUI, KC_RALT,                            KC_TRNS,                                     KC_TRNS,          XXXXXXX, XXXXXXX, XXXXXXX),
};


////////////////////////////////////////////////////////////////////////////////////////////////////
// Accent implementation
//
// In the body of process_record_user, we store an "accent_request", which is the accent keycode if
// one was just selected, or zero otherwise. When the *next* key is hit, we look up whether the
// accent request plus that next keycode (plus the state of the shift key) together amount to an
// interesting combined (NFKC) character, and if so, emit it; otherwise, we emit the accent as a
// separate character and then process the next key normally. The resulting UI behavior is similar
// to that of the combining accent keys in MacOS.
//
// We store two arrays, depending on whether shift is or isn't held. Each is two-dimensional, with
// its outer key by the next keycode struck, and the inner key by the accent requested. The outer
// array has KC_Z + 1 as its upper bound, so that we can save memory by only coding alphabetic keys.
// The contents are either Unicode code points, or zero to indicate that we don't have a point for
// this combination.

#define NUM_ACCENTS (KC_ACCENT_END - KC_ACCENT_START)
#define NUM_ACCENTABLE_CHARS (KC_Z + 1)

const uint16_t PROGMEM unshifted_accents[NUM_ACCENTABLE_CHARS][NUM_ACCENTS] = {
  //         KC_CGRV, KC_CAGU, KC_CDIA, KC_CCIR, KC_CCED, KC_CTIL
  [KC_A] = { 0x00e0,  0x00e1,  0x00e4,  0x00e2,  0,       0x00e3 },
  [KC_E] = { 0x00e8,  0x00e9,  0x00eb,  0x00ea,  0,       0      },
  [KC_I] = { 0x00ec,  0x00ed,  0x00ef,  0x00ee,  0,       0      },
  [KC_O] = { 0x00f2,  0x00f3,  0x00f6,  0x00f4,  0,       0x00f5 },
  [KC_U] = { 0x00f9,  0x00fa,  0x00fc,  0x00fb,  0,       0      },
  [KC_Y] = { 0,       0,       0x00ff,  0,       0,       0      },
  [KC_N] = { 0,       0,       0,       0,       0,       0x00f1 },
  [KC_C] = { 0,       0,       0,       0,       0x00e7,  0      },
};

const uint16_t PROGMEM shifted_accents[NUM_ACCENTABLE_CHARS][NUM_ACCENTS] = {
  //         KC_CGRV, KC_CAGU, KC_CDIA, KC_CCIR, KC_CCED, KC_CTIL
  [KC_A] = { 0x00c0,  0x00c1,  0x00c4,  0x00c2,  0,       0x00c3 },
  [KC_E] = { 0x00c8,  0x00c9,  0x00cb,  0x00ca,  0,       0      },
  [KC_I] = { 0x00cc,  0x00cd,  0x00cf,  0x00ce,  0,       0      },
  [KC_O] = { 0x00d2,  0x00d3,  0x00d6,  0x00d4,  0,       0x00d5 },
  [KC_U] = { 0x00d9,  0x00da,  0x00dc,  0x00db,  0,       0      },
  [KC_Y] = { 0,       0,       0x00df,  0,       0,       0      },
  [KC_N] = { 0,       0,       0,       0,       0,       0x00d1 },
  [KC_C] = { 0,       0,       0,       0,       0x00c7,  0      },
};

// The uncombined and combined forms of the accents, for when we want to emit them as single
// characters.
const uint16_t PROGMEM uncombined_accents[NUM_ACCENTS] = {
  [KC_CGRV - KC_ACCENT_START] = 0x0060,
  [KC_CAGU - KC_ACCENT_START] = 0x00b4,
  [KC_CDIA - KC_ACCENT_START] = 0x00a8,
  [KC_CCIR - KC_ACCENT_START] = 0x005e,
  [KC_CCED - KC_ACCENT_START] = 0x00b8,
  [KC_CTIL - KC_ACCENT_START] = 0x02dc,
};

const uint16_t PROGMEM combined_accents[NUM_ACCENTS] = {
  [KC_CGRV - KC_ACCENT_START] = 0x0300,
  [KC_CAGU - KC_ACCENT_START] = 0x0301,
  [KC_CDIA - KC_ACCENT_START] = 0x0308,
  [KC_CCIR - KC_ACCENT_START] = 0x0302,
  [KC_CCED - KC_ACCENT_START] = 0x0327,
  [KC_CTIL - KC_ACCENT_START] = 0x0303,
};

bool process_accent_key(uint16_t keycode, keyrecord_t *record) {
  // The accent request, or zero if there isn't one.
  static uint16_t accent_request = 0;

  // Everything in here only triggers on key downstrokes.
  if (!record->event.pressed) return FALLTHROUGH;

  // Press on an accent request key.
  if (keycode >= KC_ACCENT_START && keycode < KC_ACCENT_END) {
      if (IS_SHIFTED) {
        // Shift+accent request means to just emit the appropriate Unicode combining accent symbol
        // right now.
        register_unicode(pgm_read_word(combined_accents + keycode - KC_ACCENT_START));
      } else {
        accent_request = keycode;
      }
      return STOP;
  }

  // OK, some other key was pressed. Is there a pending accent request? If not, we're done.
  if (!accent_request) return FALLTHROUGH;

  // If a modifier key was pressed, even though there's an accent request, don't do anything yet.
  if (IS_MODIFIER_KEYCODE(keycode) || IS_QK_MODS(keycode)) return FALLTHROUGH;

  // If we hit a normal key but with ctrl, alt, or gui, or if we just hit a non-alphanumeric key
  // altogether, then just abort the accent request as if it never happened.
  if (!IS_BASIC_KEYCODE(keycode) || (get_mods() & MOD_MASK_CAG)) {
    accent_request = 0;
    return FALLTHROUGH;
  }

  // An accent request is pending, and a normal key got hit! Time to generate some Unicode.
  assert(accent_request >= KC_ACCENT_START);
  assert(accent_request < KC_ACCENT_END);
  const int accent_index = accent_request - KC_ACCENT_START;
  // Consume the accent request, no matter which path we take from here.
  accent_request = 0;

  // If the accent request and the next key (as represented by its keycode and shift state)
  // together have an NFC representation, emit that. For example, fn-e e leads to U+00E9 LATIN
  // SMALL LETTER E WITH ACUTE if shift isn't held, or U+00C9 LATIN LARGE LETTER E WITH ACUTE if it is.
  // If the keycode is outside A..Z, we know we shouldn't even bother with a table lookup.
  if (keycode <= KC_Z) {
    // Pick the correct array. Because this is progmem, we're going to need to do the
    // two-dimensional array indexing by hand, and so we just cast it to a single-dimensional array.
    const uint16_t *points = (const uint16_t*)(IS_SHIFTED ? shifted_accents : unshifted_accents);
    const uint16_t code_point = pgm_read_word(points + NUM_ACCENTS * keycode + accent_index);
    if (code_point) {
      register_unicode(code_point);
      return STOP;
    }
  }

  // Otherwise, NFC and NFD are identical, and we emit the accent as its own character -- a
  // Unicode combining accent mark -- and then return false, so that the keycode falls through
  // and ultimately gets transmitted to the host OS. For example, if you are a Spinal Tap fan,
  // you might tap fn-u n, and we will emit U+0308 COMBINING DIARESIS followed by KC_N. The host
  // OS is responsible for merging those; generally speaking, Mac OS is much better at handling
  // that than other OS's, so YMMV.
  register_unicode(pgm_read_word(uncombined_accents + accent_index));
  return FALLTHROUGH;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
// OS MODES
// We manage our OS mode internally, and store it in a static, rather than EEPROM, bit. That's
// because it changes as we flip machines, and there's no good reason to wear out the memory.
void set_os_mode(uint8_t new_mode) {
  os_mode = new_mode;
  // NB: We set unicode_config.input_mode directly, rather than calling
  // set_unicode_input_mode, because we don't want to persist this and so we shouldn't put
  // extra load on the EEPROMs.
  unicode_config.input_mode = (os_mode == OS_MAC ? UNICODE_MODE_MACOS : UNICODE_MODE_WINCOMPOSE);
  // Swap LALT and LGUI depending on Mac/Windows.
  keymap_config.swap_lalt_lgui = (os_mode == OS_MAC);
  // This would be a great moment for some auditory or visual feedback, but this keyboard
  // doesn't support it. :(
}

void toggle_os_mode(void) {
  set_os_mode((os_mode + 1) % NUM_OS_MODES);
}

// msec to hold the platform key to trigger a switch
#define PLATFORM_HOLD_DURATION 750
// Values for our OS-dependent keys, as arrays keyed by OS mode. Use Meet shortcuts on Mac, Teams on Windows
const char *VC_MUTE_VALUES[NUM_OS_MODES] = {SS_LCTL(SS_LSFT("m")), SS_LCMD("d")};
const char *VC_HAND_VALUES[NUM_OS_MODES] = {SS_LCTL(SS_LSFT("k")), SS_LCTL(SS_LCMD("h"))};
const char *SCRNSHT_VALUES[NUM_OS_MODES] = {SS_LGUI(SS_LSFT("s")), SS_LCMD(SS_LSFT("4"))};

bool process_os_key(uint16_t keycode, keyrecord_t *record) {
  // When the hold on the platform key started
  static uint16_t platform_hold_start = 0;
  if (keycode == KC_PLATFORM) {
    if (record->event.pressed) {
      platform_hold_start = record->event.time;
    } else if (platform_hold_start != 0 && record->event.time - platform_hold_start > PLATFORM_HOLD_DURATION) {
      toggle_os_mode();
    }
    return STOP;
  }

  // For other cases, we only want keypresses.
  if (!record->event.pressed) return FALLTHROUGH;

  switch (keycode) {
    case KC_VC_MUTE:
        send_string(VC_MUTE_VALUES[os_mode]);
        return STOP;

    case KC_VC_HAND:
        send_string(VC_HAND_VALUES[os_mode]);
        return STOP;

    case KC_SCRNSHT:
        send_string(SCRNSHT_VALUES[os_mode]);
        return STOP;
  }

  return FALLTHROUGH;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
// Main

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    return (
        process_os_key(keycode, record) &&
        process_accent_key(keycode, record) &&
        process_language_key(keycode, record)
    );
}

void keyboard_post_init_user() {
  set_os_mode(OS_WINDOWS);
}

#endif  // USERS_ZUNGER_OS_KEYS_H__
*/
