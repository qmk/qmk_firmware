// Render an animation,
// size of ANIM_WIDTH * ANIM_HEIGHT (in pixel, and MUST be divisible by 8, e.g. 24x32 pixel)
// at position [ANIM_POS_X, ANIM_POS_Y] as top-left coordinate ([column, row], means the animation is render within text line)

#define ANIM_POS_X  0
#define ANIM_POS_Y  4
#define ANIM_FRAME_DURATION 200 // delay between frames, in ms, at 42ms the animation will be 24fps
#define ANIM_WIDTH  16
#define ANIM_HEIGHT 32
#define ANIM_STATES 2 // Running, Jumping
#define IDLE_FRAMES 4 // Total frames for "idle state"
#define TAP_FRAMES  2 // Total frames for "tap state"
uint8_t  anim_state = 0;
uint8_t  anim_idle_frame = 0;
uint8_t  anim_tap_frame = 0;
uint16_t anim_timer = 0;

static void render_anim(void) {
    static const char PROGMEM mario_idle0[ANIM_HEIGHT/8][ANIM_WIDTH] = {
        { 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20, 0xc0, 0x00, 0x00, 0x00, 0x00 },
        { 0x00, 0x78, 0x8e, 0x09, 0x38, 0x7c, 0x26, 0x82, 0xc3, 0x9b, 0x03, 0x1f, 0x17, 0x97, 0x62, 0x00 },
        { 0x00, 0xf8, 0xc6, 0x83, 0x03, 0x06, 0x3c, 0xcc, 0x84, 0x85, 0x85, 0xcb, 0x71, 0xc0, 0x00, 0x00 },
        { 0x00, 0x00, 0x0f, 0xff, 0x9f, 0x9f, 0x9f, 0x9f, 0x9e, 0xbe, 0xdf, 0x1f, 0x0e, 0x03, 0x00, 0x00 }
    };
    static const char PROGMEM mario_idle1[ANIM_HEIGHT/8][ANIM_WIDTH] = {
        { 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x20, 0x20, 0x20, 0x20, 0xc0, 0x00, 0x00, 0x00, 0x00 },
        { 0x00, 0x78, 0x8e, 0x09, 0x38, 0x7c, 0x26, 0x82, 0xc3, 0x9b, 0x83, 0x1b, 0x1f, 0x97, 0xe2, 0x80 },
        { 0xf0, 0x8c, 0x02, 0x63, 0x93, 0x0e, 0x0c, 0x0c, 0x94, 0x65, 0x8d, 0x9b, 0x71, 0xc9, 0x30, 0x00 },
        { 0x00, 0x3b, 0x47, 0x9f, 0xbf, 0xbf, 0xbf, 0xdf, 0x0e, 0x1e, 0x7f, 0x9f, 0x8e, 0x47, 0x24, 0x18 }
    };
    static const char PROGMEM mario_idle2[ANIM_HEIGHT/8][ANIM_WIDTH] = {
        { 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x20, 0x20, 0x20, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00 },
        { 0x60, 0x98, 0x0e, 0x39, 0x7c, 0x24, 0x82, 0xc3, 0x9b, 0x83, 0x1b, 0x03, 0x9f, 0xe6, 0x80, 0x00 },
        { 0x70, 0x88, 0xc5, 0x23, 0x12, 0x12, 0x14, 0x2c, 0xfd, 0x65, 0x45, 0x8f, 0x99, 0x74, 0xc4, 0x38 },
        { 0x3c, 0x46, 0x41, 0x3d, 0x3e, 0x1e, 0x1e, 0x1f, 0x0f, 0x0e, 0x0e, 0x1f, 0x21, 0x20, 0x30, 0x1f }
    };
    static const char PROGMEM mario_tap0[ANIM_HEIGHT/8][ANIM_WIDTH] = {
        { 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x90, 0xc8, 0xc8, 0xc8, 0xd8, 0xf0, 0xc8, 0x88, 0x08, 0xf0 },
        { 0x18, 0x26, 0x43, 0xce, 0x9f, 0x89, 0x20, 0x30, 0x66, 0x60, 0x46, 0xc0, 0x67, 0x39, 0xe1, 0x1e },
        { 0x1c, 0xa2, 0x71, 0x48, 0x84, 0x84, 0x85, 0xcb, 0xff, 0x99, 0x91, 0xe3, 0x66, 0x1d, 0x30, 0xc0 },
        { 0x0f, 0x11, 0x10, 0x0f, 0x0f, 0x07, 0x07, 0x07, 0x03, 0x03, 0x03, 0x07, 0x08, 0x08, 0x0c, 0x07 }
    };

    bool draw_frame(const char data[][ANIM_WIDTH], uint8_t col, uint8_t row) {
        // Check if the frame is within OLED screen, or it may cause unexpected behavior
        if ((col*8 + ANIM_WIDTH > OLED_DISPLAY_WIDTH) || (row*8 + ANIM_HEIGHT > OLED_DISPLAY_HEIGHT)) {
            return false;
        }
        for (uint8_t i = 0; i < ANIM_HEIGHT/8; i++) {
            oled_set_cursor(col, row++);
            oled_write_raw_P(data[i], sizeof(data[i]));
        }
        return true;
    }

    void animation_phase(void) {
        // Idle (running Mario)
        if (anim_state == 0) {
            anim_idle_frame = (anim_idle_frame + 1) % IDLE_FRAMES;
            switch (anim_idle_frame) {
                case 0:
                    draw_frame(mario_idle0, ANIM_POS_X, ANIM_POS_Y);
                    break;
                case 1:
                    draw_frame(mario_idle1, ANIM_POS_X, ANIM_POS_Y);
                    break;
                case 2:
                    draw_frame(mario_idle2, ANIM_POS_X, ANIM_POS_Y);
                    break;
                case 3:
                    draw_frame(mario_idle1, ANIM_POS_X, ANIM_POS_Y);
                    break;        
            }
        }
        // Tap (jumping Mario)
        if (anim_state == 1) {
            anim_tap_frame = (anim_tap_frame + 1) % TAP_FRAMES;
            switch (anim_tap_frame) {
                case 0:
                    draw_frame(mario_tap0, ANIM_POS_X, ANIM_POS_Y);
                    break;
                case 1:
                    draw_frame(mario_idle2, ANIM_POS_X, ANIM_POS_Y);
                    break;
            }
        }
    }
    if (timer_elapsed(anim_timer) > ANIM_FRAME_DURATION) {
        anim_timer = timer_read();
        animation_phase(); // next frame
    }
}
