// Copyright 2023 QMK
// SPDX-License-Identifier: GPL-2.0-or-later

#include QMK_KEYBOARD_H

#ifdef OLED_ENABLE
oled_rotation_t oled_init_user(oled_rotation_t rotation) { return OLED_ROTATION_180; }
bool oled_task_user() {
    static const char gravitas_logo [] PROGMEM = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 
        0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 
        0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 
        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 
        0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x80, 0x80, 0x80, 0x80, 0xc0, 0xc0, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0xf8, 0xfc, 0xfe, 0xff, 0xff, 0xff, 0x0f, 0xc7, 0xc7, 0xcf, 0xdf, 0xdf, 
        0xdf, 0xde, 0xdc, 0xc0, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xe7, 0xe7, 0xe7, 
        0xff, 0xff, 0xff, 0xff, 0x7f, 0x3c, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf8, 0xff, 0xff, 0x7f, 0x1f, 
        0xff, 0xff, 0xff, 0xfc, 0xe0, 0x00, 0x00, 0x01, 0x0f, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0xe0, 0x00, 
        0x00, 0xe0, 0xfe, 0xff, 0xff, 0x3f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 
        0x07, 0x07, 0x07, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0xe0, 
        0xfc, 0xff, 0xff, 0x1f, 0x7f, 0xff, 0xff, 0xff, 0xf8, 0xc0, 0x00, 0x00, 0x00, 0x18, 0xfe, 0xff, 
        0xff, 0xff, 0xff, 0xf7, 0xe7, 0xe7, 0xe7, 0xef, 0xcf, 0xcf, 0x86, 0x04, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x0f, 0x3f, 0x3f, 0x7f, 0xff, 0xff, 0xf8, 0xf3, 0xf3, 0xf3, 0x7f, 0x7f, 
        0x7f, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x01, 0x0f, 0x7f, 
        0xff, 0xff, 0xff, 0xfe, 0xf0, 0x80, 0x00, 0x00, 0xe0, 0xfc, 0xff, 0xff, 0x3f, 0x1f, 0x1e, 0x1e, 
        0x1f, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xc0, 0x00, 0x00, 0x03, 0x1f, 0xff, 0xff, 0xff, 0xfe, 
        0xff, 0xff, 0x7f, 0x0f, 0x01, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xc0, 0xf8, 0xff, 0xff, 
        0xff, 0x1f, 0x1f, 0x1e, 0x1e, 0x1f, 0x3f, 0xff, 0xff, 0xff, 0xfc, 0xe0, 0x00, 0x18, 0x3c, 0x7c, 
        0xfd, 0xfd, 0xfb, 0xf3, 0xf3, 0xf3, 0xf7, 0xff, 0xff, 0x7f, 0x7f, 0x3f, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    oled_write_raw_P(gravitas_logo, sizeof(gravitas_logo));
    oled_write_ln_P(PSTR(""), false);
    oled_write_ln_P(PSTR("hello"), false);
    return false;
};

#endif



const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {

    [0] = LAYOUT(
        KC_A,   KC_B,   KC_C,  QK_USER,
        KC_D,   KC_E,   KC_F,   
        KC_G,   KC_H,   KC_I  

    ),
    [1] = LAYOUT(
        KC_J,   KC_K,   KC_L,  QK_USER,
        KC_M,   KC_N,   KC_O,   
        KC_P,   KC_Q,   KC_R  

    ),
    [2] = LAYOUT(
        KC_S,   KC_T,   KC_U,  QK_USER,
        KC_V,   KC_W,   KC_X,   
        KC_Y,   KC_Z,   KC_1  

    ),
    [3] = LAYOUT(
        KC_2,   KC_3,   KC_4,  QK_USER,
        KC_5,   KC_6,   KC_7,   
        KC_8,   KC_9,   KC_0  

    )
};

const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {
    [0] =   { ENCODER_CCW_CW(KC_VOLD, KC_VOLU)  },
    [1] =   { ENCODER_CCW_CW(KC_VOLD, KC_VOLU)  },
    [2] =   { ENCODER_CCW_CW(KC_VOLD, KC_VOLU)  },
    [3] =   { ENCODER_CCW_CW(KC_VOLD, KC_VOLU)  }

};


enum layer_names {
    FIRST,
    SECOND,
    THIRD,
    FOURTH
};

enum keycodes {
    KC_CYCLE_LAYERS = QK_USER,
  };
  
  // 1st layer on the cycle
  #define LAYER_CYCLE_START 0
  // Last layer on the cycle
  #define LAYER_CYCLE_END   3
  
  // Add the behaviour of this new keycode
  bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    switch (keycode) {
      case KC_CYCLE_LAYERS:
        // Our logic will happen on presses, nothing is done on releases
        if (!record->event.pressed) { 
          // We've already handled the keycode (doing nothing), let QMK know so no further code is run unnecessarily
          return false;
        }

        uint8_t current_layer = get_highest_layer(layer_state);
  
        // Check if we are within the range, if not quit
        if (current_layer > LAYER_CYCLE_END || current_layer < LAYER_CYCLE_START) {
          return false;
        }
  
        uint8_t next_layer = current_layer + 1;
        if (next_layer > LAYER_CYCLE_END) {
            next_layer = LAYER_CYCLE_START;
        }
        layer_move(next_layer);
        return false;
  
      // Process other keycodes normally
      default:
        return true;
    }
  }



