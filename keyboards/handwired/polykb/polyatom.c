#include QMK_KEYBOARD_H

#include "polyatom.h"
#include "base/disp_array.h"
#include "base/shift_reg.h"
#include "base/spi_helper.h"

static uint32_t timer = 0;
static int32_t last_update = 0;
static bool splash_shown = false;

uint16_t currentLayer = 0;

static uint16_t last_key = 0;
static bool     diplays_on = false;
static deferred_token displays_task_user_token;

static uint8_t global_contrast;

static bool is_master_side = false;

#ifdef OLED_ENABLE

oled_rotation_t oled_init_user(oled_rotation_t rotation) {
    //timer = timer_read32();
    return OLED_ROTATION_180;
}

bool oled_task_user(void) {
    char buffer[32];

    led_t led_state = host_keyboard_led_state();
    snprintf(buffer, sizeof(buffer), "Layer: %d %s %s %s",
            get_highest_layer(layer_state),
            led_state.num_lock ? "NUM" : "[ ]",
            led_state.caps_lock ? "CAP" : "[ ]",
            led_state.scroll_lock ? "SCR" : "[ ]"
        );
    oled_write(buffer, false);

    snprintf(buffer, sizeof(buffer), "\nLast Key: 0x%04x", last_key);
    oled_write(buffer, false);

    snprintf(buffer, sizeof(buffer), "\nMode:%2d ver. %d.%d",
        rgb_matrix_get_mode(), (char)(DEVICE_VER >> 8), (char)DEVICE_VER);
    oled_write(buffer, false);

    snprintf(buffer, sizeof(buffer), "\n%s", is_master_side ? "MASTER" : "SLAVE");
    oled_write(buffer, false);

    oled_set_cursor(0, 4);
    static const char PROGMEM raw_logo[] = {0x80, 0xc0, 0xc0, 0x40, 0x40, 0x40, 0xc0, 0xc0, 0xc0, 0x80, 0x00, 0x80, 0xc0, 0xc0, 0x40, 0x40, 0x40, 0x40, 0xc0, 0xc0, 0x80, 0x00, 0x80, 0xc0, 0x40, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x80, 0x00, 0x80, 0xc0, 0x40, 0xc0, 0xc0, 0xc0, 0xc0, 0x40, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                            0xff, 0xff, 0x00, 0xef, 0xef, 0xef, 0xf0, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xf8, 0xf7, 0xf7, 0x07, 0xf7, 0xf8, 0xff, 0xff, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00,
                                            0x01, 0x03, 0x02, 0x03, 0x73, 0x73, 0x63, 0x03, 0x73, 0x61, 0x30, 0x01, 0x03, 0x03, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x01, 0x00, 0x01, 0x03, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x01, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x03, 0xff, 0xff, 0x00, 0xcf, 0xdf, 0x2f, 0xf0, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x01, 0xee, 0xee, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0x00, 0xff, 0xff, 0xf0, 0xef, 0xef, 0x0f, 0xef, 0xf0, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xfe, 0xfe, 0xee, 0xce, 0x31, 0xff, 0xff, 0x00, 0xff, 0xff, 0x01, 0xfe, 0xfe, 0xfe, 0xfe, 0x01, 0xff, 0xff, 0x00, 0xff, 0xff, 0x07, 0xb9, 0xbe, 0xbe, 0xb9, 0x07, 0xff, 0xff, 0x00, 0xff, 0xff, 0x01, 0xde, 0xde, 0x9e, 0x61, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0xfe, 0xfe, 0xfe, 0xfd, 0x03, 0xff, 0xff,
                                            0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21, 0x27, 0x21, 0x20, 0x27, 0x22, 0x27, 0x20, 0x27, 0x23, 0x23, 0x20, 0x27, 0x25, 0x27, 0x20, 0x27, 0x27, 0x24, 0x20, 0x27, 0x27, 0x24, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x23, 0x27, 0x24, 0x27, 0x27, 0x27, 0x24, 0x27, 0x27, 0x23, 0x20, 0x23, 0x27, 0x26, 0x25, 0x25, 0x25, 0x25, 0x25, 0x27, 0x23, 0x20, 0x23, 0x27, 0x27, 0x27, 0x27, 0x24, 0x27, 0x27, 0x27, 0x23, 0x20, 0x23, 0x27, 0x24, 0x25, 0x25, 0x25, 0x25, 0x26, 0x27, 0x23, 0x20, 0x23, 0x27, 0x26, 0x25, 0x25, 0x25, 0x25, 0x26, 0x27, 0x23, 0x20, 0x23, 0x27, 0x24, 0x27, 0x27, 0x27, 0x27, 0x24, 0x27, 0x03, 0x20, 0x03, 0x27, 0x04, 0x27, 0x07, 0x67, 0x34, 0x77, 0x07, 0x13, 0x70, 0x13, 0x07, 0x74, 0x55, 0x75, 0x05, 0x76, 0x37, 0x77, 0x03};
    oled_write_raw_P(raw_logo, sizeof(raw_logo));

    return false;
}

#endif

void select_all_displays(void) {
    // make sure we are talking to all shift registers
    uint8_t all[NUM_SHIFT_REGISTERS] = {0,0,0,0,0};
    sr_shift_out_buffer_latch(all, NUM_SHIFT_REGISTERS);
}

void set_displays(enum diplay_state state, uint8_t contrast) {
    select_all_displays();
    if (state != DISPLAYS_SET_CONTRAST) {
        bool enable = state != DISPLAYS_OFF;
        kdisp_enable(enable);
        diplays_on = enable;
        #ifdef OLED_ENABLE
        if(enable) oled_on(); else  oled_off();
        #endif
        uprintf("All displays %s\n", enable ? "on" : "off");
    }
    if (state == DISPLAYS_ON_SET_CONTRAST || state == DISPLAYS_SET_CONTRAST) {
        global_contrast = contrast;
        kdisp_set_contrast(contrast);
        #ifdef OLED_ENABLE
        oled_set_brightness(contrast);
        #endif
    }
}

#define FULL_BRIGHT 49

void inc_brightness(void) {
    if(global_contrast<FULL_BRIGHT) {
        global_contrast+=4;
    }
    if(global_contrast>FULL_BRIGHT) {
        global_contrast = FULL_BRIGHT;
    }
    set_displays(DISPLAYS_SET_CONTRAST, global_contrast);
}

void dec_brightness(void) {
    if(global_contrast>=6) {
        global_contrast-=4;
    }
    set_displays(DISPLAYS_SET_CONTRAST, global_contrast);
}

#define FADE_TRANSITION_TIME 5000
#define FADE_OUT_TIME 60000

uint32_t displays_task_user(uint32_t trigger_time, void* cb_arg) {
    uint32_t totalTime = timer_elapsed32(timer);
    uint32_t elapsed_time_since_update = totalTime - last_update;

    if (elapsed_time_since_update > FADE_OUT_TIME && diplays_on) {
        int32_t contrast = ((FADE_TRANSITION_TIME - (elapsed_time_since_update - FADE_OUT_TIME)) * FULL_BRIGHT) / FADE_TRANSITION_TIME;

        set_displays(contrast < 1 ? DISPLAYS_OFF : DISPLAYS_SET_CONTRAST, (uint8_t)contrast);
    }

    if(!splash_shown) {
        if(totalTime > 500) {
            force_layer_switch();
            splash_shown = true;
        }
    }

    return 100;
}

//disable first keypress if the displays are turned off
bool display_wakeup(keyrecord_t* record) {
    if (!diplays_on) {
        select_all_displays();
        if (!record->event.pressed) {
            set_displays(DISPLAYS_ON, 0);
        } else {
            set_displays(DISPLAYS_SET_CONTRAST, FULL_BRIGHT);
        }
        update_performed();
        return false;
    }
    return true;
}


#ifndef CUSTOM_PROCESS_RECORD_USER
bool process_record_user(uint16_t keycode, keyrecord_t* record) {
    return display_wakeup(record);
}
#endif


void clear_all_displays(void) {
    select_all_displays();
    
    kdisp_set_buffer(0x00);
    kdisp_send_buffer();
}

void early_hardware_init_post(void) {
    kdisp_hw_setup();
    spi_hw_setup();
}

void process_layer_switch_user(uint16_t new_layer);

void force_layer_switch(void) {
    process_layer_switch_user(currentLayer);
}

void set_layer(uint16_t new_layer) {
    currentLayer = new_layer;
    process_layer_switch_user(currentLayer);
}

void next_layer(int8_t num_layers) {
    currentLayer = (currentLayer+1) % num_layers;
    force_layer_switch();
}

void prev_layer(int8_t num_layers) {
    if(currentLayer==0) {
        currentLayer = num_layers-1;
    } else {
    currentLayer--;
    }
    currentLayer = currentLayer % num_layers;

    force_layer_switch();
}

void keyboard_post_init_user(void) {
    //rgb_matrix_set_color_all(0, 4, 4);
    rgb_matrix_mode_noeeprom(RGB_MATRIX_RAINBOW_MOVING_CHEVRON);

    // Customise these values to desired behaviour
    debug_enable   = true;
    debug_matrix   = false;
    debug_keyboard = false;
    debug_mouse    = false;

    kdisp_init(NUM_SHIFT_REGISTERS, true);

    displays_task_user_token = defer_exec(100, displays_task_user, NULL);

    set_displays(DISPLAYS_ON_SET_CONTRAST, FULL_BRIGHT);
    show_splash_screen();

    is_master_side = is_keyboard_master();
    uprintf("Poly Keyboard ready.");
}

bool is_master(void) {
    return is_master_side;
}

// uint8_t keycode_to_disp_index(uint16_t keycode) {
//    for(uint8_t row =0; row < MATRIX_ROWS; ++row) {
//        for(uint8_t col =0; col < MATRIX_COLS; ++col) {
//            if(keymaps[currentLayer][row][col]==keycode) {
//                return LAYOUT_TO_INDEX(row, col);
//            }
//        }
//    }

//     return 255;
// }

void update_performed(void) {
    last_update = timer_elapsed32(timer);
}

void set_last_key(uint16_t keycode) {
    last_key = keycode;
}
