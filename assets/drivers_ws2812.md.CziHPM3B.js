import { _ as _export_sfc, c as createElementBlock, o as openBlock, a8 as createStaticVNode } from "./chunks/framework.Cauyuiy8.js";
const __pageData = JSON.parse('{"title":"WS2812 Driver","description":"","frontmatter":{},"headers":[],"relativePath":"drivers/ws2812.md","filePath":"drivers/ws2812.md","lastUpdated":null}');
const _sfc_main = { name: "drivers/ws2812.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="ws2812-driver" tabindex="-1">WS2812 Driver <a class="header-anchor" href="#ws2812-driver" aria-label="Permalink to &quot;WS2812 Driver {#ws2812-driver}&quot;">​</a></h1><p>This driver provides support for WorldSemi addressable RGB(W) LEDs, and compatible equivalents:</p><ul><li>WS2811, WS2812, WS2812B, WS2812C, etc.</li><li>SK6812, SK6812MINI, SK6805</li></ul><p>These LEDs are often called &quot;addressable&quot; because instead of using a wire per color (and per LED), each LED contains a small microchip that understands a special protocol sent over a single wire. The LEDs can be chained together, and the remaining data is passed on to the next. In this way, you can easily control the color of many LEDs using a single GPIO.</p><h2 id="usage" tabindex="-1">Usage <a class="header-anchor" href="#usage" aria-label="Permalink to &quot;Usage {#usage}&quot;">​</a></h2><p>In most cases, the WS2812 driver code is automatically included if you are using either the <a href="./../features/rgblight">RGBLight</a> or <a href="./../features/rgb_matrix">RGB Matrix</a> feature with the <code>ws2812</code> driver set, and you would use those APIs instead.</p><p>However, if you need to use the driver standalone, add the following to your <code>rules.mk</code>:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WS2812_DRIVER_REQUIRED = yes</span></span></code></pre></div><p>You can then call the WS2812 API by including <code>ws2812.h</code> in your code.</p><h2 id="basic-configuration" tabindex="-1">Basic Configuration <a class="header-anchor" href="#basic-configuration" aria-label="Permalink to &quot;Basic Configuration {#basic-configuration}&quot;">​</a></h2><p>Add the following to your <code>config.h</code>:</p><table><thead><tr><th>Define</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>WS2812_DI_PIN</code></td><td><em>Not defined</em></td><td>The GPIO pin connected to the DI pin of the first LED in the chain</td></tr><tr><td><code>WS2812_LED_COUNT</code></td><td><em>Not defined</em></td><td>Number of LEDs in the WS2812 chain - automatically set when RGBLight or RGB Matrix is configured</td></tr><tr><td><code>WS2812_TIMING</code></td><td><code>1250</code></td><td>The total length of a bit (TH+TL) in nanoseconds</td></tr><tr><td><code>WS2812_T1H</code></td><td><code>900</code></td><td>The length of a &quot;1&quot; bit&#39;s high phase in nanoseconds</td></tr><tr><td><code>WS2812_T0H</code></td><td><code>350</code></td><td>The length of a &quot;0&quot; bit&#39;s high phase in nanoseconds</td></tr><tr><td><code>WS2812_TRST_US</code></td><td><code>280</code></td><td>The length of the reset phase in microseconds</td></tr><tr><td><code>WS2812_BYTE_ORDER</code></td><td><code>WS2812_BYTE_ORDER_GRB</code></td><td>The byte order of the RGB data</td></tr><tr><td><code>WS2812_RGBW</code></td><td><em>Not defined</em></td><td>Enables RGBW support (except <code>i2c</code> driver)</td></tr></tbody></table><h3 id="timing-adjustment" tabindex="-1">Timing Adjustment <a class="header-anchor" href="#timing-adjustment" aria-label="Permalink to &quot;Timing Adjustment {#timing-adjustment}&quot;">​</a></h3><p>The WS2812 LED communication protocol works by encoding a &quot;1&quot; bit with a long high pulse (T<sub>1</sub>H), and a &quot;0&quot; bit with a shorter pulse (T<sub>0</sub>H). The total cycle length of a bit is the same. The &quot;reset&quot; pulse (T<sub>RST</sub>) latches the sent RGB data to all of the LEDs and denotes a completed &quot;frame&quot;.</p><p>Some WS2812 variants have slightly different timing parameter requirements, which can be accounted for if necessary using the above <code>#define</code>s in your <code>config.h</code>.</p><h3 id="byte-order" tabindex="-1">Byte Order <a class="header-anchor" href="#byte-order" aria-label="Permalink to &quot;Byte Order {#byte-order}&quot;">​</a></h3><p>Some WS2812 variants may have their color components in a different physical or logical order. For example, the WS2812B-2020 has physically swapped red and green LEDs, which causes the wrong color to be displayed, because the default order of the bytes sent over the wire is defined as GRB. If you find your LED colors are consistently swapped, you may need to change the byte order by adding the following to your <code>config.h</code>:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WS2812_BYTE_ORDER</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> WS2812_BYTE_ORDER_GRB</span></span></code></pre></div><p>Where the byte order may be one of:</p><table><thead><tr><th>Byte Order</th><th>Known Devices</th></tr></thead><tbody><tr><td><code>GRB</code></td><td>Most WS2812s, SK6812, SK6805</td></tr><tr><td><code>RGB</code></td><td>WS2812B-2020</td></tr><tr><td><code>BGR</code></td><td>TM1812</td></tr></tbody></table><h3 id="rgbw-support" tabindex="-1">RGBW Support <a class="header-anchor" href="#rgbw-support" aria-label="Permalink to &quot;RGBW Support {#rgbw-support}&quot;">​</a></h3><p>Rendering the color white with RGB LEDs is typically inconsistent due to inherent variations between each individual LED die. However, some WS2812 variants (such as SK6812RGBW) also possess a white LED along with the red, green, and blue channels, which allows for a more accurate white to be displayed.</p><p>QMK can automatically convert the RGB data to be sent to the LEDs to mix in the white channel:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>w = min(r, g, b)</span></span>\n<span class="line"><span>r -= w</span></span>\n<span class="line"><span>g -= w</span></span>\n<span class="line"><span>b -= w</span></span></code></pre></div><p>Thus, an RGB triplet of <code>255,255,255</code> will simply turn on the white LED fully (<code>0,0,0,255</code>).</p><p>To enable RGBW conversion, add the following to your <code>config.h</code>:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WS2812_RGBW</span></span></code></pre></div><h2 id="driver-configuration" tabindex="-1">Driver Configuration <a class="header-anchor" href="#driver-configuration" aria-label="Permalink to &quot;Driver Configuration {#driver-configuration}&quot;">​</a></h2><p>Driver selection can be configured in <code>rules.mk</code> as <code>WS2812_DRIVER</code>, or in <code>info.json</code> as <code>ws2812.driver</code>. Valid values are <code>bitbang</code> (default), <code>i2c</code>, <code>spi</code>, <code>pwm</code>, <code>vendor</code>, or <code>custom</code>. See below for information on individual drivers.</p><h3 id="bitbang-driver" tabindex="-1">Bitbang Driver <a class="header-anchor" href="#bitbang-driver" aria-label="Permalink to &quot;Bitbang Driver {#bitbang-driver}&quot;">​</a></h3><p>This is the default WS2812 driver. It operates by &quot;bit-banging&quot; ie. directly toggling the GPIO.</p><p>Please note that on AVR devices, due to the tight timing requirements longer chains and/or heavy CPU loads may cause visible lag. Unfortunately this driver is usually the only option for AVR.</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WS2812_DRIVER = bitbang</span></span></code></pre></div><h3 id="i2c-driver" tabindex="-1">I2C Driver <a class="header-anchor" href="#i2c-driver" aria-label="Permalink to &quot;I2C Driver {#i2c-driver}&quot;">​</a></h3><p>A specialized driver mainly used for PS2AVRGB (Bootmapper Client) boards, which possess an ATtiny85 that handles the WS2812 LEDs.</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WS2812_DRIVER = i2c</span></span></code></pre></div><p>The following <code>#define</code>s apply only to the <code>i2c</code> driver:</p><table><thead><tr><th>Define</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>WS2812_I2C_ADDRESS</code></td><td><code>0xB0</code></td><td>The I2C address of the ATtiny85.</td></tr><tr><td><code>WS2812_I2C_TIMEOUT</code></td><td><code>100</code></td><td>The I2C timeout, in milliseconds.</td></tr></tbody></table><h3 id="pio-driver" tabindex="-1">PIO Driver <a class="header-anchor" href="#pio-driver" aria-label="Permalink to &quot;PIO Driver {#pio-driver}&quot;">​</a></h3><p>This driver is RP2040-only, and leverages the onboard PIO (programmable I/O) system and DMA to offload processing from the CPU.</p><p>The WS2812 PIO program uses one state machine, six instructions and one DMA interrupt handler callback. Due to the implementation the time resolution for this driver is 50 ns - any value not specified in this interval will be rounded to the next matching interval.</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WS2812_DRIVER = vendor</span></span></code></pre></div><h3 id="pwm-driver" tabindex="-1">PWM Driver <a class="header-anchor" href="#pwm-driver" aria-label="Permalink to &quot;PWM Driver {#pwm-driver}&quot;">​</a></h3><p>This driver is ARM-only, and leverages the onboard PWM peripheral and DMA to offload processing from the CPU.</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WS2812_DRIVER = pwm</span></span></code></pre></div><h3 id="spi-driver" tabindex="-1">SPI Driver <a class="header-anchor" href="#spi-driver" aria-label="Permalink to &quot;SPI Driver {#spi-driver}&quot;">​</a></h3><p>This driver is ARM-only, and leverages the onboard SPI peripheral and DMA to offload processing from the CPU. The DI pin <strong>must</strong> be connected to the MOSI pin on the MCU, and all other SPI pins <strong>must</strong> be left unused. This is also very dependent on your MCU&#39;s SPI peripheral clock speed, and may or may not be possible depending on the MCU selected.</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">WS2812_DRIVER = spi</span></span></code></pre></div><h2 id="arm-configuration" tabindex="-1">ChibiOS/ARM Configuration <a class="header-anchor" href="#arm-configuration" aria-label="Permalink to &quot;ChibiOS/ARM Configuration {#arm-configuration}&quot;">​</a></h2><p>The following defines apply only to ARM devices:</p><table><thead><tr><th>Define</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>WS2812_T1L</code></td><td><code>(WS2812_TIMING - WS2812_T1H)</code></td><td>The length of a &quot;1&quot; bit&#39;s low phase in nanoseconds (bitbang and PIO drivers only)</td></tr><tr><td><code>WS2812_T0L</code></td><td><code>(WS2812_TIMING - WS2812_T0H)</code></td><td>The length of a &quot;0&quot; bit&#39;s low phase in nanoseconds (bitbang and PIO drivers only)</td></tr></tbody></table><h3 id="logic-levels" tabindex="-1">Logic Levels <a class="header-anchor" href="#logic-levels" aria-label="Permalink to &quot;Logic Levels {#logic-levels}&quot;">​</a></h3><p>WS2812 LEDs usually operate at 5V, but some microcontrollers, particularly ARM-based ones, run on 3.3V. This can pose an issue when driving the LED chain as the logic level voltage is lower than the power supply voltage, leading to unreliable data transmission. There are two main workarounds:</p><h4 id="open-drain-circuit" tabindex="-1">1. Open Drain Circuit <a class="header-anchor" href="#open-drain-circuit" aria-label="Permalink to &quot;1. Open Drain Circuit {#open-drain-circuit}&quot;">​</a></h4><p>By default, <code>WS2812_DI_PIN</code> is configured as a <em>push-pull</em> output, meaning the pin is effectively always driven either to VCC or to ground; however, it can be configured in <em>open drain</em> mode instead.</p><p>In this mode, the MCU will only pull the GPIO <em>low</em>, and leaves it floating otherwise. A pullup resistor (typically around 10kΩ) between DI and 5V is then responsible for pulling the line high when the MCU is not driving the GPIO.</p><p>To use the DI pin in open drain configuration, add the following to your <code>config.h</code>:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WS2812_EXTERNAL_PULLUP</span></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>Because the GPIO is being pulled to 5V in this situation rather than VCC (3.3V), <strong>it must be a 5V tolerant pin</strong>. Consult your MCU&#39;s datasheet first – if there are no eligible pins, you must use a level shifter instead.</p></div><h4 id="level-shifter" tabindex="-1">2. Level Shifter <a class="header-anchor" href="#level-shifter" aria-label="Permalink to &quot;2. Level Shifter {#level-shifter}&quot;">​</a></h4><p>A level shifter IC, such as the SN74LV1T34, can be placed between the GPIO and the first LED&#39;s DI pin to convert the 3.3V logic to 5V. This requires no additional configuration in the firmware, nor a 5V tolerant GPIO, but may be more expensive and is generally less handwire-friendly.</p><h3 id="arm-spi-driver" tabindex="-1">SPI Driver <a class="header-anchor" href="#arm-spi-driver" aria-label="Permalink to &quot;SPI Driver {#arm-spi-driver}&quot;">​</a></h3><p>Depending on the ChibiOS board configuration, you may need to enable SPI at the keyboard level. For STM32, this would look like:</p><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-jJ_Pe" id="tab-ICEctq_" checked="checked"><label for="tab-ICEctq_">halconf.h</label><input type="radio" name="group-jJ_Pe" id="tab-4tR7B9d"><label for="tab-4tR7B9d">mcuconf.h</label></div><div class="blocks"><div class="language-c vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark has-focused-lines vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> once</span></span>\n<span class="line"></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HAL_USE_SPI</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include_next</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;halconf.h&gt;</span></span></code></pre></div><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark has-focused-lines vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> once</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include_next</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;mcuconf.h&gt;</span></span>\n<span class="line"></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#undef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> STM32_SPI_USE_SPI1</span></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> STM32_SPI_USE_SPI1</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span></span></code></pre></div></div></div><p>The following <code>define</code>s apply only to the <code>spi</code> driver:</p><table><thead><tr><th>Define</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>WS2812_SPI_DRIVER</code></td><td><code>SPID1</code></td><td>The SPI driver to use</td></tr><tr><td><code>WS2812_SPI_MOSI_PAL_MODE</code></td><td><code>5</code></td><td>The MOSI pin alternative function to use</td></tr><tr><td><code>WS2812_SPI_SCK_PIN</code></td><td><em>Not defined</em></td><td>The SCK pin - required for F072 and possibly others</td></tr><tr><td><code>WS2812_SPI_SCK_PAL_MODE</code></td><td><code>5</code></td><td>The SCK pin alternative function to use - required for F072 and possibly others</td></tr><tr><td><code>WS2812_SPI_DIVISOR</code></td><td><code>16</code></td><td>The divisor used to adjust the baudrate</td></tr><tr><td><code>WS2812_SPI_USE_CIRCULAR_BUFFER</code></td><td><em>Not defined</em></td><td>Enable a circular buffer for improved rendering</td></tr></tbody></table><h4 id="arm-spi-baudrate" tabindex="-1">Setting the Baudrate <a class="header-anchor" href="#arm-spi-baudrate" aria-label="Permalink to &quot;Setting the Baudrate {#arm-spi-baudrate}&quot;">​</a></h4><p>To adjust the SPI baudrate, you will need to derive the target baudrate from the clock tree provided by STM32CubeMX, and add the following to your <code>config.h</code>:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WS2812_SPI_DIVISOR</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 16</span></span></code></pre></div><p>Only divisors of 2, 4, 8, 16, 32, 64, 128 and 256 are supported on STM32 devices. Other MCUs may have similar constraints -- check the reference manual for your respective MCU for specifics.</p><h4 id="arm-spi-circular-buffer" tabindex="-1">Circular Buffer <a class="header-anchor" href="#arm-spi-circular-buffer" aria-label="Permalink to &quot;Circular Buffer {#arm-spi-circular-buffer}&quot;">​</a></h4><p>A circular buffer can be enabled if you experience flickering.</p><p>To enable the circular buffer, add the following to your <code>config.h</code>:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WS2812_SPI_USE_CIRCULAR_BUFFER</span></span></code></pre></div><h3 id="arm-pio-driver" tabindex="-1">PIO Driver <a class="header-anchor" href="#arm-pio-driver" aria-label="Permalink to &quot;PIO Driver {#arm-pio-driver}&quot;">​</a></h3><p>The following <code>#define</code>s apply only to the PIO driver:</p><table><thead><tr><th>Define</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>WS2812_PIO_USE_PIO1</code></td><td><em>Not defined</em></td><td>Use the PIO1 peripheral instead of PIO0</td></tr></tbody></table><h3 id="arm-pwm-driver" tabindex="-1">PWM Driver <a class="header-anchor" href="#arm-pwm-driver" aria-label="Permalink to &quot;PWM Driver {#arm-pwm-driver}&quot;">​</a></h3><p>Depending on the ChibiOS board configuration, you may need to enable PWM at the keyboard level. For STM32, this would look like:</p><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-Zx0Sz" id="tab-KiSpAGt" checked="checked"><label for="tab-KiSpAGt">halconf.h</label><input type="radio" name="group-Zx0Sz" id="tab-kyCn--P"><label for="tab-kyCn--P">mcuconf.h</label></div><div class="blocks"><div class="language-c vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark has-focused-lines vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> once</span></span>\n<span class="line"></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HAL_USE_PWM</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include_next</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;halconf.h&gt;</span></span></code></pre></div><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark has-focused-lines vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> once</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include_next</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;mcuconf.h&gt;</span></span>\n<span class="line"></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#undef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> STM32_PWM_USE_TIM2</span></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> STM32_PWM_USE_TIM2</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span></span></code></pre></div></div></div><p>The following <code>#define</code>s apply only to the <code>pwm</code> driver:</p><table><thead><tr><th>Define</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>WS2812_PWM_DRIVER</code></td><td><code>PWMD2</code></td><td>The PWM driver to use</td></tr><tr><td><code>WS2812_PWM_CHANNEL</code></td><td><code>2</code></td><td>The PWM channel to use</td></tr><tr><td><code>WS2812_PWM_PAL_MODE</code></td><td><code>2</code></td><td>The pin alternative function to use</td></tr><tr><td><code>WS2812_PWM_DMA_STREAM</code></td><td><code>STM32_DMA1_STREAM2</code></td><td>The DMA Stream for <code>TIMx_UP</code></td></tr><tr><td><code>WS2812_PWM_DMA_CHANNEL</code></td><td><code>2</code></td><td>The DMA Channel for <code>TIMx_UP</code></td></tr><tr><td><code>WS2812_PWM_DMAMUX_ID</code></td><td><em>Not defined</em></td><td>The DMAMUX configuration for <code>TIMx_UP</code> - only required if your MCU has a DMAMUX peripheral</td></tr><tr><td><code>WS2812_PWM_COMPLEMENTARY_OUTPUT</code></td><td><em>Not defined</em></td><td>Whether the PWM output is complementary (<code>TIMx_CHyN</code>)</td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Using a complementary timer output (<code>TIMx_CHyN</code>) is possible only for advanced-control timers (1, 8 and 20 on STM32). Complementary outputs of general-purpose timers are not supported due to ChibiOS limitations.</p></div><h2 id="api" tabindex="-1">API <a class="header-anchor" href="#api" aria-label="Permalink to &quot;API {#api}&quot;">​</a></h2><h3 id="api-ws2812-init" tabindex="-1"><code>void ws2812_init(void)</code> <a class="header-anchor" href="#api-ws2812-init" aria-label="Permalink to &quot;`void ws2812_init(void)` {#api-ws2812-init}&quot;">​</a></h3><p>Initialize the LED driver. This function should be called first.</p><hr><h3 id="api-ws2812-set-color" tabindex="-1"><code>void ws2812_set_color(int index, uint8_t red, uint8_t green, uint8_t blue)</code> <a class="header-anchor" href="#api-ws2812-set-color" aria-label="Permalink to &quot;`void ws2812_set_color(int index, uint8_t red, uint8_t green, uint8_t blue)` {#api-ws2812-set-color}&quot;">​</a></h3><p>Set the color of a single LED. This function does not immediately update the LEDs; call <code>ws2812_flush()</code> after you are finished.</p><h4 id="api-ws2812-set-color-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-ws2812-set-color-arguments" aria-label="Permalink to &quot;Arguments {#api-ws2812-set-color-arguments}&quot;">​</a></h4><ul><li><code>int index</code><br> The LED index in the WS2812 chain.</li><li><code>uint8_t red</code><br> The red value to set.</li><li><code>uint8_t green</code><br> The green value to set.</li><li><code>uint8_t blue</code><br> The blue value to set.</li></ul><hr><h3 id="api-ws2812-set-color-all" tabindex="-1"><code>void ws812_set_color_all(uint8_t red, uint8_t green, uint8_t blue)</code> <a class="header-anchor" href="#api-ws2812-set-color-all" aria-label="Permalink to &quot;`void ws812_set_color_all(uint8_t red, uint8_t green, uint8_t blue)` {#api-ws2812-set-color-all}&quot;">​</a></h3><p>Set the color of all LEDs.</p><h4 id="api-ws2812-set-color-all-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-ws2812-set-color-all-arguments" aria-label="Permalink to &quot;Arguments {#api-ws2812-set-color-all-arguments}&quot;">​</a></h4><ul><li><code>uint8_t red</code><br> The red value to set.</li><li><code>uint8_t green</code><br> The green value to set.</li><li><code>uint8_t blue</code><br> The blue value to set.</li></ul><hr><h3 id="api-ws2812-flush" tabindex="-1"><code>void ws2812_flush(void)</code> <a class="header-anchor" href="#api-ws2812-flush" aria-label="Permalink to &quot;`void ws2812_flush(void)` {#api-ws2812-flush}&quot;">​</a></h3><p>Flush the PWM values to the LED chain.</p>', 99);
const _hoisted_100 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_100);
}
const ws2812 = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  ws2812 as default
};
