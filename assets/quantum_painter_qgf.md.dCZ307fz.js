import { _ as _export_sfc, c as createElementBlock, o as openBlock, a8 as createStaticVNode } from "./chunks/framework.Cauyuiy8.js";
const __pageData = JSON.parse('{"title":"QMK Graphics Format","description":"","frontmatter":{},"headers":[],"relativePath":"quantum_painter_qgf.md","filePath":"quantum_painter_qgf.md","lastUpdated":null}');
const _sfc_main = { name: "quantum_painter_qgf.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="qmk-graphics-format" tabindex="-1">QMK Graphics Format <a class="header-anchor" href="#qmk-graphics-format" aria-label="Permalink to &quot;QMK Graphics Format {#qmk-graphics-format}&quot;">​</a></h1><p>QMK uses a graphics format <em>(&quot;Quantum Graphics Format&quot; - QGF)</em> specifically for resource-constrained systems.</p><p>This format is capable of encoding 1-, 2-, 4-, and 8-bit-per-pixel greyscale- and palette-based images. It also includes RLE for pixel data for some basic compression.</p><p>All integer values are in little-endian format.</p><p>The QGF is defined in terms of <em>blocks</em> -- each <em>block</em> contains a <em>header</em> and an optional <em>blob</em> of data. The <em>header</em> contains the block&#39;s <em>typeid</em>, and the length of the <em>blob</em> that follows. Each block type is denoted by a different <em>typeid</em> has its own block definition below. All blocks are defined as packed structs, containing zero padding between fields.</p><p>The general structure of the file is:</p><ul><li><em>Graphics descriptor block</em></li><li><em>Frame offset block</em></li><li>Repeating list of frames: <ul><li><em>Frame descriptor block</em></li><li><em>Frame palette block</em> (optional, depending on frame format)</li><li><em>Frame delta block</em> (optional, depending on delta flag)</li><li><em>Frame data block</em></li></ul></li></ul><p>Different frames within the file should be considered &quot;isolated&quot; and may have their own image format and/or palette.</p><h2 id="qgf-block-header" tabindex="-1">Block Header <a class="header-anchor" href="#qgf-block-header" aria-label="Permalink to &quot;Block Header {#qgf-block-header}&quot;">​</a></h2><p>This block header is present for all blocks, including the graphics descriptor.</p><p><em>Block header</em> format:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> __attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((packed)) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qgf_block_header_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> type_id;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // See each respective block type</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> neg_type_id;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Negated type ID, used for detecting parsing errors</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    uint24_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 24-bit blob length, allowing for block sizes of a maximum of 16MB</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qgf_block_header_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// STATIC_ASSERT(sizeof(qgf_block_header_v1_t) == 5, &quot;qgf_block_header_v1_t must be 5 bytes in v1 of QGF&quot;);</span></span></code></pre></div><p>The <em>length</em> describes the number of octets in the data following the block header -- a block header may specify a <em>length</em> of <code>0</code> if no blob is specified.</p><h2 id="qgf-graphics-descriptor" tabindex="-1">Graphics descriptor block <a class="header-anchor" href="#qgf-graphics-descriptor" aria-label="Permalink to &quot;Graphics descriptor block {#qgf-graphics-descriptor}&quot;">​</a></h2><ul><li><em>typeid</em> = 0x00</li><li><em>length</em> = 18</li></ul><p>This block must be located at the start of the file contents, and can exist a maximum of once in an entire QGF file. It is always followed by the <em>frame offset block</em>.</p><p><em>Block</em> format:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> __attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((packed)) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qgf_graphics_descriptor_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    qgf_block_header_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> header;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // = { .type_id = 0x00, .neg_type_id = (~0x00), .length = 18 }</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    uint24_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              magic;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // constant, equal to 0x464751 (&quot;QGF&quot;)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">               qgf_version;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // constant, equal to 0x01</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              total_file_size;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // total size of the entire file, starting at offset zero</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              neg_total_file_size;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // negated value of total_file_size, used for detecting parsing errors</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              image_width;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // in pixels</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              image_height;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // in pixels</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              frame_count;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // minimum of 1</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qgf_graphics_descriptor_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// STATIC_ASSERT(sizeof(qgf_graphics_descriptor_v1_t) == (sizeof(qgf_block_header_v1_t) + 18), &quot;qgf_graphics_descriptor_v1_t must be 23 bytes in v1 of QGF&quot;);</span></span></code></pre></div><h2 id="qgf-frame-offset-descriptor" tabindex="-1">Frame offset block <a class="header-anchor" href="#qgf-frame-offset-descriptor" aria-label="Permalink to &quot;Frame offset block {#qgf-frame-offset-descriptor}&quot;">​</a></h2><ul><li><em>typeid</em> = 0x01</li><li><em>length</em> = variable</li></ul><p>This block denotes the offsets within the file to each frame&#39;s <em>frame descriptor block</em>, relative to the start of the file. The <em>frame offset block</em> always immediately follows the <em>graphics descriptor block</em>. The contents of this block are an array of U32&#39;s, with one entry for each frame.</p><p>Duplicate frame offsets in this block are allowed, if a certain frame is to be shown multiple times during animation.</p><p><em>Block</em> format:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> __attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((packed)) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qgf_frame_offsets_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    qgf_block_header_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> header;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // = { .type_id = 0x01, .neg_type_id = (~0x01), .length = (N * sizeof(uint32_t)) }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint32_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">              offset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[N];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // where &#39;N&#39; is the number of frames in the file</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qgf_frame_offsets_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h2 id="qgf-frame-descriptor" tabindex="-1">Frame descriptor block <a class="header-anchor" href="#qgf-frame-descriptor" aria-label="Permalink to &quot;Frame descriptor block {#qgf-frame-descriptor}&quot;">​</a></h2><ul><li><em>typeid</em> = 0x02</li><li><em>length</em> = 5</li></ul><p>This block denotes the start of a frame.</p><p><em>Block</em> format:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> __attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((packed)) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qgf_frame_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    qgf_block_header_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> header;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // = { .type_id = 0x02, .neg_type_id = (~0x02), .length = 5 }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">               format;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              // Frame format, see below.</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">               flags;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // Frame flags, see below.</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">               compression_scheme;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Compression scheme, see below.</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">               transparency_index;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // palette index used for transparent pixels (not yet implemented)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              delay;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // frame delay time for animations (in units of milliseconds)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qgf_frame_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// STATIC_ASSERT(sizeof(qgf_frame_v1_t) == (sizeof(qgf_block_header_v1_t) + 6), &quot;qgf_frame_v1_t must be 11 bytes in v1 of QGF&quot;);</span></span></code></pre></div><p>If this frame is grayscale, the <em>frame descriptor block</em> (or <em>frame delta block</em> if flags denote a delta frame) is immediately followed by this frame&#39;s corresponding <em>frame data block</em>.</p><p>If the frame uses an indexed palette, the <em>frame descriptor block</em> (or <em>frame delta block</em> if flags denote a delta frame) is immediately followed by this frame&#39;s corresponding <em>frame palette block</em>.</p><p>Frame format possible values:</p><ul><li><code>0x00</code>: 1bpp grayscale, no palette, <code>0</code> = black, <code>1</code> = white, LSb first pixel</li><li><code>0x01</code>: 2bpp grayscale, no palette, <code>0</code> = black, <code>3</code> = white, linear interpolation of brightness, LSb first pixel</li><li><code>0x02</code>: 4bpp grayscale, no palette, <code>0</code> = black, <code>15</code> = white, linear interpolation of brightness, LSb first pixel</li><li><code>0x03</code>: 8bpp grayscale, no palette, <code>0</code> = black, <code>255</code> = white, linear interpolation of brightness, LSb first pixel</li><li><code>0x04</code>: 1bpp indexed palette, 2 colors, LSb first pixel</li><li><code>0x05</code>: 2bpp indexed palette, 4 colors, LSb first pixel</li><li><code>0x06</code>: 4bpp indexed palette, 16 colors, LSb first pixel</li><li><code>0x07</code>: 8bpp indexed palette, 256 colors, LSb first pixel</li></ul><p>Frame flags is a bitmask with the following format:</p><table><thead><tr><th><code>bit 7</code></th><th><code>bit 6</code></th><th><code>bit 5</code></th><th><code>bit 4</code></th><th><code>bit 3</code></th><th><code>bit 2</code></th><th><code>bit 1</code></th><th><code>bit 0</code></th></tr></thead><tbody><tr><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>Delta</td><td>Transparency</td></tr></tbody></table><ul><li><code>[1]</code> -- Delta: Signifies that the current frame is a delta frame, which specifies only a sub-image. The <em>frame delta block</em> follows the <em>frame palette block</em> if the image format specifies a palette, otherwise it directly follows the <em>frame descriptor block</em>.</li><li><code>[0]</code> -- Transparency: The transparent palette index in the <em>blob</em> is considered valid and should be used when considering which pixels should be transparent during rendering this frame, if possible.</li></ul><p>Compression scheme possible values:</p><ul><li><code>0x00</code>: No compression</li><li><code>0x01</code>: <a href="./quantum_painter_rle">QMK RLE</a></li></ul><h2 id="qgf-frame-palette-descriptor" tabindex="-1">Frame palette block <a class="header-anchor" href="#qgf-frame-palette-descriptor" aria-label="Permalink to &quot;Frame palette block {#qgf-frame-palette-descriptor}&quot;">​</a></h2><ul><li><em>typeid</em> = 0x03</li><li><em>length</em> = variable</li></ul><p>This block describes the palette used for the frame. The <em>blob</em> contains an array of palette entries -- one palette entry is present for each color used -- each palette entry is in QMK HSV888 format:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> __attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((packed)) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qgf_palette_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    qgf_block_header_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> header;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // = { .type_id = 0x03, .neg_type_id = (~0x03), .length = (N * 3 * sizeof(uint8_t)) }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // container for a single HSV palette entry</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    // hue component: `[0,360)` degrees is mapped to `[0,255]` uint8_t.</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    // saturation component: `[0,1]` is mapped to `[0,255]` uint8_t.</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    // value component: `[0,1]` is mapped to `[0,255]` uint8_t.</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">hsv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[N];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                         // N * hsv, where N is the number of palette entries depending on the frame format in the descriptor</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qgf_palette_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h2 id="qgf-frame-delta-descriptor" tabindex="-1">Frame delta block <a class="header-anchor" href="#qgf-frame-delta-descriptor" aria-label="Permalink to &quot;Frame delta block {#qgf-frame-delta-descriptor}&quot;">​</a></h2><ul><li><em>typeid</em> = 0x04</li><li><em>length</em> = 8</li></ul><p>This block describes where the delta frame should be drawn, with respect to the top left location of the image.</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> __attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((packed)) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qgf_delta_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    qgf_block_header_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> header;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // = { .type_id = 0x04, .neg_type_id = (~0x04), .length = 8 }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> left;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 // The left pixel location to draw the delta image</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> top;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  // The top pixel location to draw the delta image</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> right;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // The right pixel location to to draw the delta image</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bottom;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">               // The bottom pixel location to to draw the delta image</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qgf_delta_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// STATIC_ASSERT(sizeof(qgf_delta_v1_t) == 13, &quot;qgf_delta_v1_t must be 13 bytes in v1 of QGF&quot;);</span></span></code></pre></div><h2 id="qgf-frame-data-descriptor" tabindex="-1">Frame data block <a class="header-anchor" href="#qgf-frame-data-descriptor" aria-label="Permalink to &quot;Frame data block {#qgf-frame-data-descriptor}&quot;">​</a></h2><ul><li><em>typeid</em> = 0x05</li><li><em>length</em> = variable</li></ul><p>This block describes the data associated with the frame. The <em>blob</em> contains an array of bytes containing the data corresponding to the frame&#39;s image format:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typedef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> __attribute__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((packed)) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qgf_data_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    qgf_block_header_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> header;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // = { .type_id = 0x05, .neg_type_id = (~0x05), .length = N }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint8_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">               data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[N];</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // N data octets</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qgf_data_v1_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div>', 50);
const _hoisted_51 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_51);
}
const quantum_painter_qgf = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  quantum_painter_qgf as default
};
