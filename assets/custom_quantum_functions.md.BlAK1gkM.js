import { _ as _export_sfc, c as createElementBlock, o as openBlock, a8 as createStaticVNode } from "./chunks/framework.Cauyuiy8.js";
const __pageData = JSON.parse(`{"title":"How to Customize Your Keyboard's Behavior","description":"","frontmatter":{},"headers":[],"relativePath":"custom_quantum_functions.md","filePath":"custom_quantum_functions.md","lastUpdated":null}`);
const _sfc_main = { name: "custom_quantum_functions.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="how-to-customize-your-keyboard-s-behavior" tabindex="-1">How to Customize Your Keyboard&#39;s Behavior <a class="header-anchor" href="#how-to-customize-your-keyboard-s-behavior" aria-label="Permalink to &quot;How to Customize Your Keyboard&#39;s Behavior&quot;">​</a></h1><p>For a lot of people a custom keyboard is about more than sending button presses to your computer. You want to be able to do things that are more complex than simple button presses and macros. QMK has hooks that allow you to inject code, override functionality, and otherwise customize how your keyboard behaves in different situations.</p><p>This page does not assume any special knowledge about QMK, but reading <a href="./understanding_qmk">Understanding QMK</a> will help you understand what is going on at a more fundamental level.</p><h2 id="a-word-on-core-vs-keyboards-vs-keymap" tabindex="-1">A Word on Core vs Keyboards vs Keymap <a class="header-anchor" href="#a-word-on-core-vs-keyboards-vs-keymap" aria-label="Permalink to &quot;A Word on Core vs Keyboards vs Keymap {#a-word-on-core-vs-keyboards-vs-keymap}&quot;">​</a></h2><p>We have structured QMK as a hierarchy:</p><ul><li>Core (<code>_quantum</code>) <ul><li>Community Module (<code>_&lt;module&gt;</code>) <ul><li>Community Module -&gt; Keyboard/Revision (<code>_&lt;module&gt;_kb</code>) <ul><li>Community Module -&gt; Keymap (<code>_&lt;module&gt;_user</code>)</li></ul></li></ul></li><li>Keyboard/Revision (<code>_kb</code>) <ul><li>Keymap (<code>_user</code>)</li></ul></li></ul></li></ul><p>Each of the functions described below can be defined with a <code>_kb()</code> suffix or a <code>_user()</code> suffix. We intend for you to use the <code>_kb()</code> suffix at the Keyboard/Revision level, while the <code>_user()</code> suffix should be used at the Keymap level.</p><p>When defining functions at the Keyboard/Revision level it is important that your <code>_kb()</code> implementation call <code>_user()</code> at an appropriate location, otherwise the keymap level function will never be called.</p><p>Functions at the <code>_&lt;module&gt;_xxx()</code> level are intended to allow keyboards or keymaps to override or enhance the processing associated with a <a href="/features/community_modules">community module</a>.</p><p>When defining module overrides such as <code>process_record_&lt;module&gt;()</code>, the same pattern should be used; the module must invoke <code>process_record_&lt;module&gt;_kb()</code> as appropriate.</p><h1 id="custom-keycodes" tabindex="-1">Custom Keycodes <a class="header-anchor" href="#custom-keycodes" aria-label="Permalink to &quot;Custom Keycodes&quot;">​</a></h1><p>By far the most common task is to change the behavior of an existing keycode or to create a new keycode. From a code standpoint the mechanism for each is very similar.</p><h2 id="defining-a-new-keycode" tabindex="-1">Defining a New Keycode <a class="header-anchor" href="#defining-a-new-keycode" aria-label="Permalink to &quot;Defining a New Keycode&quot;">​</a></h2><p>The first step to creating your own custom keycode(s) is to enumerate them. This means both naming them and assigning a unique number to that keycode. Rather than limit custom keycodes to a fixed range of numbers QMK provides the <code>SAFE_RANGE</code> macro. You can use <code>SAFE_RANGE</code> when enumerating your custom keycodes to guarantee that you get a unique number.</p><p>Here is an example of enumerating 2 keycodes. After adding this block to your <code>keymap.c</code> you will be able to use <code>FOO</code> and <code>BAR</code> inside your keymap.</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">enum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> my_keycodes {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  FOO </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SAFE_RANGE,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  BAR</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="programming-the-behavior-of-any-keycode" tabindex="-1">Programming the Behavior of Any Keycode <a class="header-anchor" href="#programming-the-behavior-of-any-keycode" aria-label="Permalink to &quot;Programming the Behavior of Any Keycode {#programming-the-behavior-of-any-keycode}&quot;">​</a></h2><p>When you want to override the behavior of an existing key, or define the behavior for a new key, you should use the <code>process_record_kb()</code> and <code>process_record_user()</code> functions. These are called by QMK during key processing before the actual key event is handled. If these functions return <code>true</code> QMK will process the keycodes as usual. That can be handy for extending the functionality of a key rather than replacing it. If these functions return <code>false</code> QMK will skip the normal key handling, and it will be up to you to send any key up or down events that are required.</p><p>These function are called every time a key is pressed or released.</p><h3 id="example-process-record-user-implementation" tabindex="-1">Example <code>process_record_user()</code> Implementation <a class="header-anchor" href="#example-process-record-user-implementation" aria-label="Permalink to &quot;Example `process_record_user()` Implementation&quot;">​</a></h3><p>This example does two things. It defines the behavior for a custom keycode called <code>FOO</code>, and it supplements our Enter key by playing a tone whenever it is pressed.</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> process_record_user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint16_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> keycode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">keyrecord_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">record</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (keycode) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FOO:</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (record</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">event.pressed) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Do something when pressed</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Do something else when release</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Skip all further processing of this key</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KC_ENTER:</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // Play a tone when enter is pressed</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (record</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">event.pressed) {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        PLAY_SONG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(tone_qwerty);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Let QMK send the enter press/release events</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Process all other keycodes normally</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="process-record-function-documentation" tabindex="-1"><code>process_record_*</code> Function Documentation <a class="header-anchor" href="#process-record-function-documentation" aria-label="Permalink to &quot;`process_record_*` Function Documentation&quot;">​</a></h3><ul><li>Keyboard/Revision: <code>bool process_record_kb(uint16_t keycode, keyrecord_t *record)</code></li><li>Keymap: <code>bool process_record_user(uint16_t keycode, keyrecord_t *record)</code></li></ul><p>The <code>keycode</code> argument is whatever is defined in your keymap, eg <code>MO(1)</code>, <code>KC_L</code>, etc. You should use a <code>switch...case</code> block to handle these events.</p><p>The <code>record</code> argument contains information about the actual press:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">keyrecord_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> record {</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  keyevent_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> event {</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    keypos_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> col</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> row</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     pressed</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint16_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> time</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h1 id="keyboard-initialization-code" tabindex="-1">Keyboard Initialization Code <a class="header-anchor" href="#keyboard-initialization-code" aria-label="Permalink to &quot;Keyboard Initialization Code&quot;">​</a></h1><p>There are several steps in the keyboard initialization process. Depending on what you want to do, it will influence which function you should use.</p><p>These are the three main initialization functions, listed in the order that they&#39;re called.</p><ul><li><code>keyboard_pre_init_*</code> - Happens before most anything is started. Good for hardware setup that you want running very early.</li><li><code>matrix_init_*</code> - Happens midway through the firmware&#39;s startup process. Hardware is initialized, but features may not be yet.</li><li><code>keyboard_post_init_*</code> - Happens at the end of the firmware&#39;s startup process. This is where you&#39;d want to put &quot;customization&quot; code, for the most part.</li></ul><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>For most people, the <code>keyboard_post_init_user</code> function is what you want to implement. For instance, this is where you want to set up things for RGB Underglow.</p></div><h2 id="keyboard-pre-initialization-code" tabindex="-1">Keyboard Pre Initialization code <a class="header-anchor" href="#keyboard-pre-initialization-code" aria-label="Permalink to &quot;Keyboard Pre Initialization code&quot;">​</a></h2><p>This runs very early during startup, even before the USB has been started.</p><p>Shortly after this, the matrix is initialized.</p><p>For most users, this shouldn&#39;t be used, as it&#39;s primarily for hardware oriented initialization.</p><p>However, if you have hardware stuff that you need initialized, this is the best place for it (such as initializing LED pins).</p><h3 id="example-keyboard-pre-init-user-implementation" tabindex="-1">Example <code>keyboard_pre_init_user()</code> Implementation <a class="header-anchor" href="#example-keyboard-pre-init-user-implementation" aria-label="Permalink to &quot;Example `keyboard_pre_init_user()` Implementation&quot;">​</a></h3><p>This example, at the keyboard level, sets up B0, B1, B2, B3, and B4 as LED pins.</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> keyboard_pre_init_user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Call the keyboard pre init code.</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Set our LED pins as output</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  gpio_set_pin_output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(B0);</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  gpio_set_pin_output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(B1);</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  gpio_set_pin_output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(B2);</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  gpio_set_pin_output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(B3);</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  gpio_set_pin_output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(B4);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="keyboard-pre-init-function-documentation" tabindex="-1"><code>keyboard_pre_init_*</code> Function Documentation <a class="header-anchor" href="#keyboard-pre-init-function-documentation" aria-label="Permalink to &quot;`keyboard_pre_init_*` Function Documentation&quot;">​</a></h3><ul><li>Keyboard/Revision: <code>void keyboard_pre_init_kb(void)</code></li><li>Keymap: <code>void keyboard_pre_init_user(void)</code></li></ul><h2 id="matrix-initialization-code" tabindex="-1">Matrix Initialization Code <a class="header-anchor" href="#matrix-initialization-code" aria-label="Permalink to &quot;Matrix Initialization Code&quot;">​</a></h2><p>This is called when the matrix is initialized, and after some of the hardware has been set up, but before many of the features have been initialized.</p><p>This is useful for setting up stuff that you may need elsewhere, but isn&#39;t hardware related nor is dependent on where it&#39;s started.</p><h3 id="matrix-init-function-documentation" tabindex="-1"><code>matrix_init_*</code> Function Documentation <a class="header-anchor" href="#matrix-init-function-documentation" aria-label="Permalink to &quot;`matrix_init_*` Function Documentation&quot;">​</a></h3><ul><li>Keyboard/Revision: <code>void matrix_init_kb(void)</code></li><li>Keymap: <code>void matrix_init_user(void)</code></li></ul><h3 id="low-level-matrix-overrides" tabindex="-1">Low-level Matrix Overrides Function Documentation <a class="header-anchor" href="#low-level-matrix-overrides" aria-label="Permalink to &quot;Low-level Matrix Overrides Function Documentation {#low-level-matrix-overrides}&quot;">​</a></h3><ul><li>GPIO pin initialisation: <code>void matrix_init_pins(void)</code><ul><li>This needs to perform the low-level initialisation of all row and column pins. By default this will initialise the input/output state of each of the GPIO pins listed in <code>MATRIX_ROW_PINS</code> and <code>MATRIX_COL_PINS</code>, based on whether or not the keyboard is set up for <code>ROW2COL</code>, <code>COL2ROW</code>, or <code>DIRECT_PINS</code>. Should the keyboard designer override this function, no initialisation of pin state will occur within QMK itself, instead deferring to the keyboard&#39;s override.</li></ul></li><li><code>COL2ROW</code>-based row reads: <code>void matrix_read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)</code></li><li><code>ROW2COL</code>-based column reads: <code>void matrix_read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col, matrix_row_t row_shifter)</code></li><li><code>DIRECT_PINS</code>-based reads: <code>void matrix_read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row)</code><ul><li>These three functions need to perform the low-level retrieval of matrix state of relevant input pins, based on the matrix type. Only one of the functions should be implemented, if needed. By default this will iterate through <code>MATRIX_ROW_PINS</code> and <code>MATRIX_COL_PINS</code>, configuring the inputs and outputs based on whether or not the keyboard is set up for <code>ROW2COL</code>, <code>COL2ROW</code>, or <code>DIRECT_PINS</code>. Should the keyboard designer override this function, no manipulation of matrix GPIO pin state will occur within QMK itself, instead deferring to the keyboard&#39;s override.</li></ul></li></ul><h2 id="keyboard-post-initialization-code" tabindex="-1">Keyboard Post Initialization code <a class="header-anchor" href="#keyboard-post-initialization-code" aria-label="Permalink to &quot;Keyboard Post Initialization code&quot;">​</a></h2><p>This is ran as the very last task in the keyboard initialization process. This is useful if you want to make changes to certain features, as they should be initialized by this point.</p><h3 id="example-keyboard-post-init-user-implementation" tabindex="-1">Example <code>keyboard_post_init_user()</code> Implementation <a class="header-anchor" href="#example-keyboard-post-init-user-implementation" aria-label="Permalink to &quot;Example `keyboard_post_init_user()` Implementation&quot;">​</a></h3><p>This example, running after everything else has initialized, sets up the rgb underglow configuration.</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> keyboard_post_init_user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // Call the post init code.</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  rgblight_enable_noeeprom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // enables Rgb, without saving settings</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  rgblight_sethsv_noeeprom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">180</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // sets the color to teal/cyan without saving</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  rgblight_mode_noeeprom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RGBLIGHT_MODE_BREATHING </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // sets mode to Fast breathing without saving</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="keyboard-post-init-function-documentation" tabindex="-1"><code>keyboard_post_init_*</code> Function Documentation <a class="header-anchor" href="#keyboard-post-init-function-documentation" aria-label="Permalink to &quot;`keyboard_post_init_*` Function Documentation&quot;">​</a></h3><ul><li>Keyboard/Revision: <code>void keyboard_post_init_kb(void)</code></li><li>Keymap: <code>void keyboard_post_init_user(void)</code></li></ul><h1 id="matrix-scanning-code" tabindex="-1">Matrix Scanning Code <a class="header-anchor" href="#matrix-scanning-code" aria-label="Permalink to &quot;Matrix Scanning Code&quot;">​</a></h1><p>Whenever possible you should customize your keyboard by using <code>process_record_*()</code> and hooking into events that way, to ensure that your code does not have a negative performance impact on your keyboard. However, in rare cases it is necessary to hook into the matrix scanning. Be extremely careful with the performance of code in these functions, as it will be called at least 10 times per second.</p><h3 id="example-matrix-scan-implementation" tabindex="-1">Example <code>matrix_scan_*</code> Implementation <a class="header-anchor" href="#example-matrix-scan-implementation" aria-label="Permalink to &quot;Example `matrix_scan_*` Implementation&quot;">​</a></h3><p>This example has been deliberately omitted. You should understand enough about QMK internals to write this without an example before hooking into such a performance sensitive area. If you need help please <a href="https://github.com/qmk/qmk_firmware/issues/new" target="_blank" rel="noreferrer">open an issue</a> or <a href="https://discord.gg/qmk" target="_blank" rel="noreferrer">chat with us on Discord</a>.</p><h3 id="matrix-scan-function-documentation" tabindex="-1"><code>matrix_scan_*</code> Function Documentation <a class="header-anchor" href="#matrix-scan-function-documentation" aria-label="Permalink to &quot;`matrix_scan_*` Function Documentation&quot;">​</a></h3><ul><li>Keyboard/Revision: <code>void matrix_scan_kb(void)</code></li><li>Keymap: <code>void matrix_scan_user(void)</code></li></ul><p>This function gets called at every matrix scan, which is basically as often as the MCU can handle. Be careful what you put here, as it will get run a lot.</p><p>You should use this function if you need custom matrix scanning code. It can also be used for custom status output (such as LEDs or a display) or other functionality that you want to trigger regularly even when the user isn&#39;t typing.</p><h1 id="keyboard-housekeeping" tabindex="-1">Keyboard housekeeping <a class="header-anchor" href="#keyboard-housekeeping" aria-label="Permalink to &quot;Keyboard housekeeping&quot;">​</a></h1><ul><li>Keyboard/Revision: <code>void housekeeping_task_kb(void)</code></li><li>Keymap: <code>void housekeeping_task_user(void)</code></li></ul><p>This function gets called at the end of all QMK processing, before starting the next iteration. You can safely assume that QMK has dealt with the last matrix scan at the time that these functions are invoked -- layer states have been updated, USB reports have been sent, LEDs have been updated, and displays have been drawn.</p><p>Similar to <code>matrix_scan_*</code>, these are called as often as the MCU can handle. To keep your board responsive, it&#39;s suggested to do as little as possible during these function calls, potentially throttling their behaviour if you do indeed require implementing something special.</p><h3 id="example-void-housekeeping-task-user-void-implementation" tabindex="-1">Example <code>void housekeeping_task_user(void)</code> implementation <a class="header-anchor" href="#example-void-housekeeping-task-user-void-implementation" aria-label="Permalink to &quot;Example `void housekeeping_task_user(void)` implementation&quot;">​</a></h3><p>This example will show you how to use <code>void housekeeping_task_user(void)</code> to turn off <a href="./features/rgblight">RGB Light</a>. For RGB Matrix, the <a href="./features/rgb_matrix#additional-configh-options">builtin</a> <code>RGB_MATRIX_TIMEOUT</code> should be used.</p><p>First, add the following lines to your keymap&#39;s <code>config.h</code>:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RGBLIGHT_SLEEP</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // enable rgblight_suspend() and rgblight_wakeup() in keymap.c</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RGBLIGHT_TIMEOUT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 900000</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ms to wait until rgblight time out, 900K ms is 15min.</span></span></code></pre></div><p>Next, add the following code to your <code>keymap.c</code>:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key_timer;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">           // timer for last keyboard activity, use 32bit value and function to make longer idle time possible</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> refresh_rgb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       // refreshes the activity timer and RGB, invoke whenever any activity happens</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> check_rgb_timeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // checks if enough time has passed for RGB to timeout</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> is_rgb_timeout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // store if RGB has timed out or not in a boolean</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> refresh_rgb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    key_timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> timer_read32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // store time of last refresh</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (is_rgb_timeout)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        is_rgb_timeout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        rgblight_wakeup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> check_rgb_timeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">is_rgb_timeout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> timer_elapsed32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key_timer) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RGBLIGHT_TIMEOUT)</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // check if RGB has already timeout and if enough time has passed</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        rgblight_suspend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        is_rgb_timeout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Then, call the above functions from QMK&#39;s built in post processing functions like so */</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Runs at the end of each scan loop, check if RGB timeout has occurred or not */</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> housekeeping_task_user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#ifdef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RGBLIGHT_TIMEOUT</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    check_rgb_timeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Runs after each key press, check if activity occurred */</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> post_process_record_user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint16_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> keycode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">keyrecord_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">record</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#ifdef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RGBLIGHT_TIMEOUT</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (record-&gt;event.pressed)</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        refresh_rgb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Runs after each encoder tick, check if activity occurred */</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> post_encoder_update_user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint8_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> clockwise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#ifdef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RGBLIGHT_TIMEOUT</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    refresh_rgb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#endif</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h1 id="keyboard-idling-wake-code" tabindex="-1">Keyboard Idling/Wake Code <a class="header-anchor" href="#keyboard-idling-wake-code" aria-label="Permalink to &quot;Keyboard Idling/Wake Code&quot;">​</a></h1><p>If the board supports it, it can be &quot;idled&quot;, by stopping a number of functions. A good example of this is RGB lights or backlights. This can save on power consumption, or may be better behavior for your keyboard.</p><p>This is controlled by two functions: <code>suspend_power_down_*</code> and <code>suspend_wakeup_init_*</code>, which are called when the system board is idled and when it wakes up, respectively.</p><h3 id="example-suspend-power-down-user-and-suspend-wakeup-init-user-implementation" tabindex="-1">Example <code>suspend_power_down_user()</code> and <code>suspend_wakeup_init_user()</code> Implementation <a class="header-anchor" href="#example-suspend-power-down-user-and-suspend-wakeup-init-user-implementation" aria-label="Permalink to &quot;Example `suspend_power_down_user()` and `suspend_wakeup_init_user()` Implementation&quot;">​</a></h3><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> suspend_power_down_user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // code will run multiple times while keyboard is suspended</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> suspend_wakeup_init_user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // code will run on keyboard wakeup</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="keyboard-suspend-wake-function-documentation" tabindex="-1">Keyboard suspend/wake Function Documentation <a class="header-anchor" href="#keyboard-suspend-wake-function-documentation" aria-label="Permalink to &quot;Keyboard suspend/wake  Function Documentation&quot;">​</a></h3><ul><li>Keyboard/Revision: <code>void suspend_power_down_kb(void)</code> and <code>void suspend_wakeup_init_user(void)</code></li><li>Keymap: <code>void suspend_power_down_kb(void)</code> and <code>void suspend_wakeup_init_user(void)</code></li></ul><h1 id="keyboard-shutdown-reboot-code" tabindex="-1">Keyboard Shutdown/Reboot Code <a class="header-anchor" href="#keyboard-shutdown-reboot-code" aria-label="Permalink to &quot;Keyboard Shutdown/Reboot Code {#keyboard-shutdown-reboot-code}&quot;">​</a></h1><p>This function gets called whenever the firmware is reset, whether it&#39;s a soft reset or reset to the bootloader. This is the spot to use for any sort of cleanup, as this happens right before the actual reset. And it can be useful for turning off different systems (such as RGB, onboard screens, etc).</p><p>Additionally, it differentiates between the soft reset (eg, rebooting back into the firmware) or jumping to the bootloader.</p><p>Certain tasks are performed during shutdown too. The keyboard is cleared, music and midi is stopped (if enabled), the shutdown chime is triggered (if audio is enabled), and haptic is stopped.</p><p>If <code>jump_to_bootloader</code> is set to <code>true</code>, this indicates that the board will be entering the bootloader for a new firmware flash, whereas <code>false</code> indicates that this is happening for a soft reset and will load the firmware agaim immediately (such as when using <code>QK_REBOOT</code> or <code>QK_CLEAR_EEPROM</code>).</p><p>As there is a keyboard and user level function, returning <code>false</code> for the user function will disable the keyboard level function, allowing for customization.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Bootmagic does not trigger <code>shutdown_*()</code> as it happens before most of the initialization process.</p></div><h3 id="example-shutdown-kb-implementation" tabindex="-1">Example <code>shutdown_kb()</code> Implementation <a class="header-anchor" href="#example-shutdown-kb-implementation" aria-label="Permalink to &quot;Example `shutdown_kb()` Implementation&quot;">​</a></h3><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shutdown_kb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> jump_to_bootloader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">shutdown_user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(jump_to_bootloader)) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (jump_to_bootloader) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // red for bootloader</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        rgb_matrix_set_color_all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RGB_OFF);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // off for soft reset</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        rgb_matrix_set_color_all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RGB_GREEN);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // force flushing -- otherwise will never happen</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    rgb_matrix_update_pwm_buffers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="example-shutdown-user-implementation" tabindex="-1">Example <code>shutdown_user()</code> Implementation <a class="header-anchor" href="#example-shutdown-user-implementation" aria-label="Permalink to &quot;Example `shutdown_user()` Implementation&quot;">​</a></h3><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> shutdown_user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> jump_to_bootloader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (jump_to_bootloader) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // red for bootloader</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        rgb_matrix_set_color_all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RGB_RED);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // off for soft reset</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        rgb_matrix_set_color_all</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RGB_OFF);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // force flushing -- otherwise will never happen</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    rgb_matrix_update_pwm_buffers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // false to not process kb level</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="keyboard-shutdown-reboot-function-documentation" tabindex="-1">Keyboard shutdown/reboot Function Documentation <a class="header-anchor" href="#keyboard-shutdown-reboot-function-documentation" aria-label="Permalink to &quot;Keyboard shutdown/reboot Function Documentation&quot;">​</a></h3><ul><li>Keyboard/Revision: <code>bool shutdown_kb(bool jump_to_bootloader)</code></li><li>Keymap: <code>bool shutdown_user(bool jump_to_bootloader)</code></li></ul><h1 id="deferred-execution" tabindex="-1">Deferred Execution <a class="header-anchor" href="#deferred-execution" aria-label="Permalink to &quot;Deferred Execution {#deferred-execution}&quot;">​</a></h1><p>QMK has the ability to execute a callback after a specified period of time, rather than having to manually manage timers. To enable this functionality, set <code>DEFERRED_EXEC_ENABLE = yes</code> in rules.mk.</p><h2 id="deferred-executor-callbacks" tabindex="-1">Deferred executor callbacks <a class="header-anchor" href="#deferred-executor-callbacks" aria-label="Permalink to &quot;Deferred executor callbacks&quot;">​</a></h2><p>All <em>deferred executor callbacks</em> have a common function signature and look like:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint32_t</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> my_callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint32_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> trigger_time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cb_arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /* do something */</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repeat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> my_deferred_functionality</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> repeat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 500</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>The first argument <code>trigger_time</code> is the intended time of execution. If other delays prevent executing at the exact trigger time, this allows for &quot;catch-up&quot; or even skipping intervals, depending on the required behaviour.</p><p>The second argument <code>cb_arg</code> is the same argument passed into <code>defer_exec()</code> below, and can be used to access state information from the original call context.</p><p>The return value is the number of milliseconds to use if the function should be repeated -- if the callback returns <code>0</code> then it&#39;s automatically unregistered. In the example above, a hypothetical <code>my_deferred_functionality()</code> is invoked to determine if the callback needs to be repeated -- if it does, it reschedules for a <code>500</code> millisecond delay, otherwise it informs the deferred execution background task that it&#39;s done, by returning <code>0</code>.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Note that the returned delay will be applied to the intended trigger time, not the time of callback invocation. This allows for generally consistent timing even in the face of occasional late execution.</p></div><h2 id="deferred-executor-registration" tabindex="-1">Deferred executor registration <a class="header-anchor" href="#deferred-executor-registration" aria-label="Permalink to &quot;Deferred executor registration&quot;">​</a></h2><p>Once a callback has been defined, it can be scheduled using the following API:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">deferred_token my_token </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defer_exec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1500</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, my_callback, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">NULL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>The first argument is the number of milliseconds to wait until executing <code>my_callback</code> -- in the case above, <code>1500</code> milliseconds, or 1.5 seconds.</p><p>The third parameter is the <code>cb_arg</code> that gets passed to the callback at the point of execution. This value needs to be valid at the time the callback is invoked -- a local function value will be destroyed before the callback is executed and should not be used. If this is not required, <code>NULL</code> should be used.</p><p>The return value is a <code>deferred_token</code> that can consequently be used to cancel the deferred executor callback before it&#39;s invoked. If a failure occurs, the returned value will be <code>INVALID_DEFERRED_TOKEN</code>. Usually this will be as a result of supplying <code>0</code> to the delay, or a <code>NULL</code> for the callback. The other failure case is if there are too many deferred executions &quot;in flight&quot; -- this can be increased by changing the limit, described below.</p><h2 id="extending-a-deferred-execution" tabindex="-1">Extending a deferred execution <a class="header-anchor" href="#extending-a-deferred-execution" aria-label="Permalink to &quot;Extending a deferred execution&quot;">​</a></h2><p>The <code>deferred_token</code> returned by <code>defer_exec()</code> can be used to extend a the duration a pending execution waits before it gets invoked:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// This will re-delay my_token&#39;s future execution such that it is invoked 800ms after the current time</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">extend_deferred_exec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(my_token, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">800</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="cancelling-a-deferred-execution" tabindex="-1">Cancelling a deferred execution <a class="header-anchor" href="#cancelling-a-deferred-execution" aria-label="Permalink to &quot;Cancelling a deferred execution&quot;">​</a></h2><p>The <code>deferred_token</code> returned by <code>defer_exec()</code> can be used to cancel a pending execution before it gets invoked:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// This will cancel my_token&#39;s future execution</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cancel_deferred_exec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(my_token);</span></span></code></pre></div><p>Once a token has been canceled, it should be considered invalid. Reusing the same token is not supported.</p><h2 id="deferred-callback-limits" tabindex="-1">Deferred callback limits <a class="header-anchor" href="#deferred-callback-limits" aria-label="Permalink to &quot;Deferred callback limits&quot;">​</a></h2><p>There are a maximum number of deferred callbacks that can be scheduled, controlled by the value of the define <code>MAX_DEFERRED_EXECUTORS</code>.</p><p>If registrations fail, then you can increase this value in your keyboard or keymap <code>config.h</code> file, for example to 16 instead of the default 8:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MAX_DEFERRED_EXECUTORS</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 16</span></span></code></pre></div><h1 id="advanced-topics" tabindex="-1">Advanced topics <a class="header-anchor" href="#advanced-topics" aria-label="Permalink to &quot;Advanced topics {#advanced-topics}&quot;">​</a></h1><p>This page used to encompass a large set of features. We have moved many sections that used to be part of this page to their own pages. Everything below this point is simply a redirect so that people following old links on the web find what they&#39;re looking for.</p><h2 id="layer-change-code" tabindex="-1">Layer Change Code <a class="header-anchor" href="#layer-change-code" aria-label="Permalink to &quot;Layer Change Code {#layer-change-code}&quot;">​</a></h2><p><a href="./feature_layers#layer-change-code">Layer change code</a></p><h2 id="persistent-configuration-eeprom" tabindex="-1">Persistent Configuration (EEPROM) <a class="header-anchor" href="#persistent-configuration-eeprom" aria-label="Permalink to &quot;Persistent Configuration (EEPROM) {#persistent-configuration-eeprom}&quot;">​</a></h2><p><a href="./feature_eeprom">Persistent Configuration (EEPROM)</a></p>', 126);
const _hoisted_127 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_127);
}
const custom_quantum_functions = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  custom_quantum_functions as default
};
