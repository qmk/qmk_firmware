import { _ as _export_sfc, c as createElementBlock, o as openBlock, a8 as createStaticVNode } from "./chunks/framework.Cauyuiy8.js";
const __pageData = JSON.parse('{"title":"Backlighting","description":"","frontmatter":{},"headers":[],"relativePath":"features/backlight.md","filePath":"features/backlight.md","lastUpdated":null}');
const _sfc_main = { name: "features/backlight.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="backlighting" tabindex="-1">Backlighting <a class="header-anchor" href="#backlighting" aria-label="Permalink to &quot;Backlighting {#backlighting}&quot;">​</a></h1><p>Many keyboards support backlit keys by way of individual LEDs placed through or underneath the keyswitches. This feature is distinct from both the <a href="./rgblight">RGB Underglow</a> and <a href="./rgb_matrix">RGB Matrix</a> features as it usually allows for only a single colour per switch, though you can obviously install multiple different single coloured LEDs on a keyboard.</p><p>QMK is able to control the brightness of these LEDs by switching them on and off rapidly in a certain ratio, a technique known as <em>Pulse Width Modulation</em>, or PWM. By altering the duty cycle of the PWM signal, it creates the illusion of dimming.</p><h2 id="usage" tabindex="-1">Usage <a class="header-anchor" href="#usage" aria-label="Permalink to &quot;Usage {#usage}&quot;">​</a></h2><p>Most keyboards have backlighting enabled by default if they support it, but if it is not working for you (or you have added support), check that your <code>rules.mk</code> includes the following:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BACKLIGHT_ENABLE = yes</span></span></code></pre></div><h2 id="keycodes" tabindex="-1">Keycodes <a class="header-anchor" href="#keycodes" aria-label="Permalink to &quot;Keycodes {#keycodes}&quot;">​</a></h2><table><thead><tr><th>Key</th><th>Aliases</th><th>Description</th></tr></thead><tbody><tr><td><code>QK_BACKLIGHT_TOGGLE</code></td><td><code>BL_TOGG</code></td><td>Turn the backlight on or off</td></tr><tr><td><code>QK_BACKLIGHT_STEP</code></td><td><code>BL_STEP</code></td><td>Cycle through backlight levels</td></tr><tr><td><code>QK_BACKLIGHT_ON</code></td><td><code>BL_ON</code></td><td>Set the backlight to max brightness</td></tr><tr><td><code>QK_BACKLIGHT_OFF</code></td><td><code>BL_OFF</code></td><td>Turn the backlight off</td></tr><tr><td><code>QK_BACKLIGHT_UP</code></td><td><code>BL_UP</code></td><td>Increase the backlight level</td></tr><tr><td><code>QK_BACKLIGHT_DOWN</code></td><td><code>BL_DOWN</code></td><td>Decrease the backlight level</td></tr><tr><td><code>QK_BACKLIGHT_TOGGLE_BREATHING</code></td><td><code>BL_BRTG</code></td><td>Toggle backlight breathing</td></tr></tbody></table><h2 id="basic-configuration" tabindex="-1">Basic Configuration <a class="header-anchor" href="#basic-configuration" aria-label="Permalink to &quot;Basic Configuration {#basic-configuration}&quot;">​</a></h2><p>Add the following to your <code>config.h</code>:</p><table><thead><tr><th>Define</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>BACKLIGHT_PIN</code></td><td><em>Not defined</em></td><td>The pin that controls the LEDs</td></tr><tr><td><code>BACKLIGHT_LEVELS</code></td><td><code>3</code></td><td>The number of brightness levels (maximum 31 excluding off)</td></tr><tr><td><code>BACKLIGHT_CAPS_LOCK</code></td><td><em>Not defined</em></td><td>Enable Caps Lock indicator using backlight (for keyboards without dedicated LED)</td></tr><tr><td><code>BACKLIGHT_BREATHING</code></td><td><em>Not defined</em></td><td>Enable backlight breathing, if supported</td></tr><tr><td><code>BREATHING_PERIOD</code></td><td><code>6</code></td><td>The length of one backlight &quot;breath&quot; in seconds</td></tr><tr><td><code>BACKLIGHT_ON_STATE</code></td><td><code>1</code></td><td>The state of the backlight pin when the backlight is &quot;on&quot; - <code>1</code> for high, <code>0</code> for low</td></tr><tr><td><code>BACKLIGHT_LIMIT_VAL</code></td><td><code>255</code></td><td>The maximum duty cycle of the backlight -- <code>255</code> allows for full brightness, any lower will decrease the maximum.</td></tr><tr><td><code>BACKLIGHT_DEFAULT_ON</code></td><td><code>true</code></td><td>Enable backlight upon clearing the EEPROM</td></tr><tr><td><code>BACKLIGHT_DEFAULT_BREATHING</code></td><td><code>false</code></td><td>Whether to enable backlight breathing upon clearing the EEPROM</td></tr><tr><td><code>BACKLIGHT_DEFAULT_LEVEL</code></td><td><code>BACKLIGHT_LEVELS</code></td><td>The default backlight level to use upon clearing the EEPROM</td></tr></tbody></table><p>Unless you are designing your own keyboard, you generally should not need to change the <code>BACKLIGHT_PIN</code> or <code>BACKLIGHT_ON_STATE</code>.</p><h3 id="on-state" tabindex="-1">&quot;On&quot; State <a class="header-anchor" href="#on-state" aria-label="Permalink to &quot;&quot;On&quot; State {#on-state}&quot;">​</a></h3><p>Most backlight circuits are driven by an N-channel MOSFET or NPN transistor. This means that to turn the transistor <em>on</em> and light the LEDs, you must drive the backlight pin, connected to the gate or base, <em>high</em>. Sometimes, however, a P-channel MOSFET, or a PNP transistor is used. In this case, when the transistor is on, the pin is driven <em>low</em> instead.</p><p>To configure the &quot;on&quot; state of the backlight circuit, add the following to your <code>config.h</code>:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BACKLIGHT_ON_STATE</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre></div><h3 id="multiple-backlight-pins" tabindex="-1">Multiple Backlight Pins <a class="header-anchor" href="#multiple-backlight-pins" aria-label="Permalink to &quot;Multiple Backlight Pins {#multiple-backlight-pins}&quot;">​</a></h3><p>Most keyboards have only one backlight pin which controls all backlight LEDs (especially if the backlight is connected to a hardware PWM pin). The <code>timer</code> and <code>software</code> drivers allow you to define multiple backlight pins, which will be turned on and off at the same time during the PWM duty cycle.</p><p>This feature allows to set, for instance, the Caps Lock LED&#39;s (or any other controllable LED) brightness at the same level as the other LEDs of the backlight. This is useful if you have mapped Control in place of Caps Lock and you need the Caps Lock LED to be part of the backlight instead of being activated when Caps Lock is on, as it is usually wired to a separate pin from the backlight.</p><p>To configure multiple backlight pins, add something like this to your <code>config.h</code>, instead of <code>BACKLIGHT_PIN</code>:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BACKLIGHT_PINS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { F5, B2 }</span></span></code></pre></div><h2 id="driver-configuration" tabindex="-1">Driver Configuration <a class="header-anchor" href="#driver-configuration" aria-label="Permalink to &quot;Driver Configuration {#driver-configuration}&quot;">​</a></h2><p>Backlight driver selection is configured in <code>rules.mk</code>. Valid drivers are <code>pwm</code> (default), <code>timer</code>, <code>software</code>, or <code>custom</code>. See below for information on individual drivers.</p><h3 id="pwm-driver" tabindex="-1">PWM Driver <a class="header-anchor" href="#pwm-driver" aria-label="Permalink to &quot;PWM Driver {#pwm-driver}&quot;">​</a></h3><p>This is the default backlight driver, which leverages the hardware PWM output capability of the microcontroller.</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BACKLIGHT_DRIVER = pwm</span></span></code></pre></div><h3 id="timer-driver" tabindex="-1">Timer Driver <a class="header-anchor" href="#timer-driver" aria-label="Permalink to &quot;Timer Driver {#timer-driver}&quot;">​</a></h3><p>This driver is similar to the PWM driver, but instead of directly configuring the pin to output a PWM signal, an interrupt handler is attached to the timer to turn the pin on and off as appropriate.</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BACKLIGHT_DRIVER = timer</span></span></code></pre></div><h3 id="software-driver" tabindex="-1">Software Driver <a class="header-anchor" href="#software-driver" aria-label="Permalink to &quot;Software Driver {#software-driver}&quot;">​</a></h3><p>In this mode, PWM is &quot;emulated&quot; while running other keyboard tasks. It offers maximum hardware compatibility without extra platform configuration. However, breathing is not supported, and the backlight can flicker when the keyboard is busy.</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BACKLIGHT_DRIVER = software</span></span></code></pre></div><h3 id="custom-driver" tabindex="-1">Custom Driver <a class="header-anchor" href="#custom-driver" aria-label="Permalink to &quot;Custom Driver {#custom-driver}&quot;">​</a></h3><p>If none of the above drivers apply to your board (for example, you are using a separate IC to control the backlight), you can implement a custom backlight driver using a simple API.</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BACKLIGHT_DRIVER = custom</span></span></code></pre></div><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> backlight_init_ports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Optional - runs on startup</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //   Usually you want to configure pins here</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> backlight_set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint8_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> level</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Optional - runs on level change</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //   Usually you want to respond to the new value</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> backlight_task</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Optional - runs periodically</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //   Note that this is called in the main keyboard loop,</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //   so long running actions here can cause performance issues</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="avr-configuration" tabindex="-1">AVR Configuration <a class="header-anchor" href="#avr-configuration" aria-label="Permalink to &quot;AVR Configuration {#avr-configuration}&quot;">​</a></h2><h3 id="avr-pwm-driver" tabindex="-1">PWM Driver <a class="header-anchor" href="#avr-pwm-driver" aria-label="Permalink to &quot;PWM Driver {#avr-pwm-driver}&quot;">​</a></h3><p>The following table describes the supported pins for the PWM driver. Only cells marked with a timer number are capable of hardware PWM output; any others must use the <code>timer</code> driver.</p><table><thead><tr><th>Backlight Pin</th><th>AT90USB64/128</th><th>AT90USB162</th><th>ATmega16/32U4</th><th>ATmega16/32U2</th><th>ATmega32A</th><th>ATmega328/P</th></tr></thead><tbody><tr><td><code>B1</code></td><td></td><td></td><td></td><td></td><td></td><td>Timer 1</td></tr><tr><td><code>B2</code></td><td></td><td></td><td></td><td></td><td></td><td>Timer 1</td></tr><tr><td><code>B5</code></td><td>Timer 1</td><td></td><td>Timer 1</td><td></td><td></td><td></td></tr><tr><td><code>B6</code></td><td>Timer 1</td><td></td><td>Timer 1</td><td></td><td></td><td></td></tr><tr><td><code>B7</code></td><td>Timer 1</td><td>Timer 1</td><td>Timer 1</td><td>Timer 1</td><td></td><td></td></tr><tr><td><code>C4</code></td><td>Timer 3</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>C5</code></td><td>Timer 3</td><td>Timer 1</td><td></td><td>Timer 1</td><td></td><td></td></tr><tr><td><code>C6</code></td><td>Timer 3</td><td>Timer 1</td><td>Timer 3</td><td>Timer 1</td><td></td><td></td></tr><tr><td><code>D4</code></td><td></td><td></td><td></td><td></td><td>Timer 1</td><td></td></tr><tr><td><code>D5</code></td><td></td><td></td><td></td><td></td><td>Timer 1</td><td></td></tr></tbody></table><h3 id="avr-timer-driver" tabindex="-1">Timer Driver <a class="header-anchor" href="#avr-timer-driver" aria-label="Permalink to &quot;Timer Driver {#avr-timer-driver}&quot;">​</a></h3><p>Any GPIO pin can be used with this driver. The following table describes the supported timers:</p><table><thead><tr><th>AT90USB64/128</th><th>AT90USB162</th><th>ATmega16/32U4</th><th>ATmega16/32U2</th><th>ATmega32A</th><th>ATmega328/P</th></tr></thead><tbody><tr><td>Timers 1 &amp; 3</td><td>Timer 1</td><td>Timers 1 &amp; 3</td><td>Timer 1</td><td>Timer 1</td><td>Timer 1</td></tr></tbody></table><p>The following <code>#define</code>s apply only to the <code>timer</code> driver:</p><table><thead><tr><th>Define</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>BACKLIGHT_PWM_TIMER</code></td><td><code>1</code></td><td>The timer to use</td></tr></tbody></table><p>Note that the choice of timer may conflict with the <a href="./audio">Audio</a> feature.</p><h2 id="arm-configuration" tabindex="-1">ChibiOS/ARM Configuration <a class="header-anchor" href="#arm-configuration" aria-label="Permalink to &quot;ChibiOS/ARM Configuration {#arm-configuration}&quot;">​</a></h2><h3 id="arm-pwm-driver" tabindex="-1">PWM Driver <a class="header-anchor" href="#arm-pwm-driver" aria-label="Permalink to &quot;PWM Driver {#arm-pwm-driver}&quot;">​</a></h3><p>Depending on the ChibiOS board configuration, you may need to enable PWM at the keyboard level. For STM32, this would look like:</p><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-3RkGq" id="tab-gvqRAyT" checked="checked"><label for="tab-gvqRAyT">halconf.h</label><input type="radio" name="group-3RkGq" id="tab-DTMBHaI"><label for="tab-DTMBHaI">mcuconf.h</label></div><div class="blocks"><div class="language-c vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark has-focused-lines vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> once</span></span>\n<span class="line"></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HAL_USE_PWM</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include_next</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;halconf.h&gt;</span></span></code></pre></div><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark has-focused-lines vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> once</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include_next</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;mcuconf.h&gt;</span></span>\n<span class="line"></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#undef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> STM32_PWM_USE_TIM4</span></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> STM32_PWM_USE_TIM4</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span></span></code></pre></div></div></div><p>The following <code>#define</code>s apply only to the <code>pwm</code> driver:</p><table><thead><tr><th>Define</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>BACKLIGHT_PWM_DRIVER</code></td><td><code>PWMD4</code></td><td>The PWM driver to use</td></tr><tr><td><code>BACKLIGHT_PWM_CHANNEL</code></td><td><code>3</code></td><td>The PWM channel to use</td></tr><tr><td><code>BACKLIGHT_PAL_MODE</code></td><td><code>2</code></td><td>The pin alternative function to use</td></tr><tr><td><code>BACKLIGHT_PWM_PERIOD</code></td><td><em>Not defined</em></td><td>The PWM period in counter ticks - Default is platform dependent</td></tr></tbody></table><p>Refer to the ST datasheet for your particular MCU to determine these values. For example, these defaults are set up for pin <code>B8</code> on a Proton-C (STM32F303) using <code>TIM4_CH3</code> on AF2. Unless you are designing your own keyboard, you generally should not need to change them.</p><h3 id="arm-timer-driver" tabindex="-1">Timer Driver <a class="header-anchor" href="#arm-timer-driver" aria-label="Permalink to &quot;Timer Driver {#arm-timer-driver}&quot;">​</a></h3><p>Depending on the ChibiOS board configuration, you may need to enable general-purpose timers at the keyboard level. For STM32, this would look like:</p><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-7s1ni" id="tab-PIxXftf" checked="checked"><label for="tab-PIxXftf">halconf.h</label><input type="radio" name="group-7s1ni" id="tab-Db-9lHi"><label for="tab-Db-9lHi">mcuconf.h</label></div><div class="blocks"><div class="language-c vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark has-focused-lines vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> once</span></span>\n<span class="line"></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HAL_USE_GPT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include_next</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;halconf.h&gt;</span></span></code></pre></div><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark has-focused-lines vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> once</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include_next</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;mcuconf.h&gt;</span></span>\n<span class="line"></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#undef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> STM32_GPT_USE_TIM15</span></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> STM32_GPT_USE_TIM15</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span></span></code></pre></div></div></div><p>The following <code>#define</code>s apply only to the <code>timer</code> driver:</p><table><thead><tr><th>Define</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>BACKLIGHT_GPT_DRIVER</code></td><td><code>GPTD15</code></td><td>The timer to use</td></tr></tbody></table><h2 id="example-schematic" tabindex="-1">Example Schematic <a class="header-anchor" href="#example-schematic" aria-label="Permalink to &quot;Example Schematic&quot;">​</a></h2><p>Since the MCU can only supply so much current to its GPIO pins, instead of powering the backlight directly from the MCU, the backlight pin is connected to a transistor or MOSFET that switches the power to the LEDs.</p><p>In this typical example, the backlight LEDs are all connected in parallel towards an N-channel MOSFET. Its gate pin is wired to one of the microcontroller&#39;s GPIO pins through a 470Ω resistor to avoid ringing. A pulldown resistor is also placed between the gate pin and ground to keep it at a defined state when it is not otherwise being driven by the MCU. The values of these resistors are not critical - see <a href="https://electronics.stackexchange.com/q/68748" target="_blank" rel="noreferrer">this Electronics StackExchange question</a> for more information.</p><p><img src="https://i.imgur.com/BmAvoUC.png" alt="Backlight example circuit"></p><h2 id="api" tabindex="-1">API <a class="header-anchor" href="#api" aria-label="Permalink to &quot;API {#api}&quot;">​</a></h2><h3 id="api-backlight-toggle" tabindex="-1"><code>void backlight_toggle(void)</code> <a class="header-anchor" href="#api-backlight-toggle" aria-label="Permalink to &quot;`void backlight_toggle(void)` {#api-backlight-toggle}&quot;">​</a></h3><p>Toggle the backlight on or off.</p><hr><h3 id="api-backlight-enable" tabindex="-1"><code>void backlight_enable(void)</code> <a class="header-anchor" href="#api-backlight-enable" aria-label="Permalink to &quot;`void backlight_enable(void)` {#api-backlight-enable}&quot;">​</a></h3><p>Turn the backlight on.</p><hr><h3 id="api-backlight-disable" tabindex="-1"><code>void backlight_disable(void)</code> <a class="header-anchor" href="#api-backlight-disable" aria-label="Permalink to &quot;`void backlight_disable(void)` {#api-backlight-disable}&quot;">​</a></h3><p>Turn the backlight off.</p><hr><h3 id="api-backlight-step" tabindex="-1"><code>void backlight_step(void)</code> <a class="header-anchor" href="#api-backlight-step" aria-label="Permalink to &quot;`void backlight_step(void)` {#api-backlight-step}&quot;">​</a></h3><p>Cycle through backlight levels.</p><hr><h3 id="api-backlight-increase" tabindex="-1"><code>void backlight_increase(void)</code> <a class="header-anchor" href="#api-backlight-increase" aria-label="Permalink to &quot;`void backlight_increase(void)` {#api-backlight-increase}&quot;">​</a></h3><p>Increase the backlight level.</p><hr><h3 id="api-backlight-decrease" tabindex="-1"><code>void backlight_decrease(void)</code> <a class="header-anchor" href="#api-backlight-decrease" aria-label="Permalink to &quot;`void backlight_decrease(void)` {#api-backlight-decrease}&quot;">​</a></h3><p>Decrease the backlight level.</p><hr><h3 id="api-backlight-level" tabindex="-1"><code>void backlight_level(uint8_t level)</code> <a class="header-anchor" href="#api-backlight-level" aria-label="Permalink to &quot;`void backlight_level(uint8_t level)` {#api-backlight-level}&quot;">​</a></h3><p>Set the backlight level.</p><h4 id="api-backlight-level-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-backlight-level-arguments" aria-label="Permalink to &quot;Arguments {#api-backlight-level-arguments}&quot;">​</a></h4><ul><li><code>uint8_t level</code><br> The level to set, from 0 to <code>BACKLIGHT_LEVELS</code>.</li></ul><hr><h3 id="api-get-backlight-level" tabindex="-1"><code>uint8_t get_backlight_level(void)</code> <a class="header-anchor" href="#api-get-backlight-level" aria-label="Permalink to &quot;`uint8_t get_backlight_level(void)` {#api-get-backlight-level}&quot;">​</a></h3><p>Get the current backlight level.</p><h4 id="api-get-backlight-level-return" tabindex="-1">Return Value <a class="header-anchor" href="#api-get-backlight-level-return" aria-label="Permalink to &quot;Return Value {#api-get-backlight-level-return}&quot;">​</a></h4><p>The current backlight level, from 0 to <code>BACKLIGHT_LEVELS</code>.</p><hr><h3 id="api-is-backlight-enabled" tabindex="-1"><code>bool is_backlight_enabled(void)</code> <a class="header-anchor" href="#api-is-backlight-enabled" aria-label="Permalink to &quot;`bool is_backlight_enabled(void)` {#api-is-backlight-enabled}&quot;">​</a></h3><p>Get the current backlight state.</p><h4 id="api-is-backlight-enabled-return" tabindex="-1">Return Value <a class="header-anchor" href="#api-is-backlight-enabled-return" aria-label="Permalink to &quot;Return Value {#api-is-backlight-enabled-return}&quot;">​</a></h4><p><code>true</code> if the backlight is enabled.</p><hr><h3 id="api-backlight-toggle-breathing" tabindex="-1"><code>void backlight_toggle_breathing(void)</code> <a class="header-anchor" href="#api-backlight-toggle-breathing" aria-label="Permalink to &quot;`void backlight_toggle_breathing(void)` {#api-backlight-toggle-breathing}&quot;">​</a></h3><p>Toggle backlight breathing on or off.</p><hr><h3 id="api-backlight-enable-breathing" tabindex="-1"><code>void backlight_enable_breathing(void)</code> <a class="header-anchor" href="#api-backlight-enable-breathing" aria-label="Permalink to &quot;`void backlight_enable_breathing(void)` {#api-backlight-enable-breathing}&quot;">​</a></h3><p>Turn backlight breathing on.</p><hr><h3 id="api-backlight-disable-breathing" tabindex="-1"><code>void backlight_disable_breathing(void)</code> <a class="header-anchor" href="#api-backlight-disable-breathing" aria-label="Permalink to &quot;`void backlight_disable_breathing(void)` {#api-backlight-disable-breathing}&quot;">​</a></h3><p>Turn backlight breathing off.</p><hr><h3 id="api-is-backlight-breathing" tabindex="-1"><code>bool is_backlight_breathing(void)</code> <a class="header-anchor" href="#api-is-backlight-breathing" aria-label="Permalink to &quot;`bool is_backlight_breathing(void)` {#api-is-backlight-breathing}&quot;">​</a></h3><p>Get the current backlight breathing state.</p><h4 id="api-is-backlight-breathing-return" tabindex="-1">Return Value <a class="header-anchor" href="#api-is-backlight-breathing-return" aria-label="Permalink to &quot;Return Value {#api-is-backlight-breathing-return}&quot;">​</a></h4><p><code>true</code> if backlight breathing is enabled.</p>', 109);
const _hoisted_110 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_110);
}
const backlight = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  backlight as default
};
