import { _ as _export_sfc, c as createElementBlock, o as openBlock, a8 as createStaticVNode } from "./chunks/framework.Cauyuiy8.js";
const __pageData = JSON.parse('{"title":"I2C Master Driver","description":"","frontmatter":{},"headers":[],"relativePath":"drivers/i2c.md","filePath":"drivers/i2c.md","lastUpdated":null}');
const _sfc_main = { name: "drivers/i2c.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="i2c-master-driver" tabindex="-1">I2C Master Driver <a class="header-anchor" href="#i2c-master-driver" aria-label="Permalink to &quot;I2C Master Driver {#i2c-master-driver}&quot;">​</a></h1><p>The I2C Master drivers used in QMK have a set of common functions to allow portability between MCUs.</p><h2 id="usage" tabindex="-1">Usage <a class="header-anchor" href="#usage" aria-label="Permalink to &quot;Usage {#usage}&quot;">​</a></h2><p>In most cases, the I2C Master driver code is automatically included if you are using a feature or driver which requires it, such as <a href="./../features/oled_driver">OLED</a>.</p><p>However, if you need to use the driver standalone, add the following to your <code>rules.mk</code>:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">I2C_DRIVER_REQUIRED = yes</span></span></code></pre></div><p>You can then call the I2C API by including <code>i2c_master.h</code> in your code.</p><h2 id="note-on-i2c-addresses" tabindex="-1">I2C Addressing <a class="header-anchor" href="#note-on-i2c-addresses" aria-label="Permalink to &quot;I2C Addressing {#note-on-i2c-addresses}&quot;">​</a></h2><p>I2C addresses listed on datasheets and the internet are usually represented as a 7-bit value. The eighth bit (the least significant bit) controls whether the operation is a read or a write.</p><p>All of the address parameters expected by the driver API should therefore be pushed to the upper 7 bits of the address byte; the driver will take care of setting the read/write bit as appropriate.</p><p>This is easy to do via the bitwise left shift operator. For example, if your device has an address of <code>0x18</code> you might create a define for convenience:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MY_I2C_ADDRESS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">18</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Or, you can shift the address ahead of time:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MY_I2C_ADDRESS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span></span></code></pre></div><p>See <a href="https://www.robot-electronics.co.uk/i2c-tutorial" target="_blank" rel="noreferrer">https://www.robot-electronics.co.uk/i2c-tutorial</a> for more information about I2C addressing and other technical details.</p><h2 id="avr-configuration" tabindex="-1">AVR Configuration <a class="header-anchor" href="#avr-configuration" aria-label="Permalink to &quot;AVR Configuration {#avr-configuration}&quot;">​</a></h2><p>The following defines can be used to configure the I2C master driver:</p><table><thead><tr><th><code>config.h</code> Override</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>F_SCL</code></td><td>Clock frequency in Hz</td><td><code>400000</code></td></tr></tbody></table><p>No further setup is required - just connect the <code>SDA</code> and <code>SCL</code> pins of your I2C devices to the matching pins on the MCU:</p><table><thead><tr><th>MCU</th><th><code>SCL</code></th><th><code>SDA</code></th></tr></thead><tbody><tr><td>ATmega16/32U4</td><td><code>D0</code></td><td><code>D1</code></td></tr><tr><td>AT90USB64/128</td><td><code>D0</code></td><td><code>D1</code></td></tr><tr><td>ATmega32A</td><td><code>C0</code></td><td><code>C1</code></td></tr><tr><td>ATmega328/P</td><td><code>C5</code></td><td><code>C4</code></td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>The ATmega16/32U2 does not possess I2C functionality, and so cannot use this driver.</p></div><h2 id="arm-configuration" tabindex="-1">ChibiOS/ARM Configuration <a class="header-anchor" href="#arm-configuration" aria-label="Permalink to &quot;ChibiOS/ARM Configuration {#arm-configuration}&quot;">​</a></h2><p>You&#39;ll need to determine which pins can be used for I2C -- as an example, STM32 parts generally have multiple I2C peripherals, labeled I2C1, I2C2, I2C3 etc.</p><p>To enable I2C, modify your board&#39;s <code>halconf.h</code> to enable I2C, then modify your board&#39;s <code>mcuconf.h</code> to enable the peripheral you&#39;ve chosen:</p><div class="vp-code-group vp-adaptive-theme"><div class="tabs"><input type="radio" name="group-Ckz0d" id="tab-hJ0AYme" checked="checked"><label for="tab-hJ0AYme">halconf.h</label><input type="radio" name="group-Ckz0d" id="tab-GJMuqHO"><label for="tab-GJMuqHO">mcuconf.h</label></div><div class="blocks"><div class="language-c vp-adaptive-theme active"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark has-focused-lines vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> once</span></span>\n<span class="line"></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HAL_USE_I2C</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include_next</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;halconf.h&gt;</span></span></code></pre></div><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark has-focused-lines vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#pragma</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> once</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include_next</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;mcuconf.h&gt;</span></span>\n<span class="line"></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#undef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> STM32_I2C_USE_I2C2</span></span>\n<span class="line has-focus"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> STM32_I2C_USE_I2C2</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span></span></code></pre></div></div></div><table><thead><tr><th><code>mcuconf.h</code> Setting</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>STM32_I2C_BUSY_TIMEOUT</code></td><td>Time in milliseconds until the I2C command is aborted if no response is received</td><td><code>50</code></td></tr><tr><td><code>STM32_I2C_XXX_IRQ_PRIORITY</code></td><td>Interrupt priority for hardware driver XXX (THIS IS AN EXPERT SETTING)</td><td><code>10</code></td></tr><tr><td><code>STM32_I2C_USE_DMA</code></td><td>Enable/Disable the ability of the MCU to offload the data transfer to the DMA unit</td><td><code>TRUE</code></td></tr><tr><td><code>STM32_I2C_XXX_DMA_PRIORITY</code></td><td>Priority of DMA unit for hardware driver XXX (THIS IS AN EXPERT SETTING)</td><td><code>1</code></td></tr></tbody></table><p>Configuration-wise, you&#39;ll need to set up the peripheral as per your MCU&#39;s datasheet -- the defaults match the pins for a Proton-C, i.e. STM32F303.</p><table><thead><tr><th><code>config.h</code> Override</th><th>Description</th><th>Default</th></tr></thead><tbody><tr><td><code>I2C_DRIVER</code></td><td>I2C peripheral to use - I2C1 -&gt; <code>I2CD1</code>, I2C2 -&gt; <code>I2CD2</code> etc.</td><td><code>I2CD1</code></td></tr><tr><td><code>I2C1_SCL_PIN</code></td><td>The pin to use for SCL</td><td><code>B6</code></td></tr><tr><td><code>I2C1_SCL_PAL_MODE</code></td><td>The alternate function mode for SCL</td><td><code>4</code></td></tr><tr><td><code>I2C1_SDA_PIN</code></td><td>The pin to use for SDA</td><td><code>B7</code></td></tr><tr><td><code>I2C1_SDA_PAL_MODE</code></td><td>The alternate function mode for SDA</td><td><code>4</code></td></tr></tbody></table><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Currently only a single I2C peripheral is supported, therefore the <code>I2C1_*</code> defines are used for configuration regardless of the selected peripheral.</p></div><p>The following configuration values are dependent on the ChibiOS I2C LLD, which is dictated by the microcontroller.</p><h3 id="arm-configuration-i2cv1" tabindex="-1">I2Cv1 <a class="header-anchor" href="#arm-configuration-i2cv1" aria-label="Permalink to &quot;I2Cv1 {#arm-configuration-i2cv1}&quot;">​</a></h3><ul><li>STM32F1xx</li><li>STM32F2xx</li><li>STM32F4xx</li><li>STM32L0xx</li><li>STM32L1xx</li></ul><p>See <a href="https://www.playembedded.org/blog/stm32-i2c-chibios/#7_I2Cv1_configuration_structure" target="_blank" rel="noreferrer">this page</a> for the I2Cv1 configuration structure.</p><table><thead><tr><th><code>config.h</code> Override</th><th>Default</th></tr></thead><tbody><tr><td><code>I2C1_OPMODE</code></td><td><code>OPMODE_I2C</code></td></tr><tr><td><code>I2C1_CLOCK_SPEED</code></td><td><code>100000</code></td></tr><tr><td><code>I2C1_DUTY_CYCLE</code></td><td><code>STD_DUTY_CYCLE</code></td></tr></tbody></table><h3 id="arm-configuration-i2cv2" tabindex="-1">I2Cv2 <a class="header-anchor" href="#arm-configuration-i2cv2" aria-label="Permalink to &quot;I2Cv2 {#arm-configuration-i2cv2}&quot;">​</a></h3><ul><li>STM32F0xx</li><li>STM32F3xx</li><li>STM32F7xx</li><li>STM32L4xx</li></ul><p>See <a href="https://www.playembedded.org/blog/stm32-i2c-chibios/#8_I2Cv2_I2Cv3_configuration_structure" target="_blank" rel="noreferrer">this page</a> for the I2Cv2 configuration structure.</p><table><thead><tr><th><code>config.h</code> Override</th><th>Default</th></tr></thead><tbody><tr><td><code>I2C1_TIMINGR_PRESC</code></td><td><code>0U</code></td></tr><tr><td><code>I2C1_TIMINGR_SCLDEL</code></td><td><code>7U</code></td></tr><tr><td><code>I2C1_TIMINGR_SDADEL</code></td><td><code>0U</code></td></tr><tr><td><code>I2C1_TIMINGR_SCLH</code></td><td><code>38U</code></td></tr><tr><td><code>I2C1_TIMINGR_SCLL</code></td><td><code>129U</code></td></tr></tbody></table><h2 id="api" tabindex="-1">API <a class="header-anchor" href="#api" aria-label="Permalink to &quot;API {#api}&quot;">​</a></h2><h3 id="api-i2c-init" tabindex="-1"><code>void i2c_init(void)</code> <a class="header-anchor" href="#api-i2c-init" aria-label="Permalink to &quot;`void i2c_init(void)` {#api-i2c-init}&quot;">​</a></h3><p>Initialize the I2C driver. This function must be called only once, before any of the below functions can be called.</p><p>This function is weakly defined, meaning it can be overridden if necessary for your particular use case:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> i2c_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    gpio_set_pin_input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(B6);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Try releasing special pins for a short time</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    gpio_set_pin_input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(B7);</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    wait_ms</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Wait for the release to happen</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    palSetPadMode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GPIOB, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PAL_MODE_ALTERNATE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PAL_STM32_OTYPE_OPENDRAIN </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PAL_STM32_PUPDR_PULLUP);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Set B6 to I2C function</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    palSetPadMode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(GPIOB, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">PAL_MODE_ALTERNATE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PAL_STM32_OTYPE_OPENDRAIN </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PAL_STM32_PUPDR_PULLUP);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // Set B7 to I2C function</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h3 id="api-i2c-transmit" tabindex="-1"><code>i2c_status_t i2c_transmit(uint8_t address, const uint8_t* data, uint16_t length, uint16_t timeout)</code> <a class="header-anchor" href="#api-i2c-transmit" aria-label="Permalink to &quot;`i2c_status_t i2c_transmit(uint8_t address, const uint8_t* data, uint16_t length, uint16_t timeout)` {#api-i2c-transmit}&quot;">​</a></h3><p>Send multiple bytes to the selected I2C device.</p><h4 id="api-i2c-transmit-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-i2c-transmit-arguments" aria-label="Permalink to &quot;Arguments {#api-i2c-transmit-arguments}&quot;">​</a></h4><ul><li><code>uint8_t address</code><br> The 7-bit I2C address of the device.</li><li><code>const uint8_t* data</code><br> A pointer to the data to transmit.</li><li><code>uint16_t length</code><br> The number of bytes to write. Take care not to overrun the length of <code>data</code>.</li><li><code>uint16_t timeout</code><br> The time in milliseconds to wait for a response from the target device.</li></ul><h4 id="api-i2c-transmit-return" tabindex="-1">Return Value <a class="header-anchor" href="#api-i2c-transmit-return" aria-label="Permalink to &quot;Return Value {#api-i2c-transmit-return}&quot;">​</a></h4><p><code>I2C_STATUS_TIMEOUT</code> if the timeout period elapses, <code>I2C_STATUS_ERROR</code> if some other error occurs, otherwise <code>I2C_STATUS_SUCCESS</code>.</p><hr><h3 id="api-i2c-transmit-p" tabindex="-1"><code>i2c_status_t i2c_transmit_P(uint8_t address, const uint8_t* data, uint16_t length, uint16_t timeout)</code> <a class="header-anchor" href="#api-i2c-transmit-p" aria-label="Permalink to &quot;`i2c_status_t i2c_transmit_P(uint8_t address, const uint8_t* data, uint16_t length, uint16_t timeout)` {#api-i2c-transmit-p}&quot;">​</a></h3><p>Send multiple bytes from PROGMEM to the selected I2C device.</p><p>On ARM devices, this function is simply an alias for <code>i2c_transmit(address, data, length, timeout)</code>.</p><h4 id="api-i2c-transmit-p-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-i2c-transmit-p-arguments" aria-label="Permalink to &quot;Arguments {#api-i2c-transmit-p-arguments}&quot;">​</a></h4><ul><li><code>uint8_t address</code><br> The 7-bit I2C address of the device.</li><li><code>const uint8_t* data</code><br> A pointer to the data to transmit.</li><li><code>uint16_t length</code><br> The number of bytes to write. Take care not to overrun the length of <code>data</code>.</li><li><code>uint16_t timeout</code><br> The time in milliseconds to wait for a response from the target device.</li></ul><h4 id="api-i2c-transmit-p-return" tabindex="-1">Return Value <a class="header-anchor" href="#api-i2c-transmit-p-return" aria-label="Permalink to &quot;Return Value {#api-i2c-transmit-p-return}&quot;">​</a></h4><p><code>I2C_STATUS_TIMEOUT</code> if the timeout period elapses, <code>I2C_STATUS_ERROR</code> if some other error occurs, otherwise <code>I2C_STATUS_SUCCESS</code>.</p><hr><h3 id="api-i2c-receive" tabindex="-1"><code>i2c_status_t i2c_receive(uint8_t address, uint8_t* data, uint16_t length, uint16_t timeout)</code> <a class="header-anchor" href="#api-i2c-receive" aria-label="Permalink to &quot;`i2c_status_t i2c_receive(uint8_t address, uint8_t* data, uint16_t length, uint16_t timeout)` {#api-i2c-receive}&quot;">​</a></h3><p>Receive multiple bytes from the selected I2C device.</p><h4 id="api-i2c-receive-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-i2c-receive-arguments" aria-label="Permalink to &quot;Arguments {#api-i2c-receive-arguments}&quot;">​</a></h4><ul><li><code>uint8_t address</code><br> The 7-bit I2C address of the device.</li><li><code>uint8_t* data</code><br> A pointer to a buffer to read into.</li><li><code>uint16_t length</code><br> The number of bytes to read. Take care not to overrun the length of <code>data</code>.</li><li><code>uint16_t timeout</code><br> The time in milliseconds to wait for a response from the target device.</li></ul><h4 id="api-i2c-receive-return" tabindex="-1">Return Value <a class="header-anchor" href="#api-i2c-receive-return" aria-label="Permalink to &quot;Return Value {#api-i2c-receive-return}&quot;">​</a></h4><p><code>I2C_STATUS_TIMEOUT</code> if the timeout period elapses, <code>I2C_STATUS_ERROR</code> if some other error occurs, otherwise <code>I2C_STATUS_SUCCESS</code>.</p><hr><h3 id="api-i2c-write-register" tabindex="-1"><code>i2c_status_t i2c_write_register(uint8_t devaddr, uint8_t regaddr, const uint8_t* data, uint16_t length, uint16_t timeout)</code> <a class="header-anchor" href="#api-i2c-write-register" aria-label="Permalink to &quot;`i2c_status_t i2c_write_register(uint8_t devaddr, uint8_t regaddr, const uint8_t* data, uint16_t length, uint16_t timeout)` {#api-i2c-write-register}&quot;">​</a></h3><p>Write to a register with an 8-bit address on the I2C device.</p><h4 id="api-i2c-write-register-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-i2c-write-register-arguments" aria-label="Permalink to &quot;Arguments {#api-i2c-write-register-arguments}&quot;">​</a></h4><ul><li><code>uint8_t devaddr</code><br> The 7-bit I2C address of the device.</li><li><code>uint8_t regaddr</code><br> The register address to write to.</li><li><code>const uint8_t* data</code><br> A pointer to the data to transmit.</li><li><code>uint16_t length</code><br> The number of bytes to write. Take care not to overrun the length of <code>data</code>.</li><li><code>uint16_t timeout</code><br> The time in milliseconds to wait for a response from the target device.</li></ul><h4 id="api-i2c-write-register-return" tabindex="-1">Return Value <a class="header-anchor" href="#api-i2c-write-register-return" aria-label="Permalink to &quot;Return Value {#api-i2c-write-register-return}&quot;">​</a></h4><p><code>I2C_STATUS_TIMEOUT</code> if the timeout period elapses, <code>I2C_STATUS_ERROR</code> if some other error occurs, otherwise <code>I2C_STATUS_SUCCESS</code>.</p><hr><h3 id="api-i2c-write-register16" tabindex="-1"><code>i2c_status_t i2c_write_register16(uint8_t devaddr, uint16_t regaddr, const uint8_t* data, uint16_t length, uint16_t timeout)</code> <a class="header-anchor" href="#api-i2c-write-register16" aria-label="Permalink to &quot;`i2c_status_t i2c_write_register16(uint8_t devaddr, uint16_t regaddr, const uint8_t* data, uint16_t length, uint16_t timeout)` {#api-i2c-write-register16}&quot;">​</a></h3><p>Write to a register with a 16-bit address (big endian) on the I2C device.</p><h4 id="api-i2c-write-register16-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-i2c-write-register16-arguments" aria-label="Permalink to &quot;Arguments {#api-i2c-write-register16-arguments}&quot;">​</a></h4><ul><li><code>uint8_t devaddr</code><br> The 7-bit I2C address of the device.</li><li><code>uint16_t regaddr</code><br> The register address to write to.</li><li><code>const uint8_t* data</code><br> A pointer to the data to transmit.</li><li><code>uint16_t length</code><br> The number of bytes to write. Take care not to overrun the length of <code>data</code>.</li><li><code>uint16_t timeout</code><br> The time in milliseconds to wait for a response from the target device.</li></ul><h4 id="api-i2c-write-register16-return" tabindex="-1">Return Value <a class="header-anchor" href="#api-i2c-write-register16-return" aria-label="Permalink to &quot;Return Value {#api-i2c-write-register16-return}&quot;">​</a></h4><p><code>I2C_STATUS_TIMEOUT</code> if the timeout period elapses, <code>I2C_STATUS_ERROR</code> if some other error occurs, otherwise <code>I2C_STATUS_SUCCESS</code>.</p><hr><h3 id="api-i2c-read-register" tabindex="-1"><code>i2c_status_t i2c_read_register(uint8_t devaddr, uint8_t regaddr, uint8_t* data, uint16_t length, uint16_t timeout)</code> <a class="header-anchor" href="#api-i2c-read-register" aria-label="Permalink to &quot;`i2c_status_t i2c_read_register(uint8_t devaddr, uint8_t regaddr, uint8_t* data, uint16_t length, uint16_t timeout)` {#api-i2c-read-register}&quot;">​</a></h3><p>Read from a register with an 8-bit address on the I2C device.</p><h4 id="api-i2c-read-register-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-i2c-read-register-arguments" aria-label="Permalink to &quot;Arguments {#api-i2c-read-register-arguments}&quot;">​</a></h4><ul><li><code>uint8_t devaddr</code><br> The 7-bit I2C address of the device.</li><li><code>uint8_t regaddr</code><br> The register address to read from.</li><li><code>uint8_t data</code><br> A pointer to a buffer to read into.</li><li><code>uint16_t length</code><br> The number of bytes to read. Take care not to overrun the length of <code>data</code>.</li><li><code>uint16_t timeout</code><br> The time in milliseconds to wait for a response from the target device.</li></ul><h4 id="api-i2c-read-register-return" tabindex="-1">Return Value <a class="header-anchor" href="#api-i2c-read-register-return" aria-label="Permalink to &quot;Return Value {#api-i2c-read-register-return}&quot;">​</a></h4><p><code>I2C_STATUS_TIMEOUT</code> if the timeout period elapses, <code>I2C_STATUS_ERROR</code> if some other error occurs, otherwise <code>I2C_STATUS_SUCCESS</code>.</p><hr><h3 id="api-i2c-read-register16" tabindex="-1"><code>i2c_status_t i2c_read_register16(uint8_t devaddr, uint16_t regaddr, uint8_t* data, uint16_t length, uint16_t timeout)</code> <a class="header-anchor" href="#api-i2c-read-register16" aria-label="Permalink to &quot;`i2c_status_t i2c_read_register16(uint8_t devaddr, uint16_t regaddr, uint8_t* data, uint16_t length, uint16_t timeout)` {#api-i2c-read-register16}&quot;">​</a></h3><p>Read from a register with a 16-bit address (big endian) on the I2C device.</p><h4 id="api-i2c-read-register16-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-i2c-read-register16-arguments" aria-label="Permalink to &quot;Arguments {#api-i2c-read-register16-arguments}&quot;">​</a></h4><ul><li><code>uint8_t devaddr</code><br> The 7-bit I2C address of the device.</li><li><code>uint16_t regaddr</code><br> The register address to read from.</li><li><code>uint8_t* data</code><br> A pointer to a buffer to read into.</li><li><code>uint16_t length</code><br> The number of bytes to read. Take care not to overrun the length of <code>data</code>.</li><li><code>uint16_t timeout</code><br> The time in milliseconds to wait for a response from the target device.</li></ul><h4 id="api-i2c-read-register16-return" tabindex="-1">Return Value <a class="header-anchor" href="#api-i2c-read-register16-return" aria-label="Permalink to &quot;Return Value {#api-i2c-read-register16-return}&quot;">​</a></h4><p><code>I2C_STATUS_TIMEOUT</code> if the timeout period elapses, <code>I2C_STATUS_ERROR</code> if some other error occurs, otherwise <code>I2C_STATUS_SUCCESS</code>.</p><hr><h3 id="api-i2c-ping-address" tabindex="-1"><code>i2c_status_t i2c_ping_address(uint8_t address, uint16_t timeout)</code> <a class="header-anchor" href="#api-i2c-ping-address" aria-label="Permalink to &quot;`i2c_status_t i2c_ping_address(uint8_t address, uint16_t timeout)` {#api-i2c-ping-address}&quot;">​</a></h3><p>Ping the I2C bus for a specific address.</p><p>On ChibiOS a &quot;best effort&quot; attempt is made by reading a single byte from register 0 at the given address. This should generally work except for I2C devices that do not not respond to a register 0 read request, which will result in a false negative result (unsuccessful response to ping attempt).</p><p>This function is weakly defined, meaning it can be overridden if necessary for your particular use case.</p><h4 id="api-i2c-ping-address-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-i2c-ping-address-arguments" aria-label="Permalink to &quot;Arguments {#api-i2c-ping-address-arguments}&quot;">​</a></h4><ul><li><code>uint8_t address</code><br> The 7-bit I2C address of the device.</li><li><code>uint16_t timeout</code><br> The time in milliseconds to wait for a response from the target device.</li></ul><h4 id="api-i2c-ping-address-return" tabindex="-1">Return Value <a class="header-anchor" href="#api-i2c-ping-address-return" aria-label="Permalink to &quot;Return Value {#api-i2c-ping-address-return}&quot;">​</a></h4><p><code>I2C_STATUS_TIMEOUT</code> if the timeout period elapses, <code>I2C_STATUS_ERROR</code> if some other error occurs, otherwise <code>I2C_STATUS_SUCCESS</code>.</p>', 102);
const _hoisted_103 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_103);
}
const i2c = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  i2c as default
};
