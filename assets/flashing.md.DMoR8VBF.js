import { _ as _export_sfc, c as createElementBlock, o as openBlock, a8 as createStaticVNode } from "./chunks/framework.Cauyuiy8.js";
const __pageData = JSON.parse('{"title":"Flashing Instructions and Bootloader Information","description":"","frontmatter":{},"headers":[],"relativePath":"flashing.md","filePath":"flashing.md","lastUpdated":null}');
const _sfc_main = { name: "flashing.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="flashing-instructions-and-bootloader-information" tabindex="-1">Flashing Instructions and Bootloader Information <a class="header-anchor" href="#flashing-instructions-and-bootloader-information" aria-label="Permalink to &quot;Flashing Instructions and Bootloader Information&quot;">​</a></h1><p>There are quite a few different types of bootloaders that keyboards use, and almost all of them use their own flashing method and tools. Luckily, projects like the <a href="https://github.com/qmk/qmk_toolbox/releases" target="_blank" rel="noreferrer">QMK Toolbox</a> aim to support as many of them as possible, but this article will describe the different types of bootloaders, and available methods for flashing them.</p><p>For AVR-based keyboards, QMK will automatically calculate if your <code>.hex</code> file is the right size to be flashed to the device based on the <code>BOOTLOADER</code> value set in <code>rules.mk</code>, and output the total size in bytes (along with the max).</p><p>You will also be able to use the CLI to flash your keyboard, by running:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ qmk flash -kb &lt;keyboard&gt; -km &lt;keymap&gt;</span></span></code></pre></div><p>See the <a href="./cli_commands#qmk-flash"><code>qmk flash</code></a> documentation for more information.</p><h2 id="atmel-dfu" tabindex="-1">Atmel DFU <a class="header-anchor" href="#atmel-dfu" aria-label="Permalink to &quot;Atmel DFU&quot;">​</a></h2><p>Atmel&#39;s DFU bootloader comes on all USB AVRs by default (except for 16/32U4RC), and is used by many keyboards that have their own ICs on their PCBs (older OLKB boards, Clueboards). Some keyboards may also use LUFA&#39;s DFU bootloader, or QMK&#39;s fork of it (newer OLKB boards), that adds in additional features specific to that hardware.</p><p>To ensure compatibility with the DFU bootloader, make sure this block is present in your <code>rules.mk</code> (optionally with <code>lufa-dfu</code> or <code>qmk-dfu</code> instead):</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Bootloader selection</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BOOTLOADER = atmel-dfu</span></span></code></pre></div><p>Compatible flashers:</p><ul><li><a href="https://github.com/qmk/qmk_toolbox/releases" target="_blank" rel="noreferrer">QMK Toolbox</a> (recommended GUI)</li><li><a href="https://github.com/dfu-programmer/dfu-programmer" target="_blank" rel="noreferrer">dfu-programmer</a> / <code>:dfu</code> target in QMK (recommended command line)<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>dfu-programmer &lt;mcu&gt; erase --force</span></span>\n<span class="line"><span>dfu-programmer &lt;mcu&gt; flash --force &lt;filename&gt;</span></span>\n<span class="line"><span>dfu-programmer &lt;mcu&gt; reset</span></span></code></pre></div></li></ul><p>Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods: <ul><li>Press the <code>QK_BOOT</code> keycode</li><li>Press the <code>RESET</code> button on the PCB if available</li><li>Short RST to GND quickly</li></ul></li><li>Wait for the OS to detect the device</li><li>Erase the flash memory (will be done automatically if using the Toolbox or CLI/<code>make</code> command)</li><li>Flash a .hex file</li><li>Reset the device into application mode (will be done automatically as above)</li></ol><h3 id="qmk-dfu" tabindex="-1">QMK DFU <a class="header-anchor" href="#qmk-dfu" aria-label="Permalink to &quot;QMK DFU&quot;">​</a></h3><p>QMK maintains <a href="https://github.com/qmk/lufa/tree/master/Bootloaders/DFU" target="_blank" rel="noreferrer">a fork of the LUFA DFU bootloader</a> that additionally performs a simple matrix scan for exiting the bootloader and returning to the application, as well as flashing an LED/making a ticking noise with a speaker when things are happening. To enable these features, add the following defines to your <code>config.h</code>:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QMK_ESC_OUTPUT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> F1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // COL pin if COL2ROW</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QMK_ESC_INPUT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  D5</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ROW pin if COL2ROW</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Optional:</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//#define QMK_LED E6</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//#define QMK_SPEAKER C6</span></span></code></pre></div><p>Currently we do not recommend making <code>QMK_ESC</code> the same key as the one designated for <a href="./features/bootmagic">Bootmagic</a>, as holding it down will cause the MCU to loop back and forth between entering and exiting the bootloader.</p><p>The manufacturer and product strings are automatically pulled from <code>config.h</code>, with &quot; Bootloader&quot; appended to the product string.</p><p>To generate this bootloader, use the <code>bootloader</code> target, eg. <code>make planck/rev4:default:bootloader</code>. To generate a production-ready .hex file (combining QMK and the bootloader), use the <code>production</code> target, eg. <code>make planck/rev4:default:production</code>.</p><h3 id="make-targets" tabindex="-1"><code>make</code> Targets <a class="header-anchor" href="#make-targets" aria-label="Permalink to &quot;`make` Targets&quot;">​</a></h3><ul><li><code>:dfu</code>: Checks every 5 seconds until a DFU device is available, and then flashes the firmware.</li><li><code>:dfu-split-left</code> and <code>:dfu-split-right</code>: Flashes the firmware as with <code>:dfu</code>, but also sets the handedness setting in EEPROM. This is ideal for Elite-C-based split keyboards.</li></ul><h2 id="caterina" tabindex="-1">Caterina <a class="header-anchor" href="#caterina" aria-label="Permalink to &quot;Caterina&quot;">​</a></h2><p>Arduino boards and their clones use the <a href="https://github.com/arduino/ArduinoCore-avr/tree/master/bootloaders/caterina" target="_blank" rel="noreferrer">Caterina bootloader</a> or a variant of it (any keyboard built with a Pro Micro or clone, and the Pololu A-Star), and uses the AVR109 protocol to communicate through virtual serial.</p><p>To ensure compatibility with the Caterina bootloader, make sure this block is present in your <code>rules.mk</code>:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Bootloader selection</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BOOTLOADER = caterina</span></span></code></pre></div><p>Compatible flashers:</p><ul><li><a href="https://github.com/qmk/qmk_toolbox/releases" target="_blank" rel="noreferrer">QMK Toolbox</a> (recommended GUI)</li><li><a href="https://github.com/zkemble/AVRDUDESS" target="_blank" rel="noreferrer">AVRDUDESS</a></li><li><a href="https://www.nongnu.org/avrdude/" target="_blank" rel="noreferrer">avrdude</a> with the <code>avr109</code> programmer / <code>:avrdude</code> target in QMK (recommended command line)<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>avrdude -p &lt;mcu&gt; -c avr109 -P &lt;serialport&gt; -U flash:w:&lt;filename&gt;:i</span></span></code></pre></div></li></ul><p>Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods (you only have 7 seconds to flash once it enters; some variants may require you to reset twice within 750 milliseconds): <ul><li>Press the <code>QK_BOOT</code> keycode</li><li>Press the <code>RESET</code> button on the PCB if available</li><li>Short RST to GND quickly</li></ul></li><li>Wait for the OS to detect the device</li><li>Flash a .hex file</li><li>Wait for the device to reset automatically</li></ol><h3 id="make-targets-1" tabindex="-1"><code>make</code> Targets <a class="header-anchor" href="#make-targets-1" aria-label="Permalink to &quot;`make` Targets&quot;">​</a></h3><ul><li><code>:avrdude</code>: Checks every 5 seconds until a Caterina device is available (by detecting a new COM port), and then flashes the firmware.</li><li><code>:avrdude-loop</code>: Flashes the firmware as with <code>:avrdude</code>, but after each device is flashed, will attempt to flash again. This is useful for bulk flashing. Hit Ctrl+C to escape the loop.</li><li><code>:avrdude-split-left</code> and <code>:avrdude-split-right</code>: Flashes the firmware as with <code>:avrdude</code>, but also sets the handedness setting in EEPROM. This is ideal for Pro Micro-based split keyboards.</li></ul><h2 id="halfkay" tabindex="-1">HalfKay <a class="header-anchor" href="#halfkay" aria-label="Permalink to &quot;HalfKay&quot;">​</a></h2><p>HalfKay is a super-slim bootloader developed by PJRC that presents itself as an HID device (which requires no additional driver), and comes preflashed on all Teensys, namely the 2.0. It is currently closed-source, and thus once overwritten (eg. via ISP flashing another bootloader), cannot be restored.</p><p>To ensure compatibility with the Halfkay bootloader, make sure this block is present in your <code>rules.mk</code>:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Bootloader selection</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BOOTLOADER = halfkay</span></span></code></pre></div><p>Compatible flashers:</p><ul><li><a href="https://github.com/qmk/qmk_toolbox/releases" target="_blank" rel="noreferrer">QMK Toolbox</a> (recommended GUI)</li><li><a href="https://www.pjrc.com/teensy/loader.html" target="_blank" rel="noreferrer">Teensy Loader</a></li><li><a href="https://www.pjrc.com/teensy/loader_cli.html" target="_blank" rel="noreferrer">Teensy Loader Command Line</a> / <code>:teensy</code> target in QMK (recommended command line)<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>teensy_loader_cli -v -mmcu=&lt;mcu&gt; &lt;filename&gt;</span></span></code></pre></div></li></ul><p>Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods (you only have 7 seconds to flash once it enters): <ul><li>Press the <code>QK_BOOT</code> keycode</li><li>Press the <code>RESET</code> button on the Teensy or PCB if available</li><li>short RST to GND quickly</li></ul></li><li>Wait for the OS to detect the device</li><li>Flash a .hex file</li><li>Reset the device into application mode (may be done automatically)</li></ol><h2 id="usbasploader" tabindex="-1">USBasploader <a class="header-anchor" href="#usbasploader" aria-label="Permalink to &quot;USBasploader&quot;">​</a></h2><p>USBasploader is a bootloader originally by <a href="https://www.obdev.at/products/vusb/usbasploader.html" target="_blank" rel="noreferrer">Objective Development</a>. It emulates a USBasp ISP programmer and is used in some non-USB AVR chips such as the ATmega328P, which run V-USB.</p><p>To ensure compatibility with the USBasploader bootloader, make sure this block is present in your <code>rules.mk</code>:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Bootloader selection</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BOOTLOADER = usbasploader</span></span></code></pre></div><p>Compatible flashers:</p><ul><li><a href="https://github.com/qmk/qmk_toolbox/releases" target="_blank" rel="noreferrer">QMK Toolbox</a> (recommended GUI)</li><li><a href="https://github.com/zkemble/AVRDUDESS" target="_blank" rel="noreferrer">AVRDUDESS</a></li><li><a href="https://www.nongnu.org/avrdude/" target="_blank" rel="noreferrer">avrdude</a> with the <code>usbasp</code> programmer / <code>:usbasp</code> target in QMK (recommended command line)<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>avrdude -p &lt;mcu&gt; -c usbasp -U flash:w:&lt;filename&gt;:i</span></span></code></pre></div></li></ul><p>Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods: <ul><li>Press the <code>QK_BOOT</code> keycode</li><li>Keep the <code>BOOT</code> button held while quickly tapping the <code>RESET</code> button on the PCB</li></ul></li><li>Wait for the OS to detect the device</li><li>Flash a .hex file</li><li>Press the <code>RESET</code> button on the PCB or short RST to GND</li></ol><h2 id="bootloadhid" tabindex="-1">BootloadHID <a class="header-anchor" href="#bootloadhid" aria-label="Permalink to &quot;BootloadHID&quot;">​</a></h2><p>BootloadHID is a USB bootloader for AVR microcontrollers. It presents itself as an HID input device, much like HalfKay, and can therefore be run without installing any driver on Windows.</p><p>To ensure compatibility with the bootloadHID bootloader, make sure this block is present in your <code>rules.mk</code>:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Bootloader selection</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BOOTLOADER = bootloadhid</span></span></code></pre></div><p>Compatible flashers:</p><ul><li><a href="https://github.com/qmk/qmk_toolbox/releases" target="_blank" rel="noreferrer">QMK Toolbox</a> (recommended GUI)</li><li><a href="http://vusb.wikidot.com/project:hidbootflash" target="_blank" rel="noreferrer">HIDBootFlash</a></li><li><a href="https://www.obdev.at/products/vusb/bootloadhid.html" target="_blank" rel="noreferrer">bootloadHID CLI</a> / <code>:bootloadhid</code> target in QMK (recommended command line)<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>bootloadHID -r &lt;filename&gt;</span></span></code></pre></div></li></ul><p>Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods: <ul><li>Tap the <code>QK_BOOT</code> keycode</li><li>Hold the salt key while plugging the keyboard in - for PS2AVRGB boards, this is usually the key connected to MCU pins A0 and B0, otherwise it will be documented in your keyboard&#39;s readme</li></ul></li><li>Wait for the OS to detect the device</li><li>Flash a .hex file</li><li>Reset the device into application mode (may be done automatically)</li></ol><h3 id="qmk-hid" tabindex="-1">QMK HID <a class="header-anchor" href="#qmk-hid" aria-label="Permalink to &quot;QMK HID&quot;">​</a></h3><p>QMK maintains <a href="https://github.com/qmk/lufa/tree/master/Bootloaders/HID" target="_blank" rel="noreferrer">a fork of the LUFA HID bootloader</a>, which uses a USB HID Endpoint for flashing in the way that the PJRC&#39;s Teensy Loader flasher and HalfKay bootloader work. Additionally, it performs a simple matrix scan for exiting the bootloader and returning to the application, as well as flashing an LED/making a ticking noise with a speaker when things are happening.</p><p>To ensure compatibility with the QMK HID bootloader, make sure this block is present in your <code>rules.mk</code>:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Bootloader selection</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BOOTLOADER = qmk-hid</span></span></code></pre></div><p>To enable the additional features, add the following defines to your <code>config.h</code>:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QMK_ESC_OUTPUT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> F1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // COL pin if COL2ROW</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QMK_ESC_INPUT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  D5</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ROW pin if COL2ROW</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Optional:</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//#define QMK_LED E6</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//#define QMK_SPEAKER C6</span></span></code></pre></div><p>Currently we do not recommend making <code>QMK_ESC</code> the same key as the one designated for <a href="./features/bootmagic">Bootmagic</a>, as holding it down will cause the MCU to loop back and forth between entering and exiting the bootloader.</p><p>The manufacturer and product strings are automatically pulled from <code>config.h</code>, with &quot; Bootloader&quot; appended to the product string.</p><p>To generate this bootloader, use the <code>bootloader</code> target, eg. <code>make planck/rev4:default:bootloader</code>. To generate a production-ready .hex file (combining QMK and the bootloader), use the <code>production</code> target, eg. <code>make planck/rev4:default:production</code>.</p><p>Compatible flashers:</p><ul><li>TBD <ul><li>Currently, you need to either use the <a href="https://github.com/qmk/lufa/tree/master/Bootloaders/HID/HostLoaderApp_python" target="_blank" rel="noreferrer">Python script</a>, or compile <a href="https://github.com/qmk/lufa/tree/master/Bootloaders/HID/HostLoaderApp" target="_blank" rel="noreferrer"><code>hid_bootloader_cli</code></a>, from the LUFA repo. Homebrew may (will) have support for this directly (via <code>brew install qmk/qmk/hid_bootloader_cli</code>).</li></ul></li></ul><p>Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods: <ul><li>Press the <code>QK_BOOT</code> keycode</li><li>Press the <code>RESET</code> button on the PCB if available</li><li>short RST to GND quickly</li></ul></li><li>Wait for the OS to detect the device</li><li>Flash a .hex file</li><li>Reset the device into application mode (may be done automatically)</li></ol><h3 id="make-targets-2" tabindex="-1"><code>make</code> Targets <a class="header-anchor" href="#make-targets-2" aria-label="Permalink to &quot;`make` Targets&quot;">​</a></h3><ul><li><code>:qmk-hid</code>: Checks every 5 seconds until a DFU device is available, and then flashes the firmware.</li></ul><h2 id="stm32-apm32-dfu" tabindex="-1">STM32/APM32 DFU <a class="header-anchor" href="#stm32-apm32-dfu" aria-label="Permalink to &quot;STM32/APM32 DFU&quot;">​</a></h2><p>All USB-capable STM32 and APM32 MCUs, except for a small handful (such as STM32F103 -- see the <a href="#stm32duino">STM32duino section</a>) come preloaded with a factory bootloader that cannot be modified nor deleted.</p><p>To ensure compatibility with the STM32-DFU bootloader, make sure this block is present in your <code>rules.mk</code> (optionally with <code>apm32-dfu</code> instead):</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Bootloader selection</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BOOTLOADER = stm32-dfu</span></span></code></pre></div><p>Compatible flashers:</p><ul><li><a href="https://github.com/qmk/qmk_toolbox/releases" target="_blank" rel="noreferrer">QMK Toolbox</a> (recommended GUI)</li><li><a href="https://dfu-util.sourceforge.net/" target="_blank" rel="noreferrer">dfu-util</a> / <code>:dfu-util</code> target in QMK (recommended command line)<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>dfu-util -a 0 -d 0483:DF11 -s 0x8000000:leave -D &lt;filename&gt;</span></span></code></pre></div></li></ul><p>Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods: <ul><li>Tap the <code>QK_BOOT</code> keycode (may not work on STM32F042 devices)</li><li>If a reset circuit is present, tap the <code>RESET</code> button on the PCB; some boards may also have a toggle switch that must be flipped</li><li>Otherwise, you need to bridge <code>BOOT0</code> to VCC (via <code>BOOT0</code> button or jumper), short <code>RESET</code> to GND (via <code>RESET</code> button or jumper), and then let go of the <code>BOOT0</code> bridge</li></ul></li><li>Wait for the OS to detect the device</li><li>Flash a .bin file</li><li>Reset the device into application mode (may be done automatically)</li></ol><h3 id="make-targets-3" tabindex="-1"><code>make</code> Targets <a class="header-anchor" href="#make-targets-3" aria-label="Permalink to &quot;`make` Targets&quot;">​</a></h3><ul><li><code>:dfu-util</code>: Waits until an STM32 bootloader device is available, and then flashes the firmware.</li><li><code>:dfu-util-split-left</code> and <code>:dfu-util-split-right</code>: Flashes the firmware as with <code>:dfu-util</code>, but also sets the handedness setting in EEPROM. This is ideal for Proton-C-based split keyboards.</li><li><code>:st-link-cli</code>: Allows you to flash the firmware via the ST-Link CLI utility, rather than dfu-util. Requires an ST-Link dongle.</li><li><code>:st-flash</code>: Allows you to flash the firmware via the <code>st-flash</code> utility from <a href="https://github.com/stlink-org/stlink" target="_blank" rel="noreferrer">STLink Tools</a>, rather than dfu-util. Requires an ST-Link dongle.</li></ul><h2 id="stm32duino" tabindex="-1">STM32duino <a class="header-anchor" href="#stm32duino" aria-label="Permalink to &quot;STM32duino&quot;">​</a></h2><p>This bootloader is used almost exclusively for STM32F103 boards, as they do not come with a USB DFU bootloader. The source code and prebuilt binaries can be found <a href="https://github.com/rogerclarkmelbourne/STM32duino-bootloader" target="_blank" rel="noreferrer">here</a>.</p><p>To ensure compatibility with the STM32duino bootloader, make sure this block is present in your <code>rules.mk</code>:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Bootloader selection</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BOOTLOADER = stm32duino</span></span></code></pre></div><p>Compatible flashers:</p><ul><li><a href="https://github.com/qmk/qmk_toolbox/releases" target="_blank" rel="noreferrer">QMK Toolbox</a> (recommended GUI)</li><li><a href="https://dfu-util.sourceforge.net/" target="_blank" rel="noreferrer">dfu-util</a> / <code>:dfu-util</code> target in QMK (recommended command line)<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>dfu-util -a 2 -d 1EAF:0003 -D &lt;filename&gt;</span></span></code></pre></div></li></ul><p>Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods: <ul><li>Tap the <code>QK_BOOT</code> keycode</li><li>If a reset circuit is present, tap the <code>RESET</code> button on the PCB</li><li>Otherwise, you need to bridge <code>BOOT0</code> to VCC (via <code>BOOT0</code> button or jumper), short <code>RESET</code> to GND (via <code>RESET</code> button or jumper), and then let go of the <code>BOOT0</code> bridge</li></ul></li><li>Wait for the OS to detect the device</li><li>Flash a .bin file</li><li>Reset the device into application mode (may be done automatically)</li></ol><h2 id="kiibohd-dfu" tabindex="-1">Kiibohd DFU <a class="header-anchor" href="#kiibohd-dfu" aria-label="Permalink to &quot;Kiibohd DFU&quot;">​</a></h2><p>Keyboards produced by Input Club use NXP Kinetis microcontrollers rather than STM32, and come with their own <a href="https://github.com/kiibohd/controller/tree/master/Bootloader" target="_blank" rel="noreferrer">custom bootloader</a>, however the process and protocol is largely the same.</p><p>The <code>rules.mk</code> setting for this bootloader is <code>kiibohd</code>, but since this bootloader is limited to Input Club boards, it should not be necessary to set at keymap or user level.</p><p>Compatible flashers:</p><ul><li><a href="https://github.com/qmk/qmk_toolbox/releases" target="_blank" rel="noreferrer">QMK Toolbox</a> (recommended GUI)</li><li><a href="https://dfu-util.sourceforge.net/" target="_blank" rel="noreferrer">dfu-util</a> / <code>:dfu-util</code> target in QMK (recommended command line)<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>dfu-util -a 0 -d 1C11:B007 -D &lt;filename&gt;</span></span></code></pre></div></li></ul><p>Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods: <ul><li>Tap the <code>QK_BOOT</code> keycode</li><li>Press the <code>RESET</code> button on the PCB</li></ul></li><li>Wait for the OS to detect the device</li><li>Flash a .bin file</li><li>Reset the device into application mode (may be done automatically)</li></ol><h2 id="wb32-dfu" tabindex="-1">WB32 DFU <a class="header-anchor" href="#wb32-dfu" aria-label="Permalink to &quot;WB32 DFU&quot;">​</a></h2><p>Some keyboards produced for several commercial brands (GMMK, Akko, MonsGeek, Inland) use this bootloader. The <code>wb32-dfu-updater</code> utility is bundled with <a href="https://msys.qmk.fm/" target="_blank" rel="noreferrer">QMK MSYS</a> and <a href="https://www.gloriousgaming.com/blogs/guides-resources/gmmk-2-qmk-installation-guide" target="_blank" rel="noreferrer">Glorious&#39;s build of QMK Toolbox</a>. If neither of these flashing methods is available for your OS, you will likely need to <a href="https://github.com/WestberryTech/wb32-dfu-updater" target="_blank" rel="noreferrer">compile the CLI version from source</a>.</p><p>The <code>info.json</code> setting for this bootloader is <code>wb32-dfu</code>.</p><p>Compatible flashers:</p><ul><li><a href="https://www.gloriousgaming.com/blogs/guides-resources/gmmk-2-qmk-installation-guide" target="_blank" rel="noreferrer">Glorious&#39;s build of QMK Toolbox</a> (recommended GUI)</li><li><a href="https://github.com/WestberryTech/wb32-dfu-updater" target="_blank" rel="noreferrer">wb32-dfu-updater_cli</a> / <code>:flash</code> target in QMK (recommended command line)<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>wb32-dfu-updater_cli -t -s 0x8000000 -D &lt;filename&gt;</span></span></code></pre></div></li></ul><p>Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods: <ul><li>Tap the <code>QK_BOOT</code> keycode</li><li>Press the <code>RESET</code> button on the PCB</li></ul></li><li>Wait for the OS to detect the device</li><li>Flash a .bin file</li><li>Reset the device into application mode (may be done automatically)</li></ol><h2 id="at32-dfu" tabindex="-1">AT32 DFU <a class="header-anchor" href="#at32-dfu" aria-label="Permalink to &quot;AT32 DFU&quot;">​</a></h2><p>All AT32 MCUs come preloaded with a factory bootloader that cannot be modified nor deleted.</p><p>To ensure compatibility with the AT32-DFU bootloader, make sure this block is present in your <code>rules.mk</code>:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Bootloader selection</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BOOTLOADER = at32-dfu</span></span></code></pre></div><p>Compatible flashers:</p><ul><li><a href="https://dfu-util.sourceforge.net/" target="_blank" rel="noreferrer">dfu-util</a> / <code>:dfu-util</code> target in QMK (recommended command line)<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>dfu-util -a 0 -d 2E3C:DF11 -s 0x8000000:leave -D &lt;filename&gt;</span></span></code></pre></div></li></ul><p>Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods: <ul><li>Tap the <code>QK_BOOT</code> keycode</li><li>If a reset circuit is present, tap the <code>RESET</code> button on the PCB; some boards may also have a toggle switch that must be flipped</li><li>Otherwise, you need to bridge <code>BOOT0</code> to VCC (via <code>BOOT0</code> button or jumper), short <code>RESET</code> to GND (via <code>RESET</code> button or jumper), and then let go of the <code>BOOT0</code> bridge</li></ul></li><li>Wait for the OS to detect the device</li><li>Flash a .bin file</li><li>Reset the device into application mode (may be done automatically)</li></ol><h3 id="make-targets-4" tabindex="-1"><code>make</code> Targets <a class="header-anchor" href="#make-targets-4" aria-label="Permalink to &quot;`make` Targets&quot;">​</a></h3><ul><li><code>:dfu-util</code>: Waits until an AT32 bootloader device is available, and then flashes the firmware.</li><li><code>:dfu-util-split-left</code> and <code>:dfu-util-split-right</code>: Flashes the firmware as with <code>:dfu-util</code>, but also sets the handedness setting in EEPROM.</li></ul><h2 id="tinyuf2" tabindex="-1">tinyuf2 <a class="header-anchor" href="#tinyuf2" aria-label="Permalink to &quot;tinyuf2&quot;">​</a></h2><p>Keyboards may opt into supporting the tinyuf2 bootloader. This is currently only supported on F303/F401/F411.</p><p>The <code>rules.mk</code> setting for this bootloader is <code>tinyuf2</code>, and can be specified at the keymap or user level.</p><p>To ensure compatibility with the tinyuf2 bootloader, make sure this block is present in your <code>rules.mk</code>:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Bootloader selection</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BOOTLOADER = tinyuf2</span></span></code></pre></div><p>Compatible flashers:</p><ul><li>Any application able to copy a file from one place to another, such as <em>macOS Finder</em> or <em>Windows Explorer</em>.</li></ul><p>Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods: <ul><li>Tap the <code>QK_BOOT</code> keycode</li><li>Double-tap the <code>nRST</code> button on the PCB.</li></ul></li><li>Wait for the OS to detect the device</li><li>Copy the .uf2 file to the new USB disk</li><li>Wait for the keyboard to become available</li></ol><p>or</p><p>CLI Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods: <ul><li>Tap the <code>QK_BOOT</code> keycode</li><li>Double-tap the <code>nRST</code> button on the PCB.</li></ul></li><li>Wait for the OS to detect the device</li><li>Flash via QMK CLI eg. <code>qmk flash --keyboard handwired/onekey/blackpill_f411_tinyuf2 --keymap default</code></li><li>Wait for the keyboard to become available</li></ol><h3 id="make-targets-5" tabindex="-1"><code>make</code> Targets <a class="header-anchor" href="#make-targets-5" aria-label="Permalink to &quot;`make` Targets&quot;">​</a></h3><ul><li><code>:uf2-split-left</code> and <code>:uf2-split-right</code>: Flashes the firmware but also sets the handedness setting in EEPROM by generating a side specific firmware.</li></ul><h2 id="uf2boot" tabindex="-1">uf2boot <a class="header-anchor" href="#uf2boot" aria-label="Permalink to &quot;uf2boot&quot;">​</a></h2><p>Keyboards may opt into supporting the uf2boot bootloader. This is currently only supported on F103.</p><p>The <code>rules.mk</code> setting for this bootloader is <code>uf2boot</code>, and can be specified at the keymap or user level.</p><p>To ensure compatibility with the uf2boot bootloader, make sure this block is present in your <code>rules.mk</code>:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Bootloader selection</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BOOTLOADER = uf2boot</span></span></code></pre></div><p>Compatible flashers:</p><ul><li>Any application able to copy a file from one place to another, such as <em>macOS Finder</em> or <em>Windows Explorer</em>.</li></ul><p>Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods: <ul><li>Tap the <code>QK_BOOT</code> keycode</li><li>Double-tap the <code>nRST</code> button on the PCB.</li></ul></li><li>Wait for the OS to detect the device</li><li>Copy the .uf2 file to the new USB disk</li><li>Wait for the keyboard to become available</li></ol><p>or</p><p>CLI Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods: <ul><li>Tap the <code>QK_BOOT</code> keycode</li><li>Double-tap the <code>nRST</code> button on the PCB.</li></ul></li><li>Wait for the OS to detect the device</li><li>Flash via QMK CLI eg. <code>qmk flash --keyboard handwired/onekey/bluepill_uf2boot --keymap default</code></li><li>Wait for the keyboard to become available</li></ol><h3 id="make-targets-6" tabindex="-1"><code>make</code> Targets <a class="header-anchor" href="#make-targets-6" aria-label="Permalink to &quot;`make` Targets&quot;">​</a></h3><ul><li><code>:uf2-split-left</code> and <code>:uf2-split-right</code>: Flashes the firmware but also sets the handedness setting in EEPROM by generating a side specific firmware.</li></ul><h2 id="raspberry-pi-rp2040-uf2" tabindex="-1">Raspberry Pi RP2040 UF2 <a class="header-anchor" href="#raspberry-pi-rp2040-uf2" aria-label="Permalink to &quot;Raspberry Pi RP2040 UF2&quot;">​</a></h2><p>The <code>rules.mk</code> setting for this bootloader is <code>rp2040</code>, and can be specified at the keymap or user level.</p><p>To ensure compatibility with the rp2040 bootloader, make sure this block is present in your <code>rules.mk</code>:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Bootloader selection</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">BOOTLOADER = rp2040</span></span></code></pre></div><p>Compatible flashers:</p><ul><li>Any application able to copy a file from one place to another, such as <em>macOS Finder</em> or <em>Windows Explorer</em>.</li></ul><p>Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods: <ul><li>Tap the <code>QK_BOOT</code> keycode</li><li>Hold the <code>BOOTSEL</code> button on the PCB while plugin in the usb cable.</li><li>Double-tap the <code>RESET</code> button on the PCB<sup>1</sup>.</li></ul></li><li>Wait for the OS to detect the device</li><li>Copy the .uf2 file to the new USB disk</li><li>Wait for the keyboard to become available</li></ol><p>or</p><p>CLI Flashing sequence:</p><ol><li>Enter the bootloader using any of the following methods: <ul><li>Tap the <code>QK_BOOT</code> keycode</li><li>Hold the <code>BOOTSEL</code> button on the PCB while plugin in the usb cable.</li><li>Double-tap the <code>RESET</code> button on the PCB<sup>1</sup>.</li></ul></li><li>Wait for the OS to detect the device</li><li>Flash via QMK CLI eg. <code>qmk flash --keyboard handwired/onekey/rpi_pico --keymap default</code></li><li>Wait for the keyboard to become available</li></ol><p><sup>1</sup>: This works only if the controller has been flashed with QMK Firmware with <code>RP2040_BOOTLOADER_DOUBLE_TAP_RESET</code> defined.</p>', 153);
const _hoisted_154 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_154);
}
const flashing = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  flashing as default
};
