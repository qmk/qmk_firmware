import { _ as _export_sfc, c as createElementBlock, o as openBlock, a8 as createStaticVNode } from "./chunks/framework.Cauyuiy8.js";
const __pageData = JSON.parse('{"title":"Modifier Keys","description":"","frontmatter":{},"headers":[],"relativePath":"feature_advanced_keycodes.md","filePath":"feature_advanced_keycodes.md","lastUpdated":null}');
const _sfc_main = { name: "feature_advanced_keycodes.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="modifier-keys" tabindex="-1">Modifier Keys <a class="header-anchor" href="#modifier-keys" aria-label="Permalink to &quot;Modifier Keys {#modifier-keys}&quot;">​</a></h1><p>These allow you to combine a modifier with a keycode. When pressed, the keydown event for the modifier, then <code>kc</code> will be sent. On release, the keyup event for <code>kc</code>, then the modifier will be sent.</p><table><thead><tr><th>Key</th><th>Aliases</th><th>Description</th></tr></thead><tbody><tr><td><code>LCTL(kc)</code></td><td><code>C(kc)</code></td><td>Hold Left Control and press <code>kc</code></td></tr><tr><td><code>LSFT(kc)</code></td><td><code>S(kc)</code></td><td>Hold Left Shift and press <code>kc</code></td></tr><tr><td><code>LALT(kc)</code></td><td><code>A(kc)</code>, <code>LOPT(kc)</code></td><td>Hold Left Alt and press <code>kc</code></td></tr><tr><td><code>LGUI(kc)</code></td><td><code>G(kc)</code>, <code>LCMD(kc)</code>, <code>LWIN(kc)</code></td><td>Hold Left GUI and press <code>kc</code></td></tr><tr><td><code>LCS(kc)</code></td><td></td><td>Hold Left Control and Left Shift and press <code>kc</code></td></tr><tr><td><code>LCA(kc)</code></td><td></td><td>Hold Left Control and Left Alt and press <code>kc</code></td></tr><tr><td><code>LCG(kc)</code></td><td></td><td>Hold Left Control and Left GUI and press <code>kc</code></td></tr><tr><td><code>LSA(kc)</code></td><td></td><td>Hold Left Shift and Left Alt and press <code>kc</code></td></tr><tr><td><code>LSG(kc)</code></td><td><code>SGUI(kc)</code>, <code>SCMD(kc)</code>, <code>SWIN(kc)</code></td><td>Hold Left Shift and Left GUI and press <code>kc</code></td></tr><tr><td><code>LAG(kc)</code></td><td></td><td>Hold Left Alt and Left GUI and press <code>kc</code></td></tr><tr><td><code>LCSG(kc)</code></td><td></td><td>Hold Left Control, Left Shift and Left GUI and press <code>kc</code></td></tr><tr><td><code>LCAG(kc)</code></td><td></td><td>Hold Left Control, Left Alt and Left GUI and press <code>kc</code></td></tr><tr><td><code>LSAG(kc)</code></td><td></td><td>Hold Left Shift, Left Alt and Left GUI and press <code>kc</code></td></tr><tr><td><code>RCTL(kc)</code></td><td></td><td>Hold Right Control and press <code>kc</code></td></tr><tr><td><code>RSFT(kc)</code></td><td></td><td>Hold Right Shift and press <code>kc</code></td></tr><tr><td><code>RALT(kc)</code></td><td><code>ROPT(kc)</code>, <code>ALGR(kc)</code></td><td>Hold Right Alt and press <code>kc</code></td></tr><tr><td><code>RGUI(kc)</code></td><td><code>RCMD(kc)</code>, <code>RWIN(kc)</code></td><td>Hold Right GUI and press <code>kc</code></td></tr><tr><td><code>RCA(kc)</code></td><td></td><td>Hold Right Control and Right Alt and press <code>kc</code></td></tr><tr><td><code>RCS(kc)</code></td><td></td><td>Hold Right Control and Right Shift and press <code>kc</code></td></tr><tr><td><code>RCG(kc)</code></td><td></td><td>Hold Right Control and Right GUI and press <code>kc</code></td></tr><tr><td><code>RSA(kc)</code></td><td><code>SAGR(kc)</code></td><td>Hold Right Shift and Right Alt and press <code>kc</code></td></tr><tr><td><code>RSG(kc)</code></td><td></td><td>Hold Right Shift and Right GUI and press <code>kc</code></td></tr><tr><td><code>RAG(kc)</code></td><td></td><td>Hold Right Alt and Right GUI and press <code>kc</code></td></tr><tr><td><code>RCSG(kc)</code></td><td></td><td>Hold Right Control, Right Shift and Right GUI and press <code>kc</code></td></tr><tr><td><code>RCAG(kc)</code></td><td></td><td>Hold Right Control, Right Alt and Right GUI and press <code>kc</code></td></tr><tr><td><code>RSAG(kc)</code></td><td></td><td>Hold Right Shift, Right Alt and Right GUI and press <code>kc</code></td></tr><tr><td><code>MEH(kc)</code></td><td></td><td>Hold Left Control, Left Shift and Left Alt and press <code>kc</code></td></tr><tr><td><code>HYPR(kc)</code></td><td></td><td>Hold Left Control, Left Shift, Left Alt and Left GUI and press <code>kc</code><sup>1</sup></td></tr></tbody></table><p><sup>1. More information on the Hyper key can be found on <a href="https://brettterpstra.com/2012/12/08/a-useful-caps-lock-key/" target="_blank" rel="noreferrer">this blog post by Brett Terpstra</a>.</sup></p><p>You can also chain them, for example <code>LCTL(LALT(KC_DEL))</code>, <code>C(A(KC_DEL))</code>, or <code>LCA(KC_DEL)</code> all make a key that sends Control+Alt+Delete with a single keypress.</p><h1 id="checking-modifier-state" tabindex="-1">Checking Modifier State <a class="header-anchor" href="#checking-modifier-state" aria-label="Permalink to &quot;Checking Modifier State {#checking-modifier-state}&quot;">​</a></h1><p>The current modifier state can mainly be accessed with two functions: <code>get_mods()</code> for normal modifiers and modtaps and <code>get_oneshot_mods()</code> for one-shot modifiers (unless they&#39;re held, in which case they act like normal modifier keys).</p><p>The presence of one or more specific modifiers in the current modifier state can be detected by ANDing the modifier state with a mod mask corresponding to the set of modifiers you want to match for. The reason why bitwise operators are used is that the modifier state is stored as a single byte in the format (GASC)<sub>R</sub>(GASC)<sub>L</sub>.</p><p>Thus, to give an example, <code>01000010</code> would be the internal representation of LShift+RAlt. For more information on bitwise operators in C, click <a href="https://en.wikipedia.org/wiki/Bitwise_operations_in_C" target="_blank" rel="noreferrer">here</a> to open the Wikipedia page on the topic.</p><p>In practice, this means that you can check whether a given modifier is active with <code>get_mods() &amp; MOD_BIT(KC_&lt;modifier&gt;)</code> (see the <a href="./keycodes_basic#modifiers">list of modifier keycodes</a>) or with <code>get_mods() &amp; MOD_MASK_&lt;modifier&gt;</code> if the difference between left and right hand modifiers is not important and you want to match both. Same thing can be done for one-shot modifiers if you replace <code>get_mods()</code> with <code>get_oneshot_mods()</code>.</p><p>To check that <em>only</em> a specific set of mods is active at a time, use a simple equality operator: <code>get_mods() == &lt;mod mask&gt;</code>.</p><p>For example, let&#39;s say you want to trigger a piece of custom code if one-shot left control and one-shot left shift are on but every other one-shot mods are off. To do so, you can compose the desired mod mask by combining the mod bits for left control and shift with <code>(MOD_BIT(KC_LCTL) | MOD_BIT(KC_LSFT))</code> and then plug it in: <code>get_oneshot_mods() == (MOD_BIT(KC_LCTL) | MOD_BIT(KC_LSFT))</code>. Using <code>MOD_MASK_CS</code> instead for the mod bitmask would have forced you to press four modifier keys (both versions of control and shift) to fulfill the condition.</p><p>The full list of mod masks is as follows:</p><table><thead><tr><th>Mod Mask Name</th><th>Matching Modifiers</th></tr></thead><tbody><tr><td><code>MOD_MASK_CTRL</code></td><td>LCTRL , RCTRL</td></tr><tr><td><code>MOD_MASK_SHIFT</code></td><td>LSHIFT , RSHIFT</td></tr><tr><td><code>MOD_MASK_ALT</code></td><td>LALT , RALT</td></tr><tr><td><code>MOD_MASK_GUI</code></td><td>LGUI , RGUI</td></tr><tr><td><code>MOD_MASK_CS</code></td><td>CTRL , SHIFT</td></tr><tr><td><code>MOD_MASK_CA</code></td><td>(L/R)CTRL , (L/R)ALT</td></tr><tr><td><code>MOD_MASK_CG</code></td><td>(L/R)CTRL , (L/R)GUI</td></tr><tr><td><code>MOD_MASK_SA</code></td><td>(L/R)SHIFT , (L/R)ALT</td></tr><tr><td><code>MOD_MASK_SG</code></td><td>(L/R)SHIFT , (L/R)GUI</td></tr><tr><td><code>MOD_MASK_AG</code></td><td>(L/R)ALT , (L/R)GUI</td></tr><tr><td><code>MOD_MASK_CSA</code></td><td>(L/R)CTRL , (L/R)SHIFT , (L/R)ALT</td></tr><tr><td><code>MOD_MASK_CSG</code></td><td>(L/R)CTRL , (L/R)SHIFT , (L/R)GUI</td></tr><tr><td><code>MOD_MASK_CAG</code></td><td>(L/R)CTRL , (L/R)ALT , (L/R)GUI</td></tr><tr><td><code>MOD_MASK_SAG</code></td><td>(L/R)SHIFT , (L/R)ALT , (L/R)GUI</td></tr><tr><td><code>MOD_MASK_CSAG</code></td><td>(L/R)CTRL , (L/R)SHIFT , (L/R)ALT , (L/R)GUI</td></tr></tbody></table><p>Aside from accessing the currently active modifiers using <code>get_mods()</code>, there exists some other functions you can use to modify the modifier state, where the <code>mods</code> argument refers to the modifiers bitmask.</p><ul><li><code>add_mods(mods)</code>: Enable <code>mods</code> without affecting any other modifiers</li><li><code>register_mods(mods)</code>: Like <code>add_mods</code> but send a keyboard report immediately.</li><li><code>del_mods(mods)</code>: Disable <code>mods</code> without affecting any other modifiers</li><li><code>unregister_mods(mods)</code>: Like <code>del_mods</code> but send a keyboard report immediately.</li><li><code>set_mods(mods)</code>: Overwrite current modifier state with <code>mods</code></li><li><code>clear_mods()</code>: Reset the modifier state by disabling all modifiers</li></ul><p>Similarly, in addition to <code>get_oneshot_mods()</code>, there also exists these functions for one-shot mods:</p><ul><li><code>add_oneshot_mods(mods)</code>: Enable <code>mods</code> without affecting any other one-shot modifiers</li><li><code>del_oneshot_mods(mods)</code>: Disable <code>mods</code> without affecting any other one-shot modifiers</li><li><code>set_oneshot_mods(mods)</code>: Overwrite current one-shot modifier state with <code>mods</code></li><li><code>clear_oneshot_mods()</code>: Reset the one-shot modifier state by disabling all one-shot modifiers</li></ul><h2 id="examples" tabindex="-1">Examples <a class="header-anchor" href="#examples" aria-label="Permalink to &quot;Examples {#examples}&quot;">​</a></h2><p>The following examples use <a href="./feature_macros#advanced-macro-functions">advanced macro functions</a> which you can read more about in the <a href="./feature_macros">documentation page on macros</a>.</p><h3 id="alt-escape-for-alt-tab" tabindex="-1">Alt + Escape for Alt + Tab <a class="header-anchor" href="#alt-escape-for-alt-tab" aria-label="Permalink to &quot;Alt + Escape for Alt + Tab {#alt-escape-for-alt-tab}&quot;">​</a></h3><p>Simple example where chording Left Alt with <code>KC_ESC</code> makes it behave like <code>KC_TAB</code> for alt-tabbing between applications. This example strictly checks if only Left Alt is active, meaning you can&#39;t do Alt+Shift+Esc to switch between applications in reverse order. Also keep in mind that this removes the ability to trigger the actual Alt+Escape keyboard shortcut, though it keeps the ability to do AltGr+Escape.</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> process_record_user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint16_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> keycode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">keyrecord_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">record</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (keycode) {</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KC_ESC:</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Detect the activation of only Left Alt</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get_mods</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MOD_BIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(KC_LALT)) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (record-&gt;event.pressed) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // No need to register KC_LALT because it&#39;s already active.</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // The Alt modifier will apply on this KC_TAB.</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                register_code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(KC_TAB);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                unregister_code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(KC_TAB);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Do not let QMK process the keycode further</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Else, let QMK process the KC_ESC keycode as usual</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="shift-backspace-for-delete" tabindex="-1">Shift + Backspace for Delete <a class="header-anchor" href="#shift-backspace-for-delete" aria-label="Permalink to &quot;Shift + Backspace for Delete {#shift-backspace-for-delete}&quot;">​</a></h3><p>Advanced example where the original behaviour of shift is cancelled when chorded with <code>KC_BSPC</code> and is instead fully replaced by <code>KC_DEL</code>. Two main variables are created to make this work well: <code>mod_state</code> and <code>delkey_registered</code>. The first one stores the modifier state and is used to restore it after registering <code>KC_DEL</code>. The second variable is a boolean variable (true or false) which keeps track of the status of <code>KC_DEL</code> to manage the release of the whole Backspace/Delete key correctly.</p><p>As opposed to the previous example, this doesn&#39;t use strict modifier checking. Pressing <code>KC_BSPC</code> while one or two shifts are active is enough to trigger this custom code, regardless of the state of other modifiers. That approach offers some perks: Ctrl+Shift+Backspace lets us delete the next word (Ctrl+Delete) and Ctrl+Alt+Shift+Backspace lets us execute the Ctrl+Alt+Del keyboard shortcut.</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Initialize variable holding the binary</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// representation of active modifiers.</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mod_state;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> process_record_user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">uint16_t</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> keycode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">keyrecord_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">record</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Store the current modifier state in the variable for later reference</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mod_state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_mods</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (keycode) {</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> KC_BSPC:</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Initialize a boolean variable that keeps track</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // of the delete key status: registered or not?</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> delkey_registered;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (record-&gt;event.pressed) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // Detect the activation of either shift keys</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (mod_state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MOD_MASK_SHIFT) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // First temporarily canceling both shifts so that</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // shift isn&#39;t applied to the KC_DEL keycode</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                del_mods</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MOD_MASK_SHIFT);</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                register_code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(KC_DEL);</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // Update the boolean variable to reflect the status of KC_DEL</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                delkey_registered </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // Reapplying modifier state so that the held shift key(s)</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                // still work even after having tapped the Backspace/Delete key.</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                set_mods</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mod_state);</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // on release of KC_BSPC</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            // In case KC_DEL is still being sent even after the release of KC_BSPC</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (delkey_registered) {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                unregister_code</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(KC_DEL);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                delkey_registered </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Let QMK process the KC_BSPC keycode as usual outside of shift</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>Alternatively, this can be done with <a href="./features/key_overrides#simple-example">Key Overrides</a>.</p><h1 id="advanced-topics" tabindex="-1">Advanced topics <a class="header-anchor" href="#advanced-topics" aria-label="Permalink to &quot;Advanced topics {#advanced-topics}&quot;">​</a></h1><p>This page used to encompass a large set of features. We have moved many sections that used to be part of this page to their own pages. Everything below this point is simply a redirect so that people following old links on the web find what they&#39;re looking for.</p><h2 id="switching-and-toggling-layers" tabindex="-1">Layers <a class="header-anchor" href="#switching-and-toggling-layers" aria-label="Permalink to &quot;Layers {#switching-and-toggling-layers}&quot;">​</a></h2><ul><li><a href="./feature_layers">Layers</a></li></ul><h2 id="mod-tap" tabindex="-1">Mod-Tap <a class="header-anchor" href="#mod-tap" aria-label="Permalink to &quot;Mod-Tap {#mod-tap}&quot;">​</a></h2><ul><li><a href="./mod_tap">Mod-Tap</a></li></ul><h2 id="one-shot-keys" tabindex="-1">One Shot Keys <a class="header-anchor" href="#one-shot-keys" aria-label="Permalink to &quot;One Shot Keys {#one-shot-keys}&quot;">​</a></h2><ul><li><a href="./one_shot_keys">One Shot Keys</a></li></ul><h2 id="tap-hold-configuration-options" tabindex="-1">Tap-Hold Configuration Options <a class="header-anchor" href="#tap-hold-configuration-options" aria-label="Permalink to &quot;Tap-Hold Configuration Options {#tap-hold-configuration-options}&quot;">​</a></h2><ul><li><a href="./tap_hold">Tap-Hold Configuration Options</a></li></ul><h2 id="key-overrides" tabindex="-1">Key Overrides <a class="header-anchor" href="#key-overrides" aria-label="Permalink to &quot;Key Overrides {#key-overrides}&quot;">​</a></h2><ul><li><a href="./features/key_overrides">Key Overrides</a></li></ul>', 40);
const _hoisted_41 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_41);
}
const feature_advanced_keycodes = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  feature_advanced_keycodes as default
};
