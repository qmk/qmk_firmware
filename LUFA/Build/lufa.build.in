#
#             LUFA Library
#     Copyright (C) Dean Camera, 2012.
#
#  dean [at] fourwalledcubicle [dot] com
#           www.lufa-lib.org
#

LUFA_BUILD_MODULES += BUILD
LUFA_BUILD_TARGETS += size checksource all elf hex clean

# -----------------------------------------------------------------------------
#               LUFA Compiler Buildsystem Makefile Module.
# -----------------------------------------------------------------------------
# DESCRIPTION:
#   Provides a set of targets to build a C, C++ and/or Assembly application
#   via the AVR-GCC compiler.
# -----------------------------------------------------------------------------
# TARGETS:
#
#    size                      - List application size
#    checksource               - Check existance of listed input source files
#    all                       - Build application and list size
#    elf                       - Build application ELF debug object file
#    hex                       - Build application HEX object files
#    clean                     - Remove output files
#
# MANDATORY PARAMETERS:
#
#    TARGET                    - Application name
#    ARCH                      - Device architecture name
#    MCU                       - Microcontroller device model name
#    SRC                       - List of input source files (.c, .cpp/.c++, .S)
#    F_USB                     - Speed of the input clock of the USB controller
#                                in Hz
#    LUFA_PATH                 - Path to the LUFA library core
#
# OPTIONAL PARAMETERS:
#
#    BOARD                     - LUFA board hardware
#    OPTIMIZATION              - Optimization level
#    C_STANDARD                - C Language Standard to use
#    CPP_STANDARD              - C++ Language Standard to use
#    F_CPU                     - Speed of the CPU, in Hz
#    C_FLAGS                   - Flags to pass to the C compiler only
#    CPP_FLAGS                 - Flags to pass to the C++ compiler only
#    ASM_FLAGS                 - Flags to pass to the assembler only
#    CC_FLAGS                  - Common flags to pass to the C/C++ compiler and
#                                assembler
#    LD_FLAGS                  - Flags to pass to the linker
#
# -----------------------------------------------------------------------------

# Output Messages
MSG_BUILD_BEGIN = Begin compilation of project \"$(TARGET)\"...
MSG_BUILD_END   = Finished building project \"$(TARGET)\"...
MSG_COMPILE_CMD = '  [CC]      :'
MSG_REMOVE_CMD  = '  [RM]      :'
MSG_LINKER_CMD  = '  [LNK]     :'
MSG_SIZE_CMD    = '  [SIZE]    :'
MSG_OBJCPY_CMD  = '  [OBJCPY]  :'
MSG_OBJDMP_CMD  = '  [OBJDMP]  :'

# Sanity check the user MCU, TARGET, ARCH, SRC, F_USB and LUFA_PATH makefile options
ifeq ($(TARGET),)
   $(error Makefile TARGET value not set.)
endif
ifeq ($(ARCH),)
   $(error Makefile ARCH value not set.)
endif
ifeq ($(MCU),)
   $(error Makefile MCU value not set.)
endif
ifeq ($(SRC),)
   $(error Makefile SRC value not set.)
endif
ifeq ($(F_USB),)
   $(error Makefile F_USB value not set.)
endif
ifeq ($(LUFA_PATH),)
   $(error Makefile LUFA_PATH value not set.)
endif

# Default values of user-supplied variables
BOARD         ?= NONE
OPTIMIZATION  ?= s
F_CPU         ?=
C_STANDARD    ?= gnu99
CPP_STANDARD  ?= gnu++98
C_FLAGS       ?=
CPP_FLAGS     ?=
ASM_FLAGS     ?=
CC_FLAGS      ?=

# Convert input source file list to differentiate them by type
C_SOURCE   = $(filter %.c, $(SRC))
CPP_SOURCE = $(filter %.cpp, $(SRC))
ASM_SOURCE = $(filter %.S, $(SRC))

# Convert input source filenames into a list of required output object files
OBJECT_FILES = $(filter %.o, $(C_SOURCE:%.c=%.o) $(CPP_SOURCE:%.cpp=%.o) $(ASM_SOURCE:%.S=%.o))

# Create a list of flags to pass to the compiler
ifeq ($(ARCH), AVR8)
 CC_FLAGS += -mmcu=$(MCU) -gdwarf-2 -fshort-enums -fno-inline-small-functions -fpack-struct
 CROSS     = avr-
else ifeq ($(ARCH), XMEGA)
 CC_FLAGS += -mmcu=$(MCU) -gdwarf-2 -fshort-enums -fno-inline-small-functions -fpack-struct
 CROSS     = avr-
else ifeq ($(ARCH), UC3)
 CC_FLAGS += -mpart=$(MCU) -g3 -masm-addr-pseudos
 CROSS     = avr32-
else
  $(error Unsupported architecture.)
endif
CC_FLAGS += -Wall -fno-strict-aliasing -funsigned-char -funsigned-bitfields -ffunction-sections
CC_FLAGS += -I. -I$(LUFA_PATH)/..
CC_FLAGS += -DARCH=ARCH_$(ARCH) -DBOARD=BOARD_$(BOARD) -DF_USB=$(F_USB)UL
ifneq ($(F_CPU),)
   CC_FLAGS += -DF_CPU=$(F_CPU)UL
endif

# Additional language specific compiler flags
C_FLAGS   += -Wstrict-prototypes

# Create a list of flags to pass to the linker
LD_FLAGS += -Wl,-Map=$(TARGET).map,--cref -Wl,--gc-sections -lm
ifneq ($(F_CPU), UC3)
   LD_FLAGS += -Wl,--relax
endif

# Create a list of unknown source file types, if any are found throw an error
UNKNOWN_SOURCE = $(filter-out $(C_SOURCE) $(CPP_SOURCE) $(ASM_SOURCE), $(SRC))
ifneq ($(UNKNOWN_SOURCE),)
   $(error Unknown input source formats: $(UNKNOWN_SOURCE))
endif

# Determine flags to pass to the size utility based on its reported features
SIZE_MCU_FLAG    = $(shell avr-size --help | grep -- --mcu > /dev/null && echo --mcu=$(MCU) )
SIZE_FORMAT_FLAG = $(shell avr-size --help | grep -- --format=.*avr > /dev/null && echo --format=avr )


begin:
	@echo ""
	@echo $(MSG_BUILD_BEGIN)
	
end:
	@echo $(MSG_BUILD_END)
	@echo ""

checksource:
	@for f in $(SRC) $(CPPSRC) $(ASRC); do \
		if [ -f $$f ]; then \
			echo "Found Source File: $$f" ; \
		else \
			echo "Source File Not Found: $$f" ; \
		fi; \
	 done

size:
	@echo $(MSG_SIZE_CMD) Determining size of \"$(TARGET).elf\"
	@if test -f $(TARGET).elf; then \
	    avr-size $(SIZE_MCU_FLAG) $(SIZE_FORMAT_FLAG) $(TARGET).elf ; 2>/dev/null; \
	 fi

.PHONY: begin hex lss end size
all: begin hex end size

elf: $(TARGET).elf
hex: $(TARGET).hex $(TARGET).eep
lss: $(TARGET).lss

%.o: %.c
	@echo $(MSG_COMPILE_CMD) Compiling C file \"$^\"
	$(CROSS)gcc -c $(CC_FLAGS) $(C_FLAGS) -O$(OPTIMIZATION) -std=$(C_STANDARD) $< -o $@

%.o: %.cpp
	@echo $(MSG_COMPILE_CMD) Compiling C++ file \"$^\"
	$(CROSS)gcc -c $(CC_FLAGS) $(CPP_FLAGS) -O$(OPTIMIZATION) -std=$(CPP_STANDARD) -x c++ $< -o $@
	
%.o: %.S
	@echo $(MSG_COMPILE_CMD) Assembling \"$^\"
	$(CROSS)gcc -c $(CC_FLAGS) $(ASM_FLAGS) -x assembler-with-cpp $< -o $@

.PRECIOUS : $(OBJECT_FILES)
%.elf: $(OBJECT_FILES)
	@echo $(MSG_LINKER_CMD) Linking object files into \"$@\"
	$(CROSS)gcc $^ $(CC_FLAGS) $(LD_FLAGS) -o $@

%.hex: %.elf
	@echo $(MSG_OBJCPY_CMD) Extracting HEX file data from \"$@\"
	$(CROSS)objcopy -O ihex -R .eeprom -R .fuse -R .lock -R .signature $< $@

%.eep: %.elf
	@echo $(MSG_OBJCPY_CMD) Extracting EEP file data from \"$@\"
	$(CROSS)objcopy -j .eeprom --set-section-flags=.eeprom="alloc,load" --change-section-lma .eeprom=0 --no-change-warnings -O ihex $< $@ || exit 0

%.lss: %.elf
	@echo $(MSG_OBJDMP_CMD) Extracting LSS file data from \"$@\"
	$(CROSS)objdump -h -S -z $< > $@

clean:
	@echo $(MSG_REMOVE_CMD) Removing object files \"$(OBJECT_FILES)\"
	rm -f $(OBJECT_FILES)
	@echo $(MSG_REMOVE_CMD) Removing output files \"$(TARGET).elf $(TARGET).hex $(TARGET).eep $(TARGET).map $(TARGET).lss\"
	rm -f $(TARGET).elf $(TARGET).hex $(TARGET).eep $(TARGET).map $(TARGET).lss
