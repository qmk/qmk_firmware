{"pages":[{"title":"QMK Firmware","text":"Quantum Mechanical Keyboard Firmware What is QMK Firmware? How to Get Started Quantum Mechanical Keyboard Firmware What is QMK Firmware? QMK (Quantum Mechanical Keyboard) is an open source community that maintains QMK Firmware, QMK Flasher, qmk.fm, and these docs. QMK Firmware is a keyboard firmware based on the tmk_keyboard with some useful features for Atmel AVR controllers, and more specifically, the OLKB product line, the ErgoDox EZ keyboard, and the Clueboard product line. It has also been ported to ARM chips using ChibiOS. You can use it to power your own hand-wired or custom keyboard PCB. How to Get Started Dive into the documentation!","tags":"","url":"index.html"},{"title":"Getting Started","text":"Introduction Basic QMK Structure Keyboard Project Structure Keymap Structure The config.h File Introduction This page attempts to explain the basic information you need to know to work with the QMK project. It assumes that you are familiar with navigating a Unix shell, but does not assume you are familiar with C or with compiling using make. Basic QMK Structure QMK is a fork of Jun Wako's tmk_keyboard project. The original TMK code, with modifications, can be found in the tmk folder. The QMK additions to the project may be found in the quantum folder. Keyboard projects may be found in the handwired and keyboard folders. Keyboard Project Structure Within the folder keyboards and its subfolder handwired is a directory for each keyboard project, for example qmk_firmware\/keyboards\/clueboard. Within it you'll find the following structure: keymaps\/: Different keymaps that can be built rules.mk: The file that sets the default &quot;make&quot; options. Do not edit this file directly, instead use a keymap specific Makefile config.h: The file that sets the default compile time options. Do not edit this file directly, instead use a keymap specific config.h. Keymap Structure In every keymap folder, the following files may be found. Only keymap.c is required, and if the rest of the files are not found the default options will be chosen. config.h: the options to configure your keymap keymap.c: all of your keymap code, required rules.mk: the features of QMK that are enabled readme.md: a description of your keymap, how others might use it, and explanations of features. Please upload images to a service like imgur. The config.h File There are 2 config.h locations: keyboard (\/keyboards\/&lt;keyboard&gt;\/config.h) keymap (\/keyboards\/&lt;keyboard&gt;\/keymaps\/&lt;keymap&gt;\/config.h) If the keymap config.h exists, that file is included by the build system and the keyboard config.h is not included. If you wish to override settings in your keymap's config.h you will need to include some glue code: #ifndef CONFIG_USER_H #define CONFIG_USER_H #include &quot;config_common.h&quot; If you want to override a setting from the parent config.h file, you need to #undef and then #define the setting again, like this: #undef MY_SETTING #define MY_SETTING 4","tags":"","url":"Getting_Started\/index.html"},{"title":"Install Build Tools","text":"Installing Build Tools Linux Nix macOS Windows with msys2 (recommended) Windows 10 (deprecated) Creators Update Windows Subsystem for Linux Git Toolchain Setup Some Important Things to Keep in Mind Windows (Vista and Later) (Deprecated) Docker Vagrant Installing Build Tools This page describes setting up the build environment for QMK. These instructions cover AVR processors (such as the atmega32u4). Linux To ensure you are always up to date, you can just run sudo util\/install_dependencies.sh. That should always install all the dependencies needed. This will run apt-get upgrade. You can also install things manually, but this documentation might not be always up to date with all requirements. The current requirements are the following, but not all might be needed depending on what you do. Also note that some systems might not have all the dependencies available as packages, or they might be named differently. build-essential gcc unzip wget zip gcc-avr binutils-avr avr-libc dfu-programmer dfu-util gcc-arm-none-eabi binutils-arm-none-eabi libnewlib-arm-none-eabi git Install the dependencies with your favorite package manager. Debian \/ Ubuntu example: sudo apt-get update sudo apt-get install gcc unzip wget zip gcc-avr binutils-avr avr-libc dfu-programmer dfu-util gcc-arm-none-eabi binutils-arm-none-eabi libnewlib-arm-none-eabi Fedora \/ Red Hat example: sudo dnf install gcc unzip wget zip dfu-util dfu-programmer avr-gcc avr-libc binutils-avr32-linux-gnu arm-none-eabi-gcc-cs arm-none-eabi-binutils-cs arm-none-eabi-newlib Nix If you're on NixOS, or have Nix installed on Linux or macOS, run nix-shell from the repository root to get a build environment. By default, this will download compilers for both AVR and ARM. If you don't need both, disable the avr or arm arguments, e.g.: nix-shell --arg arm false macOS If you're using homebrew, you can use the following commands: brew tap osx-cross\/avr brew tap PX4\/homebrew-px4 brew update brew install avr-gcc brew install dfu-programmer brew install gcc-arm-none-eabi brew install avrdude This is the recommended method. If you don't have homebrew, install it! It's very much worth it for anyone who works in the command line. Note that the make and make install portion during the homebrew installation of avr-libc can take over 20 minutes and exhibit high CPU usage. Windows with msys2 (recommended) The best environment to use, for Windows Vista through any later version (tested on 7 and 10), is msys2. Install msys2 by downloading it and following the instructions here: http:\/\/www.msys2.org Open the MSYS2 MingGW 64-bit shortcut Navigate to your qmk checkout. For example, if it's in the root of your c drive: $ cd \/c\/qmk_firmware Run util\/msys2_install.sh and follow the prompts Windows 10 (deprecated) These are the old instructions for Windows 10. We recommend you use MSYS2 as outlined above. Creators Update If you have Windows 10 with Creators Update or later, you can build and flash the firmware directly. Before the Creators Update, only building was possible. If you don't have it yet or if are unsure, follow these instructions. Windows Subsystem for Linux In addition to the Creators Update, you need Windows 10 Subystem for Linux, so install it following these instructions. If you already have the Windows 10 Subsystem for Linux from the Anniversary update it's recommended that you upgrade it to 16.04LTS, because some keyboards don't compile with the toolchains included in 14.04LTS. Note that you need to know what your are doing if you chose the sudo do-release-upgrade method. Git If you already have cloned the repository on your Windows file system you can ignore this section. You will need to clone the repository to your Windows file system using the normal Git for Windows and not the WSL Git. So if you haven't installed Git before, download and install it. Then set it up, it's important that you setup the e-mail and user name, especially if you are planning to contribute. Once Git is installed, open the Git Bash command and change the directory to where you want to clone QMK; note that you have to use forward slashes, and that your c drive is accessed like this \/c\/path\/to\/where\/you\/want\/to\/go. Then run git clone --recurse-submodules https:\/\/github.com\/qmk\/qmk_firmware, this will create a new folder qmk_firmware as a subfolder of the current one. Toolchain Setup The Toolchain setup is done through the Windows Subsystem for Linux, and the process is fully automated. If you want to do everything manually, there are no other instructions than the scripts themselves, but you can always open issues and ask for more information. Open &quot;Bash On Ubuntu On Windows&quot; from the start menu. Go to the directory where you cloned qmk_firmware. Note that the paths start with \/mnt\/ in the WSL, so you have to write for example cd \/mnt\/c\/path\/to\/qmk_firmware. Run util\/wsl_install.sh and follow the on-screen instructions. Close the Bash command window, and re-open it. You are ready to compile and flash the firmware! Some Important Things to Keep in Mind You can run util\/wsl_install.sh again to get all the newest updates. Your QMK repository need to be on a Windows file system path, since WSL can't run executables outside it. The WSL Git is not compatible with the Windows Git, so use the Windows Git Bash or a windows Git GUI for all Git operations You can edit files either inside WSL or normally using Windows, but note that if you edit makefiles or shell scripts, make sure you are using an editor that saves the files with Unix line endings. Otherwise the compilation might not work. Windows (Vista and Later) (Deprecated) These are the old instructions for Windows Vista and later. We recommend you use MSYS2 as outlined above. If you have ever installed WinAVR, uninstall it. Install MHV AVR Tools. Disable smatch, but be sure to leave the option to add the tools to the PATH checked. If you are going to flash Infinity based keyboards you will need to install dfu-util, refer to the instructions by Input Club. Install MinGW. During installation, uncheck the option to install a graphical user interface. DO NOT change the default installation folder. The scripts depend on the default location. Clone this repository. This link will download it as a zip file, which you'll need to extract. Open the extracted folder in Windows Explorer. Open the \\util folder. Double-click on the 1-setup-path-win batch script to run it. You'll need to accept a User Account Control prompt. Press the spacebar to dismiss the success message in the command prompt that pops up. Right-click on the 2-setup-environment-win batch script, select &quot;Run as administrator&quot;, and accept the User Account Control prompt. This part may take a couple of minutes, and you'll need to approve a driver installation, but once it finishes, your environment is complete! If you have trouble and want to ask for help, it is useful to generate a Win_Check_Output.txt file by running Win_Check.bat in the \\util folder. Docker If this is a bit complex for you, Docker might be the turn-key solution you need. After installing Docker, run the following command at the root of the QMK folder to build a keyboard\/keymap: # You'll run this every time you want to build a keymap # modify the keymap and keyboard assignment to compile what you want # defaults are ergodox\/default docker run -e keymap=gwen -e keyboard=ergodox_ez --rm -v $('pwd'):\/qmk:rw edasque\/qmk_firmware On Windows Docker seems to have issues with the VOLUME tag in Dockerfile, and $('pwd') won't print a Windows compliant path; use full path instead, like this: docker run -e keymap=default -e keyboard=ergodox_ez --rm -v D:\/Users\/Sacapuces\/Documents\/Repositories\/qmk:\/qmk:rw edasque\/qmk_firmware This will compile the targeted keyboard\/keymap and leave it in your QMK directory for you to flash. Vagrant If you have any problems building the firmware, you can try using a tool called Vagrant. It will set up a virtual computer with a known configuration that's ready-to-go for firmware building. OLKB does NOT host the files for this virtual computer. Details on how to set up Vagrant are in the vagrant guide.","tags":"","url":"Getting_Started\/Install_Build_Tools.html"},{"title":"Vagrant","text":"Vagrant Quick Start Requirements Flashing the Firmware Vagrant Quick Start This project includes a Vagrantfile that will allow you to build a new firmware for your keyboard very easily without major changes to your primary operating system. This also ensures that when you clone the project and perform a build, you have the exact same environment as anyone else using the Vagrantfile to build. This makes it much easier for people to help you troubleshoot any issues you encounter. Requirements Using the \/Vagrantfile in this repository requires you have Vagrant as well as VirtualBox (or VMware Workstation and Vagrant VMware plugin but the (paid) VMware plugin requires a licensed copy of VMware Workstation\/Fusion). COMPATIBILITY NOTICE Certain versions of Virtualbox 5 appear to have an incompatibility with the Virtualbox extensions installed in the boxes in this Vagrantfile. If you encounter any issues with the \/vagrant mount not succeeding, please upgrade your version of Virtualbox to at least 5.0.12. Alternately, you can try running the following command: vagrant plugin install vagrant-vbguest Other than having Vagrant and Virtualbox installed and possibly a restart of your computer afterwards, you can simple run a 'vagrant up' anywhere inside the folder where you checked out this project and it will start a Linux virtual machine that contains all the tools required to build this project. There is a post Vagrant startup hint that will get you off on the right foot, otherwise you can also reference the build documentation below. Flashing the Firmware The &quot;easy&quot; way to flash the firmware is using a tool from your host OS: QMK Toolbox (recommended) Teensy Loader Atmel FLIP If you want to program via the command line you can uncomment the ['modifyvm'] lines in the Vagrantfile to enable the USB passthrough into Linux and then program using the command line tools like dfu-util\/dfu-programmer or you can install the Teensy CLI version.","tags":"","url":"Getting_Started\/Vagrant.html"},{"title":"Build Compile Instructions","text":"More Detailed make Instructions rules.mk Options Customizing Makefile Options on a Per-Keymap Basis More Detailed make Instructions The full syntax of the make command is &lt;keyboard_folder&gt;:&lt;keymap&gt;:&lt;target&gt;, where: &lt;keyboard_folder&gt; is the path of the keyboard, for example planck Use all to compile all keyboards Specify the path to compile a revision, for example planck\/rev4 or planck\/rev3 If the keyboard doesn't have any folders, it can be left out To compile the default folder, you can leave it out &lt;keymap&gt; is the name of the keymap, for example algernon Use all to compile all keymaps &lt;target&gt; will be explained in more detail below. The &lt;target&gt; means the following If no target is given, then it's the same as all below all compiles as many keyboard\/revision\/keymap combinations as specified. For example, make planck\/rev4:default will generate a single .hex, while make planck\/rev4:all will generate a hex for every keymap available to the planck. dfu, teensy or dfu-util, compile and upload the firmware to the keyboard. If the compilation fails, then nothing will be uploaded. The programmer to use depends on the keyboard. For most keyboards it's dfu, but for ChibiOS keyboards you should use dfu-util, and teensy for standard Teensys. To find out which command you should use for your keyboard, check the keyboard specific readme. Note: some operating systems need root access for these commands to work, so in that case you need to run for example sudo make planck\/rev4:default:dfu. clean, cleans the build output folders to make sure that everything is built from scratch. Run this before normal compilation if you have some unexplainable problems. You can also add extra options at the end of the make command line, after the target make COLOR=false - turns off color output make SILENT=true - turns off output besides errors\/warnings make VERBOSE=true - outputs all of the gcc stuff (not interesting, unless you need to debug) make EXTRAFLAGS=-E - Preprocess the code without doing any compiling (useful if you are trying to debug #define commands) The make command itself also has some additional options, type make --help for more information. The most useful is probably -jx, which specifies that you want to compile using more than one CPU, the x represents the number of CPUs that you want to use. Setting that can greatly reduce the compile times, especially if you are compiling many keyboards\/keymaps. I usually set it to one less than the number of CPUs that I have, so that I have some left for doing other things while it's compiling. Note that not all operating systems and make versions supports that option. Here are some examples commands make all:all builds everything (all keyboard folders, all keymaps). Running just make from the root will also run this. make ergodox_infinity:algernon:clean will clean the build output of the Ergodox Infinity keyboard. make planck\/rev4:default:dfu COLOR=false builds and uploads the keymap without color output. rules.mk Options Set these variables to no to disable them, and yes to enable them. BOOTMAGIC_ENABLE This allows you to hold a key and the salt key (space by default) and have access to a various EEPROM settings that persist over power loss. It's advised you keep this disabled, as the settings are often changed by accident, and produce confusing results that makes it difficult to debug. It's one of the more common problems encountered in help sessions. Consumes about 1000 bytes. MOUSEKEY_ENABLE This gives you control over cursor movements and clicks via keycodes\/custom functions. EXTRAKEY_ENABLE This allows you to use the system and audio control key codes. CONSOLE_ENABLE This allows you to print messages that can be read using hid_listen. By default, all debug (dprint) print (print, xprintf), and user print (uprint) messages will be enabled. This will eat up a significant portion of the flash and may make the keyboard .hex file too big to program. To disable debug messages (dprint) and reduce the .hex file size, include #define NO_DEBUG in your config.h file. To disable print messages (print, xprintf) and user print messages (uprint) and reduce the .hex file size, include #define NO_PRINT in your config.h file. To disable print messages (print, xprintf) and KEEP user print messages (uprint), include #define USER_PRINT in your config.h file. To see the text, open hid_listen and enjoy looking at your printed messages. NOTE: Do not include uprint messages in anything other than your keymap code. It must not be used within the QMK system framework. Otherwise, you will bloat other people's .hex files. Consumes about 400 bytes. COMMAND_ENABLE This enables magic commands, typically fired with the default magic key combo LSHIFT+RSHIFT+KEY. Magic commands include turning on debugging messages (MAGIC+D) or temporarily toggling NKRO (MAGIC+N). SLEEP_LED_ENABLE Enables your LED to breath while your computer is sleeping. Timer1 is being used here. This feature is largely unused and untested, and needs updating\/abstracting. NKRO_ENABLE This allows the keyboard to tell the host OS that up to 248 keys are held down at once (default without NKRO is 6). NKRO is off by default, even if NKRO_ENABLE is set. NKRO can be forced by adding #define FORCE_NKRO to your config.h or by binding MAGIC_TOGGLE_NKRO to a key and then hitting the key. BACKLIGHT_ENABLE This enables your backlight on Timer1 and ports B5, B6, or B7 (for now). You can specify your port by putting this in your config.h: #define BACKLIGHT_PIN B7 MIDI_ENABLE This enables MIDI sending and receiving with your keyboard. To enter MIDI send mode, you can use the keycode MI_ON, and MI_OFF to turn it off. This is a largely untested feature, but more information can be found in the quantum\/quantum.c file. UNICODE_ENABLE This allows you to send unicode symbols via UC(&lt;unicode&gt;) in your keymap. Only codes up to 0x7FFF are currently supported. UNICODEMAP_ENABLE This allows sending unicode symbols using X(&lt;unicode&gt;) in your keymap. Codes up to 0xFFFFFFFF are supported, including emojis. You will need to maintain a separate mapping table in your keymap file. Known limitations: Under Mac OS, only codes up to 0xFFFF are supported. Under Linux ibus, only codes up to 0xFFFFF are supported (but anything important is still under this limit for now). Characters out of range supported by the OS will be ignored. BLUETOOTH_ENABLE This allows you to interface with a Bluefruit EZ-key to send keycodes wirelessly. It uses the D2 and D3 pins. AUDIO_ENABLE This allows you output audio on the C6 pin (needs abstracting). See the audio page for more information. FAUXCLICKY_ENABLE Uses buzzer to emulate clicky switches. A cheap imitation of the Cherry blue switches. By default, uses the C6 pin, same as AUDIO_ENABLE. VARIABLE_TRACE Use this to debug changes to variable values, see the tracing variables section of the Unit Testing page for more information. API_SYSEX_ENABLE This enables using the Quantum SYSEX API to send strings (somewhere?) This consumes about 5390 bytes. KEY_LOCK_ENABLE This enables key lock. This consumes an additional 260 bytes. Customizing Makefile Options on a Per-Keymap Basis If your keymap directory has a file called rules.mk any options you set in that file will take precedence over other rules.mk options for your particular keyboard. So let's say your keyboard's rules.mk has BACKLIGHT_ENABLE = yes. You want your particular keyboard to not have the backlight, so you make a file called rules.mk and specify BACKLIGHT_ENABLE = no.","tags":"","url":"Getting_Started\/Build_Compile_Instructions.html"},{"title":"Flashing Firmware","text":"Flashing Instructions and Bootloader Information DFU QMK DFU Caterina Halfkay Flashing Instructions and Bootloader Information There are quite a few different types of bootloaders that keyboards use, and just about all of the use a different flashing method. Luckily, projects like the QMK Toolbox aim to be compatible with all the different types without having to think about it much, but this article will describe the different types of bootloaders, and available methods for flashing them. If you have a bootloader selected with the BOOTLOADER variable in your rules.mk, QMK will automatically calculate if your .hex file is the right size to be flashed to the device, and output the total size it bytes (along with the max). To run this process manually, compile with the target check-size, eg make planck\/rev4:default:check-size. DFU Atmel's DFU bootloader comes on all atmega32u4 chips by default, and is used by many keyboards that have their own ICs on their PCBs (Older OLKB boards, Clueboards). Some keyboards may also use LUFA's DFU bootloader (or QMK's fork) (Newer OLKB boards) that adds in additional features specific to that hardware. To ensure compatibility with the DFU bootloader, make sure this block is present your rules.mk (optionally with lufa-dfu or qmk-dfu instead): # Bootloader # This definition is optional, and if your keyboard supports multiple bootloaders of # different sizes, comment this out, and the correct address will be loaded # automatically (+60). See bootloader.mk for all options. BOOTLOADER = atmel-dfu Compatible flashers: QMK Toolbox (recommended GUI) dfu-programmer \/ :dfu in QMK (recommended command line) Atmel's Flip (not recommended) Flashing sequence: Press the RESET keycode, or tap the RESET button (or short RST to GND). Wait for the OS to detect the device Erase the memory (may be done automatically) Flash a .hex file Reset the device into application mode (may be done automatically) or: make &lt;keyboard&gt;:&lt;keymap&gt;:dfu QMK DFU QMK has a fork of the LUFA DFU bootloader that allows for a simple matrix scan for exiting the bootloader and returning to the application, as well as flashing an LED\/making a ticking noise with a speaker when things are happening. To enable these features, use this block in your config.h (The key that exits the bootloader needs to be hooked-up to the INPUT and OUTPUT defined here): #define QMK_ESC_OUTPUT F1 \/\/ usually COL #define QMK_ESC_INPUT D5 \/\/ usually ROW #define QMK_LED E6 #define QMK_SPEAKER C6 The Manufacturer and Product names are automatically pulled from your config.h, and &quot;Bootloader&quot; is added to the product. To generate this bootloader, use the bootloader target, eg make planck\/rev4:default:bootloader. To generate a production-ready .hex file (containing the application and the bootloader), use the production target, eg make planck\/rev4:default:production. Caterina Arduino boards and their clones use the Caterina bootloader (any keyboard built with a Pro Micro, or clone), and uses the avr109 protocol to communicate through virtual serial. Bootloaders like A-Star are based on Caterina. To ensure compatibility with the Caterina bootloader, make sure this block is present your rules.mk: # Bootloader # This definition is optional, and if your keyboard supports multiple bootloaders of # different sizes, comment this out, and the correct address will be loaded # automatically (+60). See bootloader.mk for all options. BOOTLOADER = caterina Compatible flashers: QMK Toolbox (recommended GUI) avrdude with avr109 \/ :avrdude (recommended command line) AVRDUDESS Flashing sequence: Press the RESET keycode, or short RST to GND quickly (you only have 7 seconds to flash once it enters) Wait for the OS to detect the device Flash a .hex file Wait for the device to reset automatically or make &lt;keyboard&gt;:&lt;keymap&gt;:avrdude Halfkay Halfkay is a super-slim protocol developed by PJRC that uses HID, and come on all Teensys (namely the 2.0). To ensure compatibility with the Halfkay bootloader, make sure this block is present your rules.mk: # Bootloader # This definition is optional, and if your keyboard supports multiple bootloaders of # different sizes, comment this out, and the correct address will be loaded # automatically (+60). See bootloader.mk for all options. BOOTLOADER = halfkay Compatible flashers: QMK Toolbox (recommended GUI) Teensy Loader Teensy Loader Command Line (recommended command line) Flashing sequence: Press the RESET keycode, or short RST to GND quickly (you only have 7 seconds to flash once it enters) Wait for the OS to detect the device Flash a .hex file Reset the device into application mode (may be done automatically)","tags":"","url":"Getting_Started\/Flashing_Firmware.html"},{"title":"Contributing","text":"How to Contribute I Don't Want to Read This Whole Thing! I Just Have a Question! Project Overview Where Can I Go for Help? How Do I Make a Contribution? Coding Conventions General Guidelines Documentation Keymaps Keyboards Quantum\/TMK Core Refactoring What Does the Code of Conduct Mean for Me? How to Contribute \ud83d\udc4d\ud83c\udf89 First off, thanks for taking the time to read this and contribute! \ud83c\udf89\ud83d\udc4d Third-party contributions help us grow and improve QMK. We want to make the pull request and contribution process useful and easy for both contributors and maintainers. To this end we've put together some guidelines for contributors to help your pull request be accepted without major changes. Project Overview Coding Conventions General Guidelines What does the Code of Conduct mean for me? I Don't Want to Read This Whole Thing! I Just Have a Question! If you'd like to ask questions about QMK you can do so on the OLKB Subreddit or on Gitter. Please keep these things in mind: It may take several hours for someone to respond to your question. Please be patient! Everyone involved with QMK is donating their time and energy. We don't get paid to work on or answer questions about QMK. Try to ask your question so it's as easy to answer as possible. If you're not sure how to do that these are some good guides: https:\/\/opensource.com\/life\/16\/10\/how-ask-technical-questions http:\/\/www.catb.org\/esr\/faqs\/smart-questions.html Project Overview QMK is largely written in C, with specific features and parts written in C++. It targets embedded processors found in keyboards, particularly AVR (LUFA) and ARM (ChibiOS). If you are already well versed in Arduino programming you'll find a lot of the concepts and limitations familiar. Prior experience with Arduino is not required to successfully contribute to QMK. Where Can I Go for Help? If you need help you can open an issue or chat on gitter. How Do I Make a Contribution? Never made an open source contribution before? Wondering how contributions work in QMK? Here's a quick rundown! Sign up for a GitHub account. Put together a keymap to contribute, find an issue you are interested in addressing, or a feature you would like to add. Fork the repository associated with the issue to your GitHub account. This means that you will have a copy of the repository under your-GitHub-username\/qmk_firmware. Clone the repository to your local machine using git clone https:\/\/github.com\/github-username\/repository-name.git. If you're working on a new feature consider opening an issue to talk with us about the work you're about to undertake. Create a new branch for your fix using git checkout -b branch-name-here. Make the appropriate changes for the issue you are trying to address or the feature that you want to add. Use git add insert-paths-of-changed-files-here to add the file contents of the changed files to the &quot;snapshot&quot; git uses to manage the state of the project, also known as the index. Use git commit -m &quot;Insert a short message of the changes made here&quot; to store the contents of the index with a descriptive message. Push the changes to your repository on GitHub using git push origin branch-name-here. Submit a pull request to QMK Firmware. Title the pull request with a short description of the changes made and the issue or bug number associated with your change. For example, you can title an issue like so &quot;Added more log outputting to resolve #4352&quot;. In the description of the pull request explain the changes that you made, any issues you think exist with the pull request you made, and any questions you have for the maintainer. It's OK if your pull request is not perfect (no pull request is), the reviewer will be able to help you fix any problems and improve it! Wait for the pull request to be reviewed by a maintainer. Make changes to the pull request if the reviewing maintainer recommends them. Celebrate your success after your pull request is merged! Coding Conventions Most of our style is pretty easy to pick up on, but right now it's not entirely consistent. You should match the style of the code surrounding your change, but if that code is inconsistent or unclear use the following guidelines: We indent using two spaces (soft tabs) We use One True Brace Style Opening Brace: At the end of the same line as the statement that opens the block Closing Brace: Lined up with the first character of the statement that opens the block Else If: Place the closing brace at the beginning of the line and the next opening brace at the end of the same line. Optional Braces: Always include optional braces. Good: if (condition) { return false; } Bad: if (condition) return false; We use C style comments: \/* *\/ Think of them as a story describing the feature Use them liberally to explain why particular decisions were made. Do not write obvious comments If you not sure if a comment is obvious, go ahead and include it. In general we don't wrap lines, they can be as long as needed. If you do choose to wrap lines please do not wrap any wider than 76 columns. General Guidelines We have a few different types of changes in QMK, each requiring a different level of rigor. We'd like you to keep the following guidelines in mind no matter what type of change you're making. Separate PR's into logical units. For example, do not submit one PR covering two separate features, instead submit a separate PR for each feature. Check for unnecessary whitespace with git diff --check before committing. Make sure your code change actually compiles. Keymaps: Make sure that make keyboard:your_new_keymap does not return an error Keyboards: Make sure that make keyboard:all does not return any errors Core: Make sure that make all does not return any errors. Make sure commit messages are understandable on their own. You should put a short description (no more than 70 characters) on the first line, the second line should be empty, and on the 3rd and later lines you should describe your commit in detail, if required. Example: Adjust the fronzlebop for the kerpleplork The kerpleplork was intermittently failing with error code 23. The root cause was the fronzlebop setting, which causes the kerpleplork to activate every N iterations. Limited experimentation on the devices I have available shows that 7 is high enough to avoid confusing the kerpleplork, but I'd like to get some feedback from people with ARM devices to be sure. Documentation Documentation is one of the easiest ways to get started contributing to QMK. Finding places where the documentation is wrong or incomplete and fixing those is easy! We also very badly need someone to edit our documentation, so if you have editing skills but aren't sure where or how to jump in please reach out for help! You'll find all our documentation in the qmk_firmware\/docs directory, or if you'd rather use a web based workflow you can click &quot;Suggest An Edit&quot; at the top of each page on http:\/\/docs.qmk.fm\/. Keymaps Most first-time QMK contributors start with their personal keymaps. We try to keep keymap standards pretty casual (keymaps, after all, reflect the personality of their creators) but we do ask that you follow these guidelines to make it easier for others to discover and learn from your keymap. Write a readme.md using the template. All Keymap PR's are squashed, so if you care about how your commits are squashed you should do it yourself Do not lump features in with keymap PR's. Submit the feature first and then a second PR for the keymap. Do not include Makefiles in your keymap folder (they're no longer used) Update copyrights in file headers (look for REPLACE_WITH_YOUR_NAME) Keyboards Keyboards are the raison d'\u00eatre for QMK. Some keyboards are community maintained, while others are maintained by the people responsible for making a particular keyboard. The readme.md should tell you who maintains a particular keyboard. If you have questions relating to a particular keyboard you can Open An Issue and tag the maintainer in your question. We also ask that you follow these guidelines: Write a readme.md using the template. Keep the number of commits reasonable or we will squash your PR Do not lump core features in with new keyboards. Submit the feature first and then submit a separate PR for the keyboard. Name .c\/.h file after the immediate parent folder, eg \/keyboards\/&lt;kb1&gt;\/&lt;kb2&gt;\/&lt;kb2&gt;.[ch] Do not include Makefiles in your keyboard folder (they're no longer used) Update copyrights in file headers (look for REPLACE_WITH_YOUR_NAME) Quantum\/TMK Core Before you put a lot of work into building your new feature you should make sure you are implementing it in the best way. You can get a basic understanding of QMK by reading Understanding QMK, which will take you on a tour of the QMK program flow. From here you should talk to us to get a sense of the best way to implement your idea. There are two main ways to do this: Chat on Gitter Open an Issue Feature and Bug Fix PR's affect all keyboards. We are also in the process of restructuring QMK. For this reason it is especially important for significant changes to be discussed before implementation has happened. If you open a PR without talking to us first please be prepared to do some significant rework if your choices do not mesh well with our planned direction. Here are some things to keep in mind when working on your feature or bug fix. Disabled by default - memory is a pretty limited on most chips QMK supports, and it's important that current keymaps aren't broken, so please allow your feature to be turned on, rather than being turned off. If you think it should be on by default, or reduces the size of the code, please talk with us about it. Compile locally before submitting - hopefully this one is obvious, but things need to compile! Our Travis system will catch any issues, but it's generally faster for you to compile a few keyboards locally instead of waiting for the results to come back. Consider revisions and different chip-bases - there are several keyboards that have revisions that allow for slightly different configurations, and even different chip-bases. Try to make a feature supported in ARM and AVR, or automatically disabled on platforms it doesn't work on. Explain your feature - Document it in docs\/, either as a new file or as part of an existing file. If you don't document it other people won't be able to benefit from your hard work. We also ask that you follow these guidelines: Keep the number of commits reasonable or we will squash your PR Do not lump keyboards or keymaps in with core changes. Submit your core changes first. Write Unit Tests for your feature Follow the style of the file you are editing. If the style is unclear or there are mixed styles you should conform to the coding conventions above. Refactoring To maintain a clear vision of how things are laid out in QMK we try to plan out refactors in-depth and have a collaborator make the changes. If you have an idea for refactoring, or suggestions, open an issue, we'd love to talk about how QMK can be improved. What Does the Code of Conduct Mean for Me? Our Code of Conduct means that you are responsible for treating everyone on the project with respect and courtesy regardless of their identity. If you are the victim of any inappropriate behavior or comments as described in our Code of Conduct, we are here for you and will do the best to ensure that the abuser is reprimanded appropriately, per our code.","tags":"","url":"Getting_Started\/Contributing.html"},{"title":"How to Use GitHub","text":"How to Use Github with QMK How to Use Github with QMK Github can be a little tricky to those that aren't familiar with it - this guide will walk through each step of forking, cloning, and submitting a pull request with QMK. {% hint style='info' %} This guide assumes you're somewhat comfortable with running things at the command line, and have git installed on your system. {% endhint %} Start on the QMK Github page, and you'll see a button in the upper right that says &quot;Fork&quot;: If you're apart of an organization, you'll need to choose which account to fork it to. In most circumstances, you'll want to fork it to your personal account. Once your fork is completed (sometimes this takes a little while), click the &quot;Clone or Download&quot; button: And be sure to select &quot;HTTPS&quot;, and select the link and copy it: From here, enter git clone into the command line, and then paste your link: **[terminal] **[prompt you@computer]**[path ~]**[delimiter $ ]**[command git clone https:\/\/github.com\/whoeveryouare\/qmk_firmware.git] Cloning into 'qmk_firmware'... remote: Counting objects: 46625, done. remote: Compressing objects: 100% (2\/2), done. remote: Total 46625 (delta 0), reused 0 (delta 0), pack-reused 46623 Receiving objects: 100% (46625\/46625), 84.47 MiB | 3.14 MiB\/s, done. Resolving deltas: 100% (29362\/29362), done. Checking out files: 100% (2799\/2799), done. You now have your QMK fork on your local machine, and you can add your keymap, compile it and flash it to your board. Once you're happy with your changes, you can add, commit, and push them to your fork like this: **[terminal] **[prompt you@computer]**[path ~\/qmk_firmware]**[delimiter $ ]**[command git add .] **[prompt you@computer]**[path ~\/qmk_firmware]**[delimiter $ ]**[command git commit -m &quot;adding my keymap&quot;] [master cccb1608] adding my keymap 1 file changed, 1 insertion(+) create mode 100644 keyboards\/planck\/keymaps\/mine\/keymap.c **[prompt you@computer]**[path ~\/qmk_firmware]**[delimiter $ ]**[command git push] Counting objects: 1, done. Delta compression using up to 4 threads. Compressing objects: 100% (1\/1), done. Writing objects: 100% (1\/1), 1.64 KiB | 0 bytes\/s, done. Total 1 (delta 1), reused 0 (delta 0) remote: Resolving deltas: 100% (1\/1), completed with 1 local objects. To https:\/\/github.com\/whoeveryouare\/qmk_firmware.git + 20043e64...7da94ac5 master -&gt; master Your changes now exist on your fork on Github - if you go back there (https:\/\/github.com\/&lt;whoeveryouare&gt;\/qmk_firmware), you can create a &quot;New Pull Request&quot; by clicking this button: Here you'll be able to see exactly what you've committed - if it all looks good, you can finalize it by clicking &quot;Create Pull Request&quot;: After submitting, we may talk to you about your changes, ask that you make changes, and eventually accept it! Thanks for contributing to QMK :)","tags":"","url":"Getting_Started\/How_to_Use_GitHub.html"},{"title":"Getting Help","text":"Getting Help Realtime Chat OLKB Subreddit Github Issues Getting Help There are a lot of resources for getting help with QMK. Realtime Chat You can find QMK developers and users on our main gitter chat room. We also have other rooms for more specific discussion: Main Firmware Chat QMK Toolbox Hardware Design Discussion Web Configurator Compiler API OLKB Subreddit The official QMK forum is \/r\/olkb on reddit.com. Github Issues You can open an issue on GitHub. This is especially handy when your issue will require long-term discussion or debugging.","tags":"","url":"Getting_Started\/Getting_Help.html"},{"title":"Complete Newbs Guide","text":"Introduction Getting Started Download Software Text Editor QMK Toolbox Environment Setup Windows macOS Linux Download QMK Setup QMK Test Your Build Environment Creating Your Layout Introduction Your computer keyboard has a processor inside of it, not unlike the one inside your computer. This processor runs software that is responsible for detecting button presses and sending reports about the state of the keyboard when they are pressed or released. QMK fills the role of that software, detecting button presses and passing that information on to the host computer. When you build your custom layout you are creating the equivalent of an .exe for your keyboard. QMK tries to put a lot of power into your hands by making easy things easy, and hard things possible. You don't have to know how to program to create powerful layouts, you only have to follow a few simple syntax rules. Getting Started Before you can build keymaps you need to install some software and setup your build environment. This only has to be done one time no matter how many keyboards you want to compile firmware for. Download Software Text Editor You'll need a program that can edit and save plain text files. If you are on Windows you can make due with Notepad, and on Linux you can use Gedit, both of which are simple but functional text editors. On macOS you can not use TextEdit.app, it will not save plain text files. You will need to install another program such as Sublime Text. {% hint style='info' %} Not sure which text editor to use? Laurence Bradford wrote a great introduction to the subject. {% endhint %} QMK Toolbox QMK Toolbox is a Windows and macOS program that allows you to both program and debug your custom keyboard. You will want to install it so that you can easily flash your keyboard and receive the debugging messages that your keyboard will print. Newest Release Source Code Environment Setup We've tried to make QMK as easy to setup as possible. You only have to prepare your Linux or Unix environment and let QMK install the rest. {% hint style=&quot;info&quot; %} If you haven't worked with the Linux\/Unix command line before there are a few basic concepts and commands you should learn. These resources will teach you enough to work with QMK: Must Know Linux Commands Some Basic Unix Commands {% endhint %} Windows You will need to install msys2 and git. Follow the installation instructions on the msys2 homepage: http:\/\/www.msys2.org Close any open msys2 terminals, and open a new terminal Install git by running this command: pacman -S git macOS You will need to install homebrew. Follow the instructions on the homebrew homepage: https:\/\/brew.sh Linux You will need to install git. It's extremely likely you already have it, but if not one of the following commands should install it: Debian\/Ubuntu\/Devuan: apt-get install git Fedora\/Redhat\/Centos: yum install git Arch: pacman -S git Download QMK Once you have setup your Linux\/Unix environment you are ready to download QMK. We will do this by using git to &quot;clone&quot; the QMK repository. Open a Terminal or MSYS2 Console window and leave it open for the remainder of this guide. Inside that window run these two commands: git clone https:\/\/github.com\/qmk\/qmk_firmware.git cd qmk_firmware {% hint style='info' %} If you already know how to use GitHub we recommend you create and clone your own fork instead. If you don't know what that means you can safely ignore this message. {% endhint %} Setup QMK QMK comes with a script to help you setup the rest of what you'll need. You should run it now by typing in this command: .\/util\/qmk_install.sh Test Your Build Environment Now that your QMK build environment is setup you can build a firmware for your keyboard. Start by trying to build the default layout for your keyboard. You should be able to do that with a command in this format: make &lt;keyboard&gt;:default For example, to build a firmware for a Clueboard 66% use: make clueboard\/66\/rev3:default When it is done you should have a lot of output that ends similar to this: Linking: .build\/clueboard_66_rev2_default.elf [OK] Creating load file for flashing: .build\/clueboard_66_rev2_default.hex [OK] Copying clueboard_66_rev2_default.hex to qmk_firmware folder [OK] Checking file size of clueboard_66_rev2_default.hex [OK] * File size is fine - 25174\/28672 Creating Your Layout Now you are ready to create your own personal layout. Move on to Building Your First Firmware for that.","tags":"","url":"Complete_Newbs_Guide\/index.html"},{"title":"Complete Newbie's Guide","text":"The Compelete Newbs Guide To QMK Overview The Compelete Newbs Guide To QMK QMK is a powerful Open Source firmware for your mechanical keyboard. You can use QMK to customize your keyboard in ways both simple and powerful. People of all skill levels, from complete newbie to master programmer, have successfully used QMK to customize their keyboard. This guide will help you do the same, no matter your skill level. Not sure if your keyboard can run QMK? If it's a mechanical keyboard you built yourself chances are good it can. We support a large number of hobbyist boards, so even if your current keyboard can't run QMK you shouldn't have trouble finding one to suit your needs. Overview There are 4 main sections to this guide: Getting Started Building Your First Firmware Flashing Firmware Testing and Debugging This guide is focused on helping someone who has never compiled software before. It makes choices and recommendations based on that viewpoint. There are alternative methods for many of these procedures, and we support most of those alternatives. If you have any doubt about how to accomplish a task you can ask us for guidance.","tags":"","url":"Complete_Newbs_Guide\/Complete_Newbie's_Guide.html"},{"title":"Building Your First Firmware","text":"Building Your First Firmware Navigate To Your Keymaps Folder Create a Copy Of The default Keymap Open keymap.c In Your Favorite Text Editor Customize The Layout To Your Liking Build Your Firmware Flash Your Firmware Building Your First Firmware Now that you have setup your build environment you are ready to start building custom firmware. For this section of the guide we will bounce between 3 programs- your file manager, your text editor, and your terminal window. Keep all 3 open until you are done and happy with your keyboard firmware. If you have closed and reopened your terminal window since following the first part of the guide, don't forget to cd qmk_firmware so that your terminal is in the correct directory. Navigate To Your Keymaps Folder Start by navigating to the keymaps folder for your keyboard. {% hint style='info' %} If you are on macOS or Windows there are commands you can use to easily open the keymaps folder. macOS: open keyboards\/&lt;keyboard_folder&gt;\/keymaps Windows: start keyboards\/&lt;keyboard_folder&gt;\/keymaps {% endhint %} Create a Copy Of The default Keymap Once you have the keymaps folder open you will want to create a copy of the default folder. We highly recommend you name your folder the same as your GitHub username, but you can use any name you want as long as it contains only lower case letters, numbers, and the underscore character. Open keymap.c In Your Favorite Text Editor Open up your keymap.c. Inside this file you'll find the structure that controls how your keyboard behaves. At the top of keymap.c there may be some defines and enums that make the keymap easier to read. Farther down you'll find a line that looks like this: const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = { This line indicates the start of the list of Layers. Below that you'll find lines containing either LAYOUT or KEYMAP, and these lines indicate the start of a layer. Below that line is the list of keys that comprise a that particular layer. {% hint style='danger' %} When editing your keymap file be careful not to add or remove any commas. If you do you will prevent your firmware from compiling and it may not be easy to figure out where the extra, or missing, comma is. {% endhint %} Customize The Layout To Your Liking How to complete this step is entirely up to you. Make the one change that's been bugging you, or completely rework everything. You can remove layers if you don't need all of them, or add layers up to a total of 32. Check the following documentation to find out what you can define here: Keycodes Features FAQ {% hint style='info' %} While you get a feel for how keymaps work, keep each change small. Bigger changes make it harder to debug any problems that arise. {% endhint %} Build Your Firmware When your changes to the keymap are complete you will need to build the firmware. To do so go back to your terminal window and run the build command: make &lt;my_keyboard&gt;:&lt;my_keymap&gt; For example, if your keymap is named &quot;xyverz&quot; and you're building a keymap for a rev5 planck, you'll use this command: make planck\/rev5:xyverz While this compiles you will have a lot of output going to the screen informing you of what files are being compiled. It should end with output that looks similar to this: Linking: .build\/planck_rev5_xyverz.elf [OK] Creating load file for flashing: .build\/planck_rev5_xyverz.hex [OK] Copying planck_rev5_xyverz.hex to qmk_firmware folder [OK] Checking file size of planck_rev5_xyverz.hex [OK] * File size is fine - 18392\/28672 Flash Your Firmware Move on to Flashing Firmware to learn how to write your new firmware to your keyboard.","tags":"","url":"Complete_Newbs_Guide\/Building_Your_First_Firmware.html"},{"title":"Flashing Firmware","text":"Flashing Your Keyboard Flashing Your Keyboard with QMK Toolbox Load The File Into QMK Toolbox Put Your Keyboard Into DFU (Bootloader) Mode Flash Your Keyboard Flash your Keyboard from the Command Line DFU Caterina HalfKay Test It Out! Flashing Your Keyboard Now that you've built a custom firmware file you'll want to flash your keyboard. Flashing Your Keyboard with QMK Toolbox The simplest way to flash your keyboard will be with the QMK Toolbox. However, the QMK Toolbox is only available for Windows and macOS currently. If you're using Linux (or just wish to flash the firmware from the command line), you'll have to use the method outlined below. Load The File Into QMK Toolbox Begin by opening the QMK Toolbox application. You'll want to locate the firmware file in Finder or Explorer. Your keyboard firmware may be in one of two formats- .hex or .bin. QMK tries to copy the appropriate one for your keyboard into the root qmk_firmware directory. {% hint style='info' %} If you are on Windows or macOS there are commands you can use to easily open the current firmware folder in Explorer or Finder. Windows: start . macOS: open . {% endhint %} The firmware file always follows this naming format: &lt;keyboard_name&gt;_&lt;keymap_name&gt;.{bin,hex} For example, the plank\/rev5 with a default keymap will have this filename: planck_rev5_default.hex Once you have located your firmware file drag it into the &quot;Local file&quot; box in QMK Toolbox, or click &quot;Open&quot; and navigate to where your firmware file is stored. Put Your Keyboard Into DFU (Bootloader) Mode In order to flash your custom firmware you have to put your keyboard into a special flashing mode. While it is in this mode you will not be able to type or otherwise use your keyboard. It is very important that you do not unplug your keyboard or otherwise interrupt the flashing process while the firmware is being written. Different keyboards have different ways to enter this special mode. If your PCB currently runs QMK or TMK and you have not been given specific instructions try the following, in order: Hold down both shift keys and press Pause Hold down both shift keys and press B Unplug your keyboard, hold down the Spacebar and B at the same time, plug in your keyboard and wait a second before releasing the keys Press the physical RESET button on the bottom of the PCB Locate header pins on the PCB labeled BOOT0 or RESET, short those together while plugging your PCB in When you are successful you will see a message similar to this in QMK Toolbox: *** Clueboard - Clueboard 66% HotSwap disconnected -- 0xC1ED:0x2390 *** DFU device connected Flash Your Keyboard Click the Flash button in QMK Toolbox. You will see output similar to the following: *** Clueboard - Clueboard 66% HotSwap disconnected -- 0xC1ED:0x2390 *** DFU device connected *** Attempting to flash, please don't remove device &gt;&gt;&gt; dfu-programmer atmega32u4 erase --force Erasing flash... Success Checking memory from 0x0 to 0x6FFF... Empty. &gt;&gt;&gt; dfu-programmer atmega32u4 flash \/Users\/skully\/qmk_firmware\/clueboard_66_hotswap_gen1_skully.hex Checking memory from 0x0 to 0x55FF... Empty. 0% 100% Programming 0x5600 bytes... [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;] Success 0% 100% Reading 0x7000 bytes... [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;] Success Validating... Success 0x5600 bytes written into 0x7000 bytes memory (76.79%). &gt;&gt;&gt; dfu-programmer atmega32u4 reset *** DFU device disconnected *** Clueboard - Clueboard 66% HotSwap connected -- 0xC1ED:0x2390 Flash your Keyboard from the Command Line First thing you'll need to know is which bootloader that your keyboard uses. There are four main bootloaders that are used, usually. Pro-Micro and clones use CATERINA, and Teensy's use Halfkay, OLKB boards use QMK-DFU, and other atmega32u4 chips use DFU. You can find more information about the bootloaders in the Flashing Instructions and Bootloader Information page. If you know what bootloader that you're using, then when compiling the firmware, you can actually add some extra text to the make command to automate the flashing process. DFU For the DFU bootloader, when you're ready to compile and flash your firmware, open up your terminal window and run the built command: make &lt;my_keyboard&gt;:&lt;my_keymap&gt;:dfu For example, if your keymap is named &quot;xyverz&quot; and you're building a keymap for a rev5 planck, you'll use this command: make planck\/rev5:xyverz:dfu Once it finishes compiling, it should output the following: Linking: .build\/planck_rev5_xyverz.elf [OK] Creating load file for flashing: .build\/planck_rev5_xyverz.hex [OK] Copying planck_rev5_xyverz.hex to qmk_firmware folder [OK] Checking file size of planck_rev5_xyverz.hex * File size is fine - 18574\/28672 After it gets to this point, the build script will look for the DFU bootloader every 5 seconds. It will repeat the following until the device is found or you cancel it. dfu-programmer: no device present. Error: Bootloader not found. Trying again in 5s. Once it does this, you'll want to reset the controller. It should then show output similiar to this: *** Attempting to flash, please don't remove device &gt;&gt;&gt; dfu-programmer atmega32u4 erase --force Erasing flash... Success Checking memory from 0x0 to 0x6FFF... Empty. &gt;&gt;&gt; dfu-programmer atmega32u4 flash \/Users\/skully\/qmk_firmware\/clueboard_66_hotswap_gen1_skully.hex Checking memory from 0x0 to 0x55FF... Empty. 0% 100% Programming 0x5600 bytes... [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;] Success 0% 100% Reading 0x7000 bytes... [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;] Success Validating... Success 0x5600 bytes written into 0x7000 bytes memory (76.79%). &gt;&gt;&gt; dfu-programmer atmega32u4 reset If you have any issues with this, you may need to this: sudo make &lt;my_keyboard&gt;:&lt;my_keymap&gt;:dfu Caterina For Arduino boards and their close (such as the SparkFun ProMicro), when you're ready to compile and flash your firmware, open up your terminal window and run the built command: make &lt;my_keyboard&gt;:&lt;my_keymap&gt;:avrdude For example, if your keymap is named &quot;xyverz&quot; and you're building a keymap for a rev2 Lets Split, you'll use this command: make lets_split\/rev2:xyverz:avrdude Once the firmware finishes compiling, it will output something like this: Linking: .build\/lets_split_rev2_xyverz.elf [OK] Creating load file for flashing: .build\/lets_split_rev2_xyverz.hex [OK] Checking file size of lets_split_rev2_xyverz.hex [OK] * File size is fine - 27938\/28672 Detecting USB port, reset your controller now.............. At this point, reset the board and then the script will detect the bootloader and then flash the board. The output should look something like this: Detected controller on USB port at \/dev\/ttyS15 Connecting to programmer: . Found programmer: Id = &quot;CATERIN&quot;; type = S Software Version = 1.0; No Hardware Version given. Programmer supports auto addr increment. Programmer supports buffered memory access with buffersize=128 bytes. Programmer supports the following devices: Device code: 0x44 avrdude.exe: AVR device initialized and ready to accept instructions Reading | ################################################## | 100% 0.00s avrdude.exe: Device signature = 0x1e9587 (probably m32u4) avrdude.exe: NOTE: &quot;flash&quot; memory has been specified, an erase cycle will be performed To disable this feature, specify the -D option. avrdude.exe: erasing chip avrdude.exe: reading input file &quot;.\/.build\/lets_split_rev2_xyverz.hex&quot; avrdude.exe: input file .\/.build\/lets_split_rev2_xyverz.hex auto detected as Intel Hex avrdude.exe: writing flash (27938 bytes): Writing | ################################################## | 100% 2.40s avrdude.exe: 27938 bytes of flash written avrdude.exe: verifying flash memory against .\/.build\/lets_split_rev2_xyverz.hex: avrdude.exe: load data flash data from input file .\/.build\/lets_split_rev2_xyverz.hex: avrdude.exe: input file .\/.build\/lets_split_rev2_xyverz.hex auto detected as Intel Hex avrdude.exe: input file .\/.build\/lets_split_rev2_xyverz.hex contains 27938 bytes avrdude.exe: reading on-chip flash data: Reading | ################################################## | 100% 0.43s avrdude.exe: verifying ... avrdude.exe: 27938 bytes of flash verified avrdude.exe: safemode: Fuses OK (E:CB, H:D8, L:FF) avrdude.exe done. Thank you. If you have any issues with this, you may need to this: sudo make &lt;my_keyboard&gt;:&lt;my_keymap&gt;:avrdude HalfKay For the PJRC devices (Teensy's), when you're ready to compile and flash your firmware, open up your terminal window and run the built command: make &lt;my_keyboard&gt;:&lt;my_keymap&gt;:teensy For example, if your keymap is named &quot;xyverz&quot; and you're building a keymap for an Ergodox or Ergodox EZ, you'll use this command: make erdogox_ez:xyverz:teensy Once the firmware finishes compiling, it will output something like this: Linking: .build\/ergodox_ez_xyverz.elf [OK] Creating load file for flashing: .build\/ergodox_ez_xyverz.hex [OK] Checking file size of ergodox_ez_xyverz.hex [OK] * File size is fine - 25584\/32256 Teensy Loader, Command Line, Version 2.1 Read &quot;.\/.build\/ergodox_ez_xyverz.hex&quot;: 25584 bytes, 79.3% usage Waiting for Teensy device... (hint: press the reset button) At this point, reset your board. Once you've done that, you'll see output like this: Found HalfKay Bootloader Read &quot;.\/.build\/ergodox_ez_drashna.hex&quot;: 28532 bytes, 88.5% usage Programming............................................................................................................................................................................ ................................................... Booting Test It Out! Congrats! Your custom firmware has been programmed to your keyboard! Give it a try and make sure everything works the way you want it to. We've written Testing and Debugging to round out this Newbie Guide, so head over there to learn about how to troubleshoot your custom functionality.","tags":"","url":"Complete_Newbs_Guide\/Flashing_Firmware.html"},{"title":"Testing and Debugging","text":"Testing and Debugging Testing Debugging With QMK Toolbox Sending Your Own Debug Messages Testing and Debugging Once you've flashed your keyboard with a custom firmware you're ready to test it out. With a little bit of luck everything will work perfectly, but if not this document will help you figure out what's wrong. Testing Testing your keyboard is usually pretty straightforward. Press every single key and make sure it sends the keys you expect. There are even programs that will help you make sure that no key is missed. Note: These programs are not provided by or endorsed by QMK. Switch Hitter (Windows Only) Keyboard Viewer (Mac Only) Keyboard Tester (Web Based) Keyboard Checker (Web Based) Debugging With QMK Toolbox QMK Toolbox will show messages from your keyboard if you have CONSOLE_ENABLE = yes in your rules.mk. By default the output is very limited, but you can turn on debug mode to increase the amount of debug output. Use the DEBUG keycode in your keymap, or use the Command feature to enable debug mode. Sending Your Own Debug Messages Sometimes it's useful to print debug messages from within your custom code. Doing so is pretty simple. Start by including print.h at the top of your file: #include &lt;print.h&gt; After that you can use a few different print functions: print(&quot;string&quot;): Print a simple string. sprintf(&quot;%s string&quot;, var): Print a formatted string dprint(&quot;string&quot;) Print a simple string, but only when debug mode is enabled dprintf(&quot;%s string&quot;, var): Print a formatted string, but only when debug mode is enabled","tags":"","url":"Complete_Newbs_Guide\/Testing_and_Debugging.html"},{"title":"FAQ","text":"Frequently Asked Questions Frequently Asked Questions General Building or Compiling QMK Debugging and Troubleshooting QMK Keymap","tags":"","url":"FAQ\/index.html"},{"title":"General FAQ","text":"Frequently Asked Questions What is QMK? Why the Name Quantum? What Differences Are There Between QMK and TMK? Frequently Asked Questions What is QMK? QMK, short for Quantum Mechanical Keyboard, is a group of people building tools for custom keyboards. We started with the QMK firmware, a heavily modified fork of TMK. Why the Name Quantum? What Differences Are There Between QMK and TMK? TMK was originally designed and implemented by Jun Wako. QMK started as Jack Humbert's fork of TMK for the Planck. After a while Jack's fork had diverged quite a bit from TMK, and in 2015 Jack decided to rename his fork to QMK. From a technical standpoint QMK builds upon TMK by adding several new features. Most notably QMK has expanded the number of available keycodes and uses these to implement advanced features like S(), LCTL(), and MO(). You can see a complete list of these keycodes in Keycodes. From a project and community management standpoint TMK maintains all the officially supported keyboards by himself, with a bit of community support. Separate community maintained forks exist or can be created for other keyboards. Only a few keymaps are provided by default, so users typically don't share keymaps with each other. QMK encourages sharing of both keyboards and keymaps through a centrally managed repository, accepting all pull requests that follow the quality standards. These are mostly community maintained, but the QMK team also helps when necessary. Both approaches have their merits and their drawbacks, and code flows freely between TMK and QMK when it makes sense.","tags":"","url":"FAQ\/General_FAQ.html"},{"title":"Build Compile QMK","text":"Frequently Asked Build Questions Can't Program on Linux Linux udev Rules WINAVR is Obsolete USB VID and PID Cortex: cstddef: No such file or directory clock_prescale_set and clock_div_1 Not Available BOOTLOADER_SIZE for AVR avr-gcc: internal compiler error: Abort trap: 6 (program cc1) on MacOS Frequently Asked Build Questions This page covers questions about building QMK. If you haven't yet done so, you should read the Build Environment Setup and Make Instructions guides. Can't Program on Linux You will need proper permissions to operate a device. For Linux users, see the instructions regarding udev rules, below. If you have issues with udev, a work-around is to use the sudo command. If you are not familiar with this command, check its manual with man sudo or see this webpage. An example of using sudo, when your controller is ATMega32u4: $ sudo dfu-programmer atmega32u4 erase --force $ sudo dfu-programmer atmega32u4 flash your.hex $ sudo dfu-programmer atmega32u4 reset or just: $ sudo make &lt;keyboard&gt;:&lt;keymap&gt;:dfu Note that running make with sudo is generally not a good idea, and you should use one of the former methods, if possible. Linux udev Rules On Linux, you'll need proper privileges to access the MCU. You can either use sudo when flashing firmware, or place these files in \/etc\/udev\/rules.d\/. \/etc\/udev\/rules.d\/50-atmel-dfu.rules: # Atmel ATMega32U4 SUBSYSTEMS==&quot;usb&quot;, ATTRS{idVendor}==&quot;03eb&quot;, ATTRS{idProduct}==&quot;2ff4&quot;, MODE:=&quot;0666&quot; # Atmel USBKEY AT90USB1287 SUBSYSTEMS==&quot;usb&quot;, ATTRS{idVendor}==&quot;03eb&quot;, ATTRS{idProduct}==&quot;2ffb&quot;, MODE:=&quot;0666&quot; # Atmel ATMega32U2 SUBSYSTEMS==&quot;usb&quot;, ATTRS{idVendor}==&quot;03eb&quot;, ATTRS{idProduct}==&quot;2ff0&quot;, MODE:=&quot;0666&quot; \/etc\/udev\/rules.d\/52-tmk-keyboard.rules: # tmk keyboard products https:\/\/github.com\/tmk\/tmk_keyboard SUBSYSTEMS==&quot;usb&quot;, ATTRS{idVendor}==&quot;feed&quot;, MODE:=&quot;0666&quot; WINAVR is Obsolete It is no longer recommended and may cause some problem. See TMK Issue #99. USB VID and PID You can use any ID you want with editing config.h. Using any presumably unused ID will be no problem in fact except for very low chance of collision with other product. Most boards in QMK use 0xFEED as the vendor ID. You should look through other keyboards to make sure you pick a unique Product ID. Also see this. https:\/\/github.com\/tmk\/tmk_keyboard\/issues\/150 You can buy a really unique VID:PID here. I don't think you need this for personal use. http:\/\/www.obdev.at\/products\/vusb\/license.html http:\/\/www.mcselec.com\/index.php?page=shop.product_details&amp;flypage=shop.flypage&amp;product_id=92&amp;option=com_phpshop&amp;Itemid=1 Cortex: cstddef: No such file or directory GCC 4.8 of Ubuntu 14.04 had this problem and had to update to 4.9 with this PPA. https:\/\/launchpad.net\/~terry.guo\/+archive\/ubuntu\/gcc-arm-embedded https:\/\/github.com\/tmk\/tmk_keyboard\/issues\/212 https:\/\/github.com\/tmk\/tmk_keyboard\/wiki\/mbed-cortex-porting#compile-error-cstddef https:\/\/developer.mbed.org\/forum\/mbed\/topic\/5205\/ clock_prescale_set and clock_div_1 Not Available Your toolchain is too old to support the MCU. For example WinAVR 20100110 doesn't support ATMega32u2. Compiling C: ..\/..\/tmk_core\/protocol\/lufa\/lufa.c avr-gcc -c -mmcu=atmega32u2 -gdwarf-2 -DF_CPU=16000000UL -DINTERRUPT_CONTROL_ENDPOINT -DBOOTLOADER_SIZE=4096 -DF_USB=16000000UL -DARCH=ARCH_AVR8 -DUSB_DEVICE_ONLY -DUSE_FLASH_DESCRIPTORS -DUSE_STATIC_OPTIONS=&quot;(USB_DEVICE_OPT_FULLSPEED | USB_OPT_REG_ENABLED | USB_OPT_AUTO_PLL)&quot; -DFIXED_CONTROL_ENDPOINT_SIZE=8 -DFIXED_NUM_CONFIGURATIONS=1 -DPROTOCOL_LUFA -DEXTRAKEY_ENABLE -DCONSOLE_ENABLE -DCOMMAND_ENABLE -DVERSION=unknown -Os -funsigned-char -funsigned-bitfields -ffunction-sections -fdata-sections -fno-inline-small-functions -fpack-struct -fshort-enums -fno-strict-aliasing -Wall -Wstrict-prototypes -Wa,-adhlns=obj_alps64\/protocol\/lufa\/lufa.lst -I. -I..\/..\/tmk_core -I..\/..\/tmk_core\/protocol\/lufa -I..\/..\/tmk_core\/protocol\/lufa\/LUFA-git -I..\/..\/tmk_core\/common -std=gnu99 -include config.h -MMD -MP -MF .dep\/obj_alps64_protocol_lufa_lufa.o.d ..\/..\/tmk_core\/protocol\/lufa\/lufa.c -o obj_alps64\/protocol\/lufa\/lufa.o ..\/..\/tmk_core\/protocol\/lufa\/lufa.c: In function 'setup_mcu': ..\/..\/tmk_core\/protocol\/lufa\/lufa.c:575: warning: implicit declaration of function 'clock_prescale_set' ..\/..\/tmk_core\/protocol\/lufa\/lufa.c:575: error: 'clock_div_1' undeclared (first use in this function) ..\/..\/tmk_core\/protocol\/lufa\/lufa.c:575: error: (Each undeclared identifier is reported only once ..\/..\/tmk_core\/protocol\/lufa\/lufa.c:575: error: for each function it appears in.) make: *** [obj_alps64\/protocol\/lufa\/lufa.o] Error 1 BOOTLOADER_SIZE for AVR Note that Teensy2.0++ bootloader size is 2048byte. Some Makefiles may have wrong comment. # Boot Section Size in *bytes* # Teensy halfKay 512 # Teensy++ halfKay 2048 # Atmel DFU loader 4096 (TMK Alt Controller) # LUFA bootloader 4096 # USBaspLoader 2048 OPT_DEFS += -DBOOTLOADER_SIZE=2048 avr-gcc: internal compiler error: Abort trap: 6 (program cc1) on MacOS This is an issue with updating on brew, causing symlinks that avr-gcc depend on getting mangled. The solution is to remove and reinstall all affected modules. brew rm avr-gcc brew rm dfu-programmer brew rm gcc-arm-none-eabi brew rm avrdude brew install avr-gcc brew install dfu-programmer brew install gcc-arm-none-eabi brew install avrdude","tags":"","url":"FAQ\/Build_Compile_QMK.html"},{"title":"Debugging and Troubleshooting","text":"Debugging FAQ Debug Console hid_listen Can't Recognize Device Can't Get Message on Console Linux or UNIX Like System Requires Super User Privilege Miscellaneous Safety Considerations NKRO Doesn't work TrackPoint Needs Reset Circuit (PS\/2 Mouse Support) Can't Read Column of Matrix Beyond 16 Bootloader Jump Doesn't Work Special Extra Key Doesn't Work (System, Audio Control Keys) Wakeup from Sleep Doesn't Work Using Arduino? Using PF4-7 Pins of USB AVR? Adding LED Indicators of Lock Keys Program Arduino Micro\/Leonardo USB 3 Compatibility Mac Compatibility OS X 10.11 and Hub Problem on BIOS (UEFI)\/Resume (Sleep &amp; Wake)\/Power Cycles FLIP Doesn't Work AtLibUsbDfu.dll Not Found Debugging FAQ This page details various common questions people have about troubleshooting their keyboards. Debug Console hid_listen Can't Recognize Device When debug console of your device is not ready you will see like this: Waiting for device:......... once the device is plugged in then hid_listen finds it you will get this message: Waiting for new device:......................... Listening: If you can't get this 'Listening:' message try building with CONSOLE_ENABLE=yes in [Makefile] You may need privilege to access the device on OS like Linux. try sudo hid_listen Can't Get Message on Console Check: hid_listen finds your device. See above. Enable debug with pressing Magic+d. See Magic Commands. set debug_enable=true usually in matrix_init() in matrix.c. try using 'print' function instead of debug print. See common\/print.h. disconnect other devices with console function. See Issue #97. Linux or UNIX Like System Requires Super User Privilege Just use 'sudo' to execute hid_listen with privilege. $ sudo hid_listen Or add an udev rule for TMK devices with placing a file in rules directory. The directory may vary on each system. File: \/etc\/udev\/rules.d\/52-tmk-keyboard.rules(in case of Ubuntu) # tmk keyboard products https:\/\/github.com\/tmk\/tmk_keyboard SUBSYSTEMS==&quot;usb&quot;, ATTRS{idVendor}==&quot;feed&quot;, MODE:=&quot;0666&quot; Miscellaneous Safety Considerations You probably don't want to &quot;brick&quot; your keyboard, making it impossible to rewrite firmware onto it. Here are some of the parameters to show what things are (and likely aren't) too risky. If your keyboard map does not include RESET, then, to get into DFU mode, you will need to press the reset button on the PCB, which requires unscrewing the bottom. Messing with tmk_core \/ common files might make the keyboard inoperable Too large a .hex file is trouble; make dfu will erase the block, test the size (oops, wrong order!), which errors out, failing to flash the keyboard, leaving it in DFU mode. To this end, note that the maximum .hex file size on Planck is 7000h (28672 decimal) Linking: .build\/planck_rev4_cbbrowne.elf [OK] Creating load file for Flash: .build\/planck_rev4_cbbrowne.hex [OK] Size after: text data bss dec hex filename 0 22396 0 22396 577c planck_rev4_cbbrowne.hex The above file is of size 22396\/577ch, which is less than 28672\/7000h As long as you have a suitable alternative .hex file around, you can retry, loading that one Some of the options you might specify in your keyboard's Makefile consume extra memory; watch out for BOOTMAGIC_ENABLE, MOUSEKEY_ENABLE, EXTRAKEY_ENABLE, CONSOLE_ENABLE, API_SYSEX_ENABLE DFU tools do \/not\/ allow you to write into the bootloader (unless you throw in extra fruit salad of options), so there is little risk there. EEPROM has around a 100000 write cycle. You shouldn't rewrite the firmware repeatedly and continually; that'll burn the EEPROM eventually. NKRO Doesn't work First you have to compile firmware with this build option NKRO_ENABLE in Makefile. Try Magic N command(LShift+RShift+N by default) when NKRO still doesn't work. You can use this command to toggle between NKRO and 6KRO mode temporarily. In some situations NKRO doesn't work you need to switch to 6KRO mode, in particular when you are in BIOS. If your firmware built with BOOTMAGIC_ENABLE you need to turn its switch on by BootMagic N command(Space+N by default). This setting is stored in EEPROM and kept over power cycles. https:\/\/github.com\/tmk\/tmk_keyboard#boot-magic-configuration---virtual-dip-switch TrackPoint Needs Reset Circuit (PS\/2 Mouse Support) Without reset circuit you will have inconsistent result due to improper initialize of the hardware. See circuit schematic of TPM754. http:\/\/geekhack.org\/index.php?topic=50176.msg1127447#msg1127447 http:\/\/www.mikrocontroller.net\/attachment\/52583\/tpm754.pdf Can't Read Column of Matrix Beyond 16 Use 1UL&lt;&lt;16 instead of 1&lt;&lt;16 in read_cols() in [matrix.h] when your columns goes beyond 16. In C 1 means one of [int] type which is [16 bit] in case of AVR so you can't shift left more than 15. You will get unexpected zero when you say 1&lt;&lt;16. You have to use [unsigned long] type with 1UL. http:\/\/deskthority.net\/workshop-f7\/rebuilding-and-redesigning-a-classic-thinkpad-keyboard-t6181-60.html#p146279 Bootloader Jump Doesn't Work Properly configure bootloader size in Makefile. With wrong section size bootloader won't probably start with Magic command and Boot Magic. # Size of Bootloaders in bytes: # Atmel DFU loader(ATmega32U4) 4096 # Atmel DFU loader(AT90USB128) 8192 # LUFA bootloader(ATmega32U4) 4096 # Arduino Caterina(ATmega32U4) 4096 # USBaspLoader(ATmega***) 2048 # Teensy halfKay(ATmega32U4) 512 # Teensy++ halfKay(AT90USB128) 2048 OPT_DEFS += -DBOOTLOADER_SIZE=4096 AVR Boot section size are defined by setting BOOTSZ fuse in fact. Consult with your MCU datasheet. Note that Word(2 bytes) size and address are used in datasheet while TMK uses Byte. AVR Boot section is located at end of Flash memory like the followings. byte Atmel\/LUFA(ATMega32u4) byte Atmel(AT90SUB1286) 0x0000 +---------------+ 0x00000 +---------------+ | | | | | | | | | Application | | Application | | | | | = = = = | | 32KB-4KB | | 128KB-8KB 0x6000 +---------------+ 0x1E000 +---------------+ | Bootloader | 4KB | Bootloader | 8KB 0x7FFF +---------------+ 0x1FFFF +---------------+ byte Teensy(ATMega32u4) byte Teensy++(AT90SUB1286) 0x0000 +---------------+ 0x00000 +---------------+ | | | | | | | | | Application | | Application | | | | | = = = = | | 32KB-512B | | 128KB-2KB 0x7E00 +---------------+ 0x1FC00 +---------------+ | Bootloader | 512B | Bootloader | 2KB 0x7FFF +---------------+ 0x1FFFF +---------------+ And see this discussion for further reference. https:\/\/github.com\/tmk\/tmk_keyboard\/issues\/179 If you are using a TeensyUSB, there is a known bug in which the hardware reset button prevents the RESET key from working. Unplugging the keyboard and plugging it back in should resolve the problem. Special Extra Key Doesn't Work (System, Audio Control Keys) You need to define EXTRAKEY_ENABLE in rules.mk to use them in QMK. EXTRAKEY_ENABLE = yes # Audio control and System control Wakeup from Sleep Doesn't Work In Windows check Allow this device to wake the computer setting in Power Management property tab of Device Manager. Also check BIOS setting. Pressing any key during sleep should wake host. Using Arduino? Note that Arduino pin naming is different from actual chip. For example, Arduino pin D0 is not PD0. Check circuit with its schematics yourself. http:\/\/arduino.cc\/en\/uploads\/Main\/arduino-leonardo-schematic_3b.pdf http:\/\/arduino.cc\/en\/uploads\/Main\/arduino-micro-schematic.pdf Arduino Leonardo and micro have ATMega32U4 and can be used for TMK, though Arduino bootloader may be a problem. Using PF4-7 Pins of USB AVR? You need to set JTD bit of MCUCR yourself to use PF4-7 as GPIO. Those pins are configured to serve JTAG function by default. MCUs like ATMegaU or AT90USB* are affected with this. If you are using Teensy this isn't needed. Teensy is shipped with JTAGEN fuse bit unprogrammed to disable the function. See this code. \/\/ JTAG disable for PORT F. write JTD bit twice within four cycles. MCUCR |= (1&lt;&lt;JTD); MCUCR |= (1&lt;&lt;JTD); https:\/\/github.com\/tmk\/tmk_keyboard\/blob\/master\/keyboard\/hbkb\/matrix.c#L67 And read 26.5.1 MCU Control Register \u2013 MCUCR of ATMega32U4 datasheet. Adding LED Indicators of Lock Keys You need your own LED indicators for CapsLock, ScrollLock and NumLock? See this post. http:\/\/deskthority.net\/workshop-f7\/tmk-keyboard-firmware-collection-t4478-120.html#p191560 Program Arduino Micro\/Leonardo Push reset button and then run command like this within 8 seconds. avrdude -patmega32u4 -cavr109 -b57600 -Uflash:w:adb_usb.hex -P\/dev\/ttyACM0 Device name will vary depending on your system. http:\/\/arduino.cc\/en\/Main\/ArduinoBoardMicro https:\/\/geekhack.org\/index.php?topic=14290.msg1563867#msg1563867 USB 3 Compatibility I heard some people have a problem with USB 3 port, try USB 2 port. Mac Compatibility OS X 10.11 and Hub https:\/\/geekhack.org\/index.php?topic=14290.msg1884034#msg1884034 Problem on BIOS (UEFI)\/Resume (Sleep &amp; Wake)\/Power Cycles Some people reported their keyboard stops working on BIOS and\/or after resume(power cycles). As of now root of its cause is not clear but some build options seem to be related. In Makefile try to disable those options like CONSOLE_ENABLE, NKRO_ENABLE, SLEEP_LED_ENABLE and\/or others. https:\/\/github.com\/tmk\/tmk_keyboard\/issues\/266 https:\/\/geekhack.org\/index.php?topic=41989.msg1967778#msg1967778 FLIP Doesn't Work AtLibUsbDfu.dll Not Found Remove current driver and reinstall one FLIP provides from DeviceManager. http:\/\/imgur.com\/a\/bnwzy","tags":"","url":"FAQ\/Debugging_and_Troubleshooting.html"},{"title":"Keymaps","text":"Keymap FAQ What Keycodes Can I Use? What Are the Default Keycodes? Some Of My Keys Are Swapped Or Not Working The Menu Key Isn't Working KC_SYSREQ Isn't Working Power Key Doesn't Work One Shot Modifier Modifier\/Layer Stuck Mechanical Lock Switch Support Input Special Characters Other Than ASCII like C\u00e9dille '\u00c7' Apple\/Mac Keyboard Fn Media Control Keys in Mac OSX KC_MNXT and KC_MPRV Does Not Work on Mac Keys Supported in Mac OSX? JIS Keys in Mac OSX RN-42 Bluetooth Doesn't Work with Karabiner Esc and ` on a Single Key Arrow on Right Modifier Keys with Dual-Role Eject on Mac OSX What's weak_mods and real_mods in action_util.c Timer Functionality Keymap FAQ This page covers questions people often have about keymaps. If you haven't you should read Keymap Overview first. What Keycodes Can I Use? See Keycodes for an index of keycodes available to you. These link to more extensive documentation when available. Keycodes are actually defined in common\/keycode.h. What Are the Default Keycodes? There are 3 standard keyboard layouts in use around the world- ANSI, ISO, and JIS. North America primarily uses ANSI, Europe and Africa primarily use ISO, and Japan uses JIS. Regions not mentioned typically use either ANSI or ISO. The keycodes corresponding to these layouts are shown here: Some Of My Keys Are Swapped Or Not Working QMK has two features, Bootmagic and Command, which allow you to change the behavior of your keyboard on the fly. This includes, but is not limited to, swapping Ctrl\/Caps, disabling Gui, swapping Alt\/Gui, swapping Backspace\/Backslash, disabling all keys, and other behavioral modifications. As a quick fix try holding down Space+Backspace while you plug in your keyboard. This will reset the stored settings on your keyboard, returning those keys to normal operation. If that doesn't work look here: Bootmagic Command The Menu Key Isn't Working The key found on most modern keyboards that is located between KC_RGUI and KC_RCTL is actually called KC_APP. This is because when that key was invented there was already a key named MENU in the relevant standards, so MS chose to call that the APP key. KC_SYSREQ Isn't Working Use keycode for Print Screen(KC_PSCREEN or KC_PSCR) instead of KC_SYSREQ. Key combination of 'Alt + Print Screen' is recognized as 'System request'. See issue #168 and http:\/\/en.wikipedia.org\/wiki\/Magic_SysRq_key http:\/\/en.wikipedia.org\/wiki\/System_request Power Key Doesn't Work Use KC_PWR instead of KC_POWER or vice versa. KC_PWR works with Windows and Linux, not with OSX. KC_POWER works with OSX and Linux, not with Windows. More info: http:\/\/geekhack.org\/index.php?topic=14290.msg1327264#msg1327264 One Shot Modifier Solves my personal 'the' problem. I often got 'the' or 'THe' wrongly instead of 'The'. One Shot Shift mitigates this for me. https:\/\/github.com\/tmk\/tmk_keyboard\/issues\/67 Modifier\/Layer Stuck Modifier keys or layers can be stuck unless layer switching is configured properly. For Modifier keys and layer actions you have to place KC_TRANS on same position of destination layer to unregister the modifier key or return to previous layer on release event. https:\/\/github.com\/tmk\/tmk_core\/blob\/master\/doc\/Reference\/Keymap_Overview.md#31-momentary-switching http:\/\/geekhack.org\/index.php?topic=57008.msg1492604#msg1492604 https:\/\/github.com\/tmk\/tmk_keyboard\/issues\/248 Mechanical Lock Switch Support This feature is for mechanical lock switch like this Alps one. You can enable it by adding this to your config.h: #define LOCKING_SUPPORT_ENABLE #define LOCKING_RESYNC_ENABLE After enabling this feature use keycodes KC_LCAP, KC_LNUM and KC_LSCR in your keymap instead. Old vintage mechanical keyboards occasionally have lock switches but modern ones don't have. You don't need this feature in most case and just use keycodes KC_CAPS, KC_NLCK and KC_SLCK. Input Special Characters Other Than ASCII like C\u00e9dille '\u00c7' NO UNIVERSAL METHOD TO INPUT THOSE WORKS OVER ALL SYSTEMS. You have to define MACRO in way specific to your OS or layout. See this post for example MACRO code. http:\/\/deskthority.net\/workshop-f7\/tmk-keyboard-firmware-collection-t4478-120.html#p195620 On Windows you can use AltGr key or Alt code. http:\/\/en.wikipedia.org\/wiki\/AltGr_key http:\/\/en.wikipedia.org\/wiki\/Alt_code On Mac OS defines Option key combinations. http:\/\/en.wikipedia.org\/wiki\/Option_key#Alternative_keyboard_input On Xorg you can use compose key, instead. http:\/\/en.wikipedia.org\/wiki\/Compose_key And see this for Unicode input. http:\/\/en.wikipedia.org\/wiki\/Unicode_input Apple\/Mac Keyboard Fn Not supported. Apple\/Mac keyboard sends keycode for Fn unlike most of other keyboards. I think you can send Apple Fn key using Apple venter specific Page 0xff01 and usage 0x0003. But you have to change HID Report Descriptor for this, of course. https:\/\/opensource.apple.com\/source\/IOHIDFamily\/IOHIDFamily-606.1.7\/IOHIDFamily\/AppleHIDUsageTables.h Media Control Keys in Mac OSX KC_MNXT and KC_MPRV Does Not Work on Mac Use KC_MFFD(KC_MEDIA_FAST_FORWARD) and KC_MRWD(KC_MEDIA_REWIND) instead of KC_MNXT and KC_MPRV. See https:\/\/github.com\/tmk\/tmk_keyboard\/issues\/195 Keys Supported in Mac OSX? You can know which keycodes are supported in OSX from this source code. usb_2_adb_keymap array maps Keyboard\/Keypad Page usages to ADB scancodes(OSX internal keycodes). https:\/\/opensource.apple.com\/source\/IOHIDFamily\/IOHIDFamily-606.1.7\/IOHIDFamily\/Cosmo_USB2ADB.c And IOHIDConsumer::dispatchConsumerEvent handles Consumer page usages. https:\/\/opensource.apple.com\/source\/IOHIDFamily\/IOHIDFamily-606.1.7\/IOHIDFamily\/IOHIDConsumer.cpp JIS Keys in Mac OSX Japanese JIS keyboard specific keys like \u7121\u5909\u63db(Muhenkan), \u5909\u63db(Henkan), \u3072\u3089\u304c\u306a(hiragana) are not recognized on OSX. You can use Seil to enable those keys, try following options. Enable NFER Key on PC keyboard Enable XFER Key on PC keyboard Enable KATAKANA Key on PC keyboard https:\/\/pqrs.org\/osx\/karabiner\/seil.html RN-42 Bluetooth Doesn't Work with Karabiner Karabiner - Keymapping tool on Mac OSX - ignores inputs from RN-42 module by default. You have to enable this option to make Karabiner working with your keyboard. https:\/\/github.com\/tekezo\/Karabiner\/issues\/403#issuecomment-102559237 See these for the detail of this problem. https:\/\/github.com\/tmk\/tmk_keyboard\/issues\/213 https:\/\/github.com\/tekezo\/Karabiner\/issues\/403 Esc and ` on a Single Key See the Grave Escape feature. Arrow on Right Modifier Keys with Dual-Role This turns right modifier keys into arrow keys when the keys are tapped while still modifiers when the keys are hold. In TMK the dual-role function is dubbed TAP. #include &quot;keymap_common.h&quot; \/* Arrow keys on right modifier keys with TMK dual role feature * * https:\/\/github.com\/tmk\/tmk_core\/blob\/master\/doc\/07_Reference\/Keymap_Overview.md#213-modifier-with-tap-keydual-role * https:\/\/en.wikipedia.org\/wiki\/Modifier_key#Dual-role_keys *\/ const uint8_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = { \/* 0: qwerty *\/ [0] = KEYMAP( \\ ESC, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, MINS,EQL, NUHS,BSPC, \\ TAB, Q, W, E, R, T, Y, U, I, O, P, LBRC,RBRC,BSLS, \\ LCTL,A, S, D, F, G, H, J, K, L, SCLN,QUOT,ENT, \\ LSFT,NUBS,Z, X, C, V, B, N, M, COMM,DOT, SLSH,FN0, ESC, \\ FN4, LGUI,LALT, SPC, APP, FN2, FN1, FN3), [1] = KEYMAP( \\ GRV, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, TRNS,TRNS, \\ TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,\\ TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS, \\ TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,TRNS,FN5, TRNS, \\ TRNS,TRNS,TRNS, TRNS, TRNS,FN7, FN6, FN8), }; const uint16_t PROGMEM fn_actions[] = { [0] = ACTION_MODS_TAP_KEY(MOD_RSFT, KC_UP), [1] = ACTION_MODS_TAP_KEY(MOD_RGUI, KC_DOWN), [2] = ACTION_MODS_TAP_KEY(MOD_RALT, KC_LEFT), [3] = ACTION_MODS_TAP_KEY(MOD_RCTL, KC_RIGHT), [4] = ACTION_LAYER_MOMENTARY(1), [5] = ACTION_MODS_TAP_KEY(MOD_RSFT, KC_PGUP), [6] = ACTION_MODS_TAP_KEY(MOD_RGUI, KC_PGDN), [7] = ACTION_MODS_TAP_KEY(MOD_RALT, KC_HOME), [8] = ACTION_MODS_TAP_KEY(MOD_RCTL, KC_END), }; Dual-role key: https:\/\/en.wikipedia.org\/wiki\/Modifier_key#Dual-role_keys Eject on Mac OSX KC_EJCT keycode works on OSX. https:\/\/github.com\/tmk\/tmk_keyboard\/issues\/250 It seems Windows 10 ignores the code and Linux\/Xorg recognizes but has no mapping by default. Not sure what keycode Eject is on genuine Apple keyboard actually. HHKB uses F20 for Eject key(Fn+f) on Mac mode but this is not same as Apple Eject keycode probably. What's weak_mods and real_mods in action_util.c TO BE IMPROVED real_mods is intended to retains state of real\/physical modifier key state, while weak_mods retains state of virtual or temporary modifiers which should not affect state real modifier key. Let's say you hold down physical left shift key and type ACTION_MODS_KEY(LSHIFT, KC_A), with weak_mods, (1) hold down left shift: real_mods |= MOD_BIT(LSHIFT) (2) press ACTION_MODS_KEY(LSHIFT, KC_A): weak_mods |= MOD_BIT(LSHIFT) (3) release ACTION_MODS_KEY(LSHIFT, KC_A): weak_mods &amp;= ~MOD_BIT(LSHIFT) real_mods still keeps modifier state. without weak mods, (1) hold down left shift: real_mods |= MOD_BIT(LSHIFT) (2) press ACTION_MODS_KEY(LSHIFT, KC_A): real_mods |= MOD_BIT(LSHIFT) (3) release ACTION_MODS_KEY(LSHIFT, KC_A): real_mods &amp;= ~MOD_BIT(LSHIFT) here real_mods lost state for 'physical left shift'. weak_mods is ORed with real_mods when keyboard report is sent. https:\/\/github.com\/tmk\/tmk_core\/blob\/master\/common\/action_util.c#L57 Timer Functionality It's possible to start timers and read values for time-specific events - here's an example: static uint16_t key_timer; key_timer = timer_read(); if (timer_elapsed(key_timer) &lt; 100) { \/\/ do something if less than 100ms have passed } else { \/\/ do something if 100ms or more have passed } It's best to declare the static uint16_t key_timer; at the top of the file, outside of any code blocks you're using it in.","tags":"","url":"FAQ\/Keymaps.html"},{"title":"Hardware","text":"Hardware Hardware QMK runs on a variety of hardware. If your processor can be targeted by LUFA or ChibiOS you can probably get QMK running on it. This section explores getting QMK running on, and communicating with, hardware of all kinds. Keyboard Guidelines AVR Processors ARM Processors (TBD) Drivers","tags":"","url":"Hardware\/index.html"},{"title":"AVR Processors","text":"Keyboards with AVR Processors Adding Your AVR Keyboard to QMK readme.md &lt;keyboard&gt;.c &lt;keyboard&gt;.h config.h Hardware Configuration Keyboard Matrix Configuration Backlight Configuration Other Configuration Options rules.mk MCU Options Bootloader Size Teensy 2.0 Bootloader Example Teensy 2.0++ Bootloader Example Atmel DFU Loader Example Build Options Keyboards with AVR Processors This page describes the support for for AVR processors in QMK. AVR processors include the atmega32u4, atmega32u2, at90usb1286, and other processors from Atmel Corporation. AVR processors are 8-bit MCU's that are designed to be easy to work with. The most common AVR processors in keyboards have on-board USB and plenty of GPIO for supporting large keyboard matrices. They are the most popular MCU for use in keyboards today. If you have not yet you should read the Keyboard Guidelines to get a sense of how keyboards fit into QMK. Adding Your AVR Keyboard to QMK QMK has a number of features to simplify working with AVR keyboards. For most keyboards you don't have to write a single line of code. To get started run the util\/new_project.sh script: $ util\/new_project.sh my_awesome_keyboard ###################################################### # \/keyboards\/my_awesome_keyboard project created. To start # working on things, cd into keyboards\/my_awesome_keyboard ###################################################### This will create all the files needed to support your new keyboard, and populate the settings with default values. Now you just need to customize it for your keyboard. readme.md This is where you'll describe your keyboard. Please follow the Keyboard Readme Template when writing your readme.md. You're encouraged to place an image at the top of your readme.md, please use an external service such as Imgur to host the images. &lt;keyboard&gt;.c This is where all the custom logic for your keyboard goes. Many keyboards do not need to put anything at all in here. You can learn more about writing custom logic in Custom Quantum Functions. &lt;keyboard&gt;.h This is the file you define your Layout Macro(s) in. At minimum you should have a #define LAYOUT for your keyboard that looks something like this: #define LAYOUT( \\ k00, k01, k02, \\ k10, k11 \\ ) { \\ { k00, k01, k02 }, \\ { k10, KC_NO, k11 }, \\ } The first half of the LAYOUT pre-processor macro defines the physical arrangement of keys. The second half of the macro defines the matrix the switches are connected to. This allows you to have a physical arrangement of keys that differs from the wiring matrix. Each of the k__ variables needs to be unique, and typically they follow the format k&lt;row&gt;&lt;col&gt;. The physical matrix (the second half) must have a number of rows equaling MATRIX_ROWS, and each row must have exactly MATRIX_COLS elements in it. If you do not have this many physical keys you can use KC_NO to fill in the blank spots. config.h The config.h file is where you configure the hardware and feature set for your keyboard. There are a lot of options that can be placed in that file, too many to list there. For a complete overview of available options see the Config Options page. Hardware Configuration At the top of the config.h you'll find USB related settings. These control how your keyboard appears to the Operating System. If you don't have a good reason to change you should leave the VENDOR_ID as 0xFEED. For the PRODUCT_ID you should pick a number that is not yet in use. Do change the MANUFACTURER, PRODUCT, and DESCRIPTION lines to accurately reflect your keyboard. #define VENDOR_ID 0xFEED #define PRODUCT_ID 0x6060 #define DEVICE_VER 0x0001 #define MANUFACTURER You #define PRODUCT my_awesome_keyboard #define DESCRIPTION A custom keyboard {% hint style='info' %} Note: On Windows and macOS the MANUFACTURER, PRODUCT, and DESCRIPTION fields will be displayed in the list of USB devices. On Linux these values will not be visible in lsusb, since Linux takes that information from the list published by the USB-IF. {% endhint %} Keyboard Matrix Configuration The next section of the config.h file deals with your keyboard's matrix. The first thing you should set is the matrix's size. This is usually, but not always, the same number of rows and columns as the physical key arrangement. #define MATRIX_ROWS 2 #define MATRIX_COLS 3 Once you've defined the size of your matrix you need to define which pins on your MCU are connected to rows and columns. To do so simply specify the names of those pins: #define MATRIX_ROW_PINS { D0, D5 } #define MATRIX_COL_PINS { F1, F0, B0 } #define UNUSED_PINS The number of MATRIX_ROW_PINS entries must be the same as the number you assigned to MATRIX_ROWS, and likewise for MATRIX_COL_PINS and MATRIX_COLS. You do not have to specify UNUSED_PINS, but you can if you want to document what pins are open. Finally, you can specify the direction your diodes point. This can be COL2ROW, ROW2COL, or CUSTOM_MATRIX. #define DIODE_DIRECTION COL2ROW Backlight Configuration By default QMK supports backlighting on pins B5, B6, and B7. If you are using one of those you can simply enable it here. For more details see the Backlight Documentation. #define BACKLIGHT_PIN B7 #define BACKLIGHT_LEVELS 3 #define BACKLIGHT_BREATHING #define BREATHING_PERIOD 6 {% hint style='info' %} You can use backlighting on any pin you like, but you will have to do more work to support that. See the Backlight Documentation for more details. {% endhint %} Other Configuration Options There are a lot of features that can be configured or tuned in config.h. You should see the Config Options page for more details. rules.mk You use the rules.mk file to tell QMK what files to build and what features to enable. If you are building around an atmega32u4 you can largely leave these defaults alone. If you are using another MCU you may have to tweak some parameters. MCU Options These options tell the build system what CPU to build for. Be very careful if you change any of these settings, you can render your keyboard inoperable. MCU = atmega32u4 F_CPU = 16000000 ARCH = AVR8 F_USB = $(F_CPU) OPT_DEFS += -DINTERRUPT_CONTROL_ENDPOINT Bootloader Size The bootloader is a special section of your MCU that allows you to upgrade the code stored on the MCU. Think of it like a Rescue Partition for your keyboard. If you are using a teensy 2.0, or a device like the Ergodox EZ that uses the teensy bootloader you should set this to 512. Most other bootloaders should be set to 4096, but 1024 and 2048 are other possible values you may encounter. Teensy 2.0 Bootloader Example OPT_DEFS += -DBOOTLOADER_SIZE=512 Teensy 2.0++ Bootloader Example OPT_DEFS += -DBOOTLOADER_SIZE=1024 Atmel DFU Loader Example OPT_DEFS += -DBOOTLOADER_SIZE=4096 Build Options There are a number of features that can be turned on or off in rules.mk. See the Config Options page for a detailed list and description.","tags":"","url":"Hardware\/AVR_Processors.html"},{"title":"Drivers","text":"QMK Hardware Drivers Available Drivers ProMicro (AVR Only) SSD1306 (AVR Only) uGFX WS2812 (AVR Only) QMK Hardware Drivers QMK is used on a lot of different hardware. While support for the most common MCU's and matrix configurations is built-in there are a number of drivers that can be added to a keyboard to support additional hardware. Examples include mice and other pointing devices, i\/o expanders for split keyboards, bluetooth modules, and LCD, OLED, and TFT screens. Available Drivers ProMicro (AVR Only) Support for addressing pins on the ProMicro by their Arduino name rather than their AVR name. This needs to be better documented, if you are trying to do this and reading the code doesn't help please open an issue and we can help you through the process. SSD1306 (AVR Only) Support for SSD1306 based OLED displays. This needs to be better documented, if you are trying to do this and reading the code doesn't help please open an issue and we can help you through the process. uGFX You can make use of uGFX within QMK to drive character and graphic LCD's, LED arrays, OLED, TFT, and other display technologies. This needs to be better documented, if you are trying to do this and reading the code doesn't help please open an issue and we can help you through the process. WS2812 (AVR Only) Support for WS2811\/WS2812{a,b,c} LED's. For more information see the RGB Light page.","tags":"","url":"Hardware\/Drivers.html"},{"title":"Features","text":"QMK Features QMK Features QMK has a staggering number of features for building your keyboard. It can take some time to understand all of them and determine which one will achieve your goal. [Advanced Keycodes](Advanced Keycodes.md) - Change layers, type shifted keys, and more. Go beyond typing simple characters. Audio - Connect a speaker to your keyboard for audio feedback, midi support, and music mode. [Auto Shift](Auto Shift.md) - Tap for the normal key, hold slightly longer for its shifted state. Backlight - LED lighting support for your keyboard. Bootmagic - Adjust the behavior of your keyboard using hotkeys. Dynamic Macros - Record and playback macros from the keyboard itself. Key Lock - Lock a key in the &quot;down&quot; state. Layouts - Use one keymap with any keyboard that supports your layout. Leader Key - Tap the leader key followed by a sequence to trigger custom behavior. Macros - Send multiple key presses when pressing only one physical key. Mouse keys - Control your mouse pointer from your keyboard. Pointing Device - Framework for connecting your custom pointing device to your keyboard. PS2 Mouse - Driver for connecting a PS\/2 mouse directly to your keyboard. RGB Light - RGB lighting for your keyboard. Space Cadet Shift - Use your left\/right shift keys to type parenthesis and brackets. Space Cadet Shift Enter - Combined Shift\/Enter keys Stenography - Put your keyboard into Plover mode for stenography use. Tap Dance - Make a single key do as many things as you want. Terminal - CLI interface to the internals of your keyboard. Thermal Printer - Connect a thermal printer to your keyboard to be able to toggle on a printed log of everything you type. Unicode - Unicode input support. Userspace - Share code between different keymaps and keyboards.","tags":"","url":"Features\/index.html"},{"title":"Advanced Keycodes","text":"Advanced Keycodes Assigning Custom Names Limits of These Aliases Switching and Toggling Layers Working with Layers Beginners Intermediate Users Advanced Users Modifier Keys Shifted Keycodes Mod Tap One Shot Keys Permissive Hold Advanced Keycodes Your keymap can include keycodes that are more advanced than normal, for example shifted keys. This page documents the functions that are available to you. Assigning Custom Names People often define custom names using #define. For example: #define FN_CAPS LT(_FL, KC_CAPSLOCK) #define ALT_TAB LALT(KC_TAB) This will allow you to use FN_CAPS and ALT_TAB in your KEYMAP(), keeping it more readable. Limits of These Aliases Currently, the keycodes able to used with these functions are limited to the Basic Keycodes, meaning you can't use keycodes like KC_TILD, or anything greater than 0xFF. For a full list of the keycodes able to be used see Basic Keycodes. Switching and Toggling Layers These functions allow you to activate layers in various ways. Note that layers are not generally independent layouts -- multiple layers can be activated at once, and it's typical for layers to use KC_TRNS to allow keypresses to pass through to lower layers. For a detailed explanation of layers, see Keymap Overview DF(layer) - switches the default layer. The default layer is the always-active base layer that other layers stack on top of. See below for more about the default layer. This might be used to switch from QWERTY to Dvorak layout. (Note that this is a temporary switch that only persists until the keyboard loses power. To modify the default layer in a persistent way requires deeper customization, such as calling the set_single_persistent_default_layer function inside of process_record_user.) MO(layer) - momentarily activates layer. As soon as you let go of the key, the layer is deactivated. LM(layer, mod) - Momentarily activates layer (like MO), but with modifier(s) mod active. Only supports layers 0-15 and the left modifiers. LT(layer, kc) - momentarily activates layer when held, and sends kc when tapped. TG(layer) - toggles layer, activating it if it's inactive and vice versa TO(layer) - activates layer and de-activates all other layers (except your default layer). This function is special, because instead of just adding\/removing one layer to your active layer stack, it will completely replace your current active layers, uniquely allowing you to replace higher layers with a lower one. This is activated on keydown (as soon as the key is pressed). TT(layer) - Layer Tap-Toggle. If you hold the key down, layer is activated, and then is de-activated when you let go (like MO). If you repeatedly tap it, the layer will be toggled on or off (like TG). It needs 5 taps by default, but you can change this by defining TAPPING_TOGGLE -- for example, #define TAPPING_TOGGLE 2 to toggle on just two taps. Working with Layers Care must be taken when switching layers, it's possible to lock yourself into a layer with no way to deactivate that layer (without unplugging your keyboard.) We've created some guidelines to help users avoid the most common problems. Beginners If you are just getting started with QMK you will want to keep everything simple. Follow these guidelines when setting up your layers: Setup layer 0 as your default, &quot;base&quot; layer. This is your normal typing layer, and could be whatever layout you want (qwerty, dvorak, colemak, etc.). It's important to set this as the lowest layer since it will typically have most or all of the keyboard's keys defined, so would block other layers from having any effect if it were above them (i.e., had a higher layer number). Arrange your layers in a &quot;tree&quot; layout, with layer 0 as the root. Do not try to enter the same layer from more than one other layer. In a layer's keymap, only reference higher-numbered layers. Because layers are processed from the highest-numbered (topmost) active layer down, modifying the state of lower layers can be tricky and error-prone. Intermediate Users Sometimes you need more than one base layer. For example, if you want to switch between QWERTY and Dvorak, switch between layouts for different countries, or switch your layout for different videogames. Your base layers should always be the lowest numbered layers. When you have multiple base layers you should always treat them as mutually exclusive. When one base layer is on the others are off. Advanced Users Once you have a good feel for how layers work and what you can do, you can get more creative. The rules listed in the beginner section will help you be successful by avoiding some of the tricker details but they can be constraining, especially for ultra-compact keyboard users. Understanding how layers work will allow you to use them in more advanced ways. Layers stack on top of each other in numerical order. When determining what a keypress does, QMK scans the layers from the top down, stopping when it reaches the first active layer that is not set to KC_TRNS. As a result if you activate a layer that is numerically lower than your current layer, and your current layer (or another layer that is active and higher than your target layer) has something other than KC_TRNS, that is the key that will be sent, not the key on the layer you just activated. This is the cause of most people's &quot;why doesn't my layer get switched&quot; problem. Sometimes, you might want to switch between layers in a macro or as part of a tap dance routine. layer_on activates a layer, and layer_off deactivates it. More layer-related functions can be found in action_layer.h. Modifier Keys These functions allow you to combine a mod with a keycode. When pressed the keydown for the mod will be sent first, and then kc will be sent. When released the keyup for kc will be sent and then the mod will be sent. LSFT(kc) or S(kc) - applies left Shift to kc (keycode) RSFT(kc) - applies right Shift to kc LCTL(kc) - applies left Control to kc RCTL(kc) - applies right Control to kc LALT(kc) - applies left Alt to kc RALT(kc) - applies right Alt to kc LGUI(kc) - applies left GUI (command\/win) to kc RGUI(kc) - applies right GUI (command\/win) to kc HYPR(kc) - applies Hyper (all modifiers) to kc MEH(kc) - applies Meh (all modifiers except Win\/Cmd) to kc LCAG(kc) - applies CtrlAltGui to kc You can also chain these, like this: LALT(LCTL(KC_DEL)) -- this makes a key that sends Alt, Control, and Delete in a single keypress. Shifted Keycodes The following shortcuts automatically add LSFT() to keycodes to get commonly used symbols. Key Aliases Description KC_TILDE KC_TILD ~ KC_EXCLAIM KC_EXLM ! KC_AT @ KC_HASH # KC_DOLLAR KC_DLR $ KC_PERCENT KC_PERC % KC_CIRCUMFLEX KC_CIRC ^ KC_AMPERSAND KC_AMPR &amp; KC_ASTERISK KC_ASTR * KC_LEFT_PAREN KC_LPRN ( KC_RIGHT_PAREN KC_RPRN ) KC_UNDERSCORE KC_UNDS _ KC_PLUS + KC_LEFT_CURLY_BRACE KC_LCBR { KC_RIGHT_CURLY_BRACE KC_RCBR } KC_PIPE | KC_COLON KC_COLN : KC_DOUBLE_QUOTE KC_DQT\/KC_DQUO &quot; KC_LEFT_ANGLE_BRACKET KC_LT\/KC_LABK &lt; KC_RIGHT_ANGLE_BRACKET KC_GT\/KC_RABK &gt; KC_QUESTION KC_QUES ? Mod Tap MT(mod, kc) - is mod (modifier key - MOD_LCTL, MOD_LSFT) when held, and kc when tapped. In other words, you can have a key that sends Esc (or the letter O or whatever) when you tap it, but works as a Control key or a Shift key when you hold it down. These are the values you can use for the mod in MT() and OSM(): MOD_LCTL MOD_LSFT MOD_LALT MOD_LGUI MOD_RCTL MOD_RSFT MOD_RALT MOD_RGUI MOD_HYPR MOD_MEH These can also be combined like MOD_LCTL | MOD_LSFT e.g. MT(MOD_LCTL | MOD_LSFT, KC_ESC) which would activate Control and Shift when held, and send Escape when tapped. We've added shortcuts to make common modifier\/tap (mod-tap) mappings more compact: CTL_T(kc) - is LCTL when held and kc when tapped SFT_T(kc) - is LSFT when held and kc when tapped ALT_T(kc) - is LALT when held and kc when tapped ALGR_T(kc) - is AltGr when held and kc when tapped GUI_T(kc) - is LGUI when held and kc when tapped ALL_T(kc) - is Hyper (all mods) when held and kc when tapped. To read more about what you can do with a Hyper key, see this blog post by Brett Terpstra LCAG_T(kc) - is CtrlAltGui when held and kc when tapped MEH_T(kc) - is like Hyper, but not as cool -- does not include the Cmd\/Win key, so just sends Alt+Ctrl+Shift. {% hint style='info' %} Due to the way that keycodes are structured, any modifiers specified as part of kc, such as LCTL() or KC_LPRN, will only activate when held instead of tapped. Additionally, if there is at least one right modifier, any other modifiers will turn into their right equivalents, so it is not possible to &quot;mix and match&quot; the two. {% endhint %} One Shot Keys One shot keys are keys that remain active until the next key is pressed, and then are released. This allows you to type keyboard combinations without pressing more than one key at a time. These keys are usually called &quot;Sticky keys&quot; or &quot;Dead keys&quot;. For example, if you define a key as OSM(MOD_LSFT), you can type a capital A character by first pressing and releasing shift, and then pressing and releasing A. Your computer will see the shift key being held the moment shift is pressed, and it will see the shift key being released immediately after A is released. One shot keys also work as normal modifiers. If you hold down a one shot key and type other keys, your one shot will be released immediately after you let go of the key. You can control the behavior of one shot keys by defining these in config.h: #define ONESHOT_TAP_TOGGLE 5 \/* Tapping this number of times holds the key until tapped this number of times again. *\/ #define ONESHOT_TIMEOUT 5000 \/* Time (in ms) before the one shot key is released *\/ OSM(mod) - Momentarily hold down mod. You must use the MOD_* keycodes as shown in Mod Tap, not the KC_* codes. OSL(layer) - momentary switch to layer. Sometimes, you want to activate a one-shot layer as part of a macro or tap dance routine. To do this, you need to call set_oneshot_layer(LAYER, ONESHOT_START) on key down, and set_oneshot_layer(ONESHOT_PRESSED) on key up. If you want to cancel the oneshot, call reset_oneshot_layer(). For more complicated actions, take a look at the oneshot implementation in process_record. If you're having issues with OSM translating over Remote Desktop Connection, this can be fixed by opening the settings, going to the &quot;Local Resources&quot; tap, and in the keyboard section, change the drop down to &quot;On this Computer&quot;. This will fix the issue and allow OSM to function properly over Remote Desktop. Permissive Hold As of PR#1359, there is a new config.h option: #define PERMISSIVE_HOLD This makes it easier for fast typists to use dual-function keys. Without this, if you let go of a held key inside the tapping term, it won't register. Example: (Tapping Term = 200ms) SHFT_T(KC_A) Down KC_X Down KC_X Up SHFT_T(KC_A) Up With defaults, if above is typed within tapping term, this will emit ax. With permissive hold, if above is typed within tapping term, this will emit X (so, Shift+X).","tags":"","url":"Features\/Advanced_Keycodes.html"},{"title":"Audio","text":"Audio Music Mode Faux Click MIDI Functionality Audio Your keyboard can make sounds! If you've got a Planck, Preonic, or basically any AVR keyboard that allows access to certain PWM-capable pins, you can hook up a simple speaker and make it beep. You can use those beeps to indicate layer transitions, modifiers, special keys, or just to play some funky 8bit tunes. Up to two simultaneous audio voices are supported, one driven by timer 1 and another driven by timer 3. The following pins can be defined as audio outputs in config.h: Timer 1: #define B5_AUDIO #define B6_AUDIO #define B7_AUDIO Timer 3: #define C4_AUDIO #define C5_AUDIO #define C6_AUDIO If you add AUDIO_ENABLE = yes to your rules.mk, there's a couple different sounds that will automatically be enabled without any other configuration: STARTUP_SONG \/\/ plays when the keyboard starts up (audio.c) GOODBYE_SONG \/\/ plays when you press the RESET key (quantum.c) AG_NORM_SONG \/\/ plays when you press AG_NORM (quantum.c) AG_SWAP_SONG \/\/ plays when you press AG_SWAP (quantum.c) MUSIC_ON_SONG \/\/ plays when music mode is activated (process_music.c) MUSIC_OFF_SONG \/\/ plays when music mode is deactivated (process_music.c) CHROMATIC_SONG \/\/ plays when the chromatic music mode is selected (process_music.c) GUITAR_SONG \/\/ plays when the guitar music mode is selected (process_music.c) VIOLIN_SONG \/\/ plays when the violin music mode is selected (process_music.c) MAJOR_SONG \/\/ plays when the major music mode is selected (process_music.c) You can override the default songs by doing something like this in your config.h: #ifdef AUDIO_ENABLE #define STARTUP_SONG SONG(STARTUP_SOUND) #endif A full list of sounds can be found in quantum\/audio\/song_list.h - feel free to add your own to this list! All available notes can be seen in quantum\/audio\/musical_notes.h. To play a custom sound at a particular time, you can define a song like this (near the top of the file): float my_song[][2] = SONG(QWERTY_SOUND); And then play your song like this: PLAY_SONG(my_song); Alternatively, you can play it in a loop like this: PLAY_LOOP(my_song); It's advised that you wrap all audio features in #ifdef AUDIO_ENABLE \/ #endif to avoid causing problems when audio isn't built into the keyboard. Music Mode The music mode maps your columns to a chromatic scale, and your rows to octaves. This works best with ortholinear keyboards, but can be made to work with others. All keycodes less than 0xFF get blocked, so you won't type while playing notes - if you have special keys\/mods, those will still work. A work-around for this is to jump to a different layer with KC_NOs before (or after) enabling music mode. Recording is experimental due to some memory issues - if you experience some weird behavior, unplugging\/replugging your keyboard will fix things. 06_Keycodes available: MU_ON - Turn music mode on MU_OFF - Turn music mode off MU_TOG - Toggle music mode MU_MOD - Cycle through the music modes: CHROMATIC_MODE - Chromatic scale, row changes the octave GUITAR_MODE - Chromatic scale, but the row changes the string (+5 st) VIOLIN_MODE - Chromatic scale, but the row changes the string (+7 st) MAJOR_MODE - Major scale In music mode, the following keycodes work differently, and don't pass through: LCTL - start a recording LALT - stop recording\/stop playing LGUI - play recording KC_UP - speed-up playback KC_DOWN - slow-down playback By default, MUSIC_MASK is set to keycode &lt; 0xFF which means keycodes less than 0xFF are turned into notes, and don't output anything. You can change this by defining this in your config.h like this: #define MUSIC_MASK keycode != KC_NO Which will capture all keycodes - be careful, this will get you stuck in music mode until you restart your keyboard! The pitch standard (PITCH_STANDARD_A) is 440.0f by default - to change this, add something like this to your config.h: #define PITCH_STANDARD_A 432.0f You can completely disable Music Mode as well. This is useful, if you're pressed for space on your controller. To disable it, add this to your config.h: #define NO_MUSIC_MODE Faux Click This adds a click sound each time you hit a button, to simulate click sounds from the keyboard. And the sounds are slightly different for each keypress, so it doesn't sound like a single long note, if you type rapidly. CK_TOGG - Toggles the status (will play sound if enabled) CK_RST - Resets the frequency to the default state CK_UP - Increases the frequency of the clicks CK_DOWN - Decreases the frequency of the clicks The feature is disabled by default, to save space. To enable it, add this to your config.h: #define AUDIO_CLICKY Additionally, even when enabled, the feature is not enabled by default, so you would need to turn it on first. And since we don't use EEPROM to store the setting (yet), you can default this to on by adding this to your config.h: #define AUDIO_CLICKY_ON You can configure the default, min and max frequencies, the stepping and built in randomness by defining these values: Option Default Value Description AUDIO_CLICKY_FREQ_DEFAULT 440.0f Sets the default\/starting audio frequency for the clicky sounds. AUDIO_CLICKY_FREQ_MIN 65.0f Sets the lowest frequency (under 60f are a bit buggy). AUDIO_CLICKY_FREQ_MAX 1500.0f Sets the the highest frequency. Too high may result in coworkers attacking you. AUDIO_CLICKY_FREQ_FACTOR 1.18921f Sets the stepping of UP\/DOWN key codes. AUDIO_CLICKY_FREQ_RANDOMNESS 0.05f Sets a factor of randomness for the clicks, Setting this to 0f will make each click identical. MIDI Functionality This is still a WIP, but check out quantum\/keymap_midi.c to see what's happening. Enable from the Makefile.","tags":"","url":"Features\/Audio.html"},{"title":"Auto Shift","text":"Auto Shift: Why Do We Need a Shift Key? Why Auto Shift? How Does It Work? Are There Limitations to Auto Shift? How Do I Enable Auto Shift? Modifiers Configuring Auto Shift AUTO_SHIFT_TIMEOUT (Value in ms) NO_AUTO_SHIFT_SPECIAL (simple define) NO_AUTO_SHIFT_NUMERIC (simple define) NO_AUTO_SHIFT_ALPHA (simple define) Using Auto Shift Setup Setup Use An Example Run Auto Shift: Why Do We Need a Shift Key? Tap a key and you get its character. Tap a key, but hold it slightly longer and you get its shifted state. Voil ! No shift key needed! Why Auto Shift? Many people suffer from various forms of RSI. A common cause is stretching your fingers repetitively long distances. For us on the keyboard, the pinky does that all too often when reaching for the shift key. Auto Shift looks to alleviate that problem. How Does It Work? When you tap a key, it stays depressed for a short period of time before it is then released. This depressed time is a different length for everyone. Auto Shift defines a constant AUTO_SHIFT_TIMEOUT which is typically set to twice your normal pressed state time. When you press a key, a timer starts and then stops when you release the key. If the time depressed is greater than or equal to the AUTO_SHIFT_TIMEOUT, then a shifted version of the key is emitted. If the time is less than the AUTO_SHIFT_TIMEOUT time, then the normal state is emitted. Are There Limitations to Auto Shift? Yes, unfortunately. Key repeat will cease to work. For example, before if you wanted 20 'a' characters, you could press and hold the 'a' key for a second or two. This no longer works with Auto Shift because it is timing your depressed time instead of emitting a depressed key state to your operating system. You will have characters that are shifted when you did not intend on shifting, and other characters you wanted shifted, but were not. This simply comes down to practice. As we get in a hurry, we think we have hit the key long enough for a shifted version, but we did not. On the other hand, we may think we are tapping the keys, but really we have held it for a little longer than anticipated. How Do I Enable Auto Shift? Add to your rules.mk in the keymap folder: AUTO_SHIFT_ENABLE = yes If no rules.mk exists, you can create one. Then compile and install your new firmware with Auto Key enabled! That's it! Modifiers By default, Auto Shift is disabled for any key press that is accompanied by one or more modifiers. Thus, Ctrl+A that you hold for a really long time is not the same as Ctrl+Shift+A. You can re-enable Auto Shift for modifiers by adding another rule to your rules.mk AUTO_SHIFT_MODIFIERS = yes In which case, Ctrl+A held past the AUTO_SHIFT_TIMEOUT will be sent as Ctrl+Shift+A Configuring Auto Shift If desired, there is some configuration that can be done to change the behavior of Auto Shift. This is done by setting various variables the config.h file located in your keymap folder. If no config.h file exists, you can create one. A sample is #ifndef CONFIG_USER_H #define CONFIG_USER_H #include &quot;..\/..\/config.h&quot; #define AUTO_SHIFT_TIMEOUT 150 #define NO_AUTO_SHIFT_SPECIAL #endif AUTO_SHIFT_TIMEOUT (Value in ms) This controls how long you have to hold a key before you get the shifted state. Obviously, this is different for everyone. For the common person, a setting of 135 to 150 works great. However, one should start with a value of at least 175, which is the default value. Then work down from there. The idea is to have the shortest time required to get the shifted state without having false positives. Play with this value until things are perfect. Many find that all will work well at a given value, but one or two keys will still emit the shifted state on occasion. This is simply due to habit and holding some keys a little longer than others. Once you find this value, work on tapping your problem keys a little quicker than normal and you will be set. {% hint style='info' %} Auto Shift has three special keys that can help you get this value right very quick. See &quot;Auto Shift Setup&quot; for more details! {% endhint %} NO_AUTO_SHIFT_SPECIAL (simple define) Do not Auto Shift special keys, which include -_, =+, [{, ]}, ;:, '&quot;, ,&lt;, .&gt;, and \/? NO_AUTO_SHIFT_NUMERIC (simple define) Do not Auto Shift numeric keys, zero through nine. NO_AUTO_SHIFT_ALPHA (simple define) Do not Auto Shift alpha characters, which include A through Z. Using Auto Shift Setup This will enable you to define three keys temporarily to increase, decrease and report your AUTO_SHIFT_TIMEOUT. Setup Map three keys temporarily in your keymap: Key Name Description KC_ASDN Lower the Auto Shift timeout variable (down) KC_ASUP Raise the Auto Shift timeout variable (up) KC_ASRP Report your current Auto Shift timeout value KC_ASON Turns on the Auto Shift Function KC_ASOFF Turns off the Auto Shift Function KC_ASTG Toggles the state of the Auto Shift feature Compile and upload your new firmware. Use It is important to note that during these tests, you should be typing completely normal and with no intention of shifted keys. Type multiple sentences of alphabetical letters. Observe any upper case letters. If there are none, press the key you have mapped to KC_ASDN to decrease time Auto Shift timeout value and go back to step 1. If there are some upper case letters, decide if you need to work on tapping those keys with less down time, or if you need to increase the timeout. If you decide to increase the timeout, press the key you have mapped to KC_ASUP and go back to step 1. Once you are happy with your results, press the key you have mapped to KC_ASRP. The keyboard will type by itself the value of your AUTO_SHIFT_TIMEOUT. Update AUTO_SHIFT_TIMEOUT in your config.h with the value reported. Remove AUTO_SHIFT_SETUP from your config.h. Remove the key bindings KC_ASDN, KC_ASUP and KC_ASRP. Compile and upload your new firmware. An Example Run hello world. my name is john doe. i am a computer programmer playing with keyboards right now. [PRESS KC_ASDN quite a few times] heLLo woRLd. mY nAMe is JOHn dOE. i AM A compUTeR proGRaMMER PlAYiNG witH KEYboArDS RiGHT NOw. [PRESS KC_ASUP a few times] hello world. my name is john Doe. i am a computer programmer playing with keyboarDs right now. [PRESS KC_ASRP] 115 The keyboard typed 115 which represents your current AUTO_SHIFT_TIMEOUT value. You are now set! Practice on the D key a little bit that showed up in the testing and you'll be golden.","tags":"","url":"Features\/Auto_Shift.html"},{"title":"Backlight","text":"Backlighting Backlight Keycodes Configuration Options in config.h Notes on Implementation Backlighting Backlight Keycodes These keycodes control the backlight. Most keyboards use this for single color in-switch lighting. Key Description BL_TOGG Turn the backlight on or off BL_STEP Cycle through backlight levels BL_ON Set the backlight to max brightness BL_OFF Turn the backlight off BL_INC Increase the backlight level BL_DEC Decrease the backlight level BL_BRTG Toggle backlight breathing Note that for backlight breathing, you need to have #define BACKLIGHT_BREATHING in your config.h. Configuration Options in config.h BACKLIGHT_PIN B7 defines the pin that controlls the LEDs. Unless you design your own keyboard, you don't need to set this. BACKLIGHT_LEVELS 3 defines the number of brightness levels (maximum 15 excluding off). BACKLIGHT_BREATHING if defined, enables backlight breathing. Note that this is only available if BACKLIGHT_PIN is B5, B6 or B7. BREATHING_PERIOD 6 defines the length of one backlight &quot;breath&quot; in seconds. Notes on Implementation To change the brightness when using pins B5, B6 or B7, the PWM (Pulse Width Modulation) functionality of the on-chip timer is used. The timer is a counter that counts up to a certain TOP value (0xFFFF set in ICR1) before resetting to 0. We also set an OCR1x register. When the counter reaches the value stored in that register, the PWM pin drops to low. The PWM pin is pulled high again when the counter resets to 0. Therefore, OCR1x basically sets the duty cycle of the LEDs and as such the brightness where 0 is the darkest and 0xFFFF the brightest setting. To enable the breathing effect, we register an interrupt handler to be called whenever the counter resets (with ISR(TIMER1_OVF_vect)). In this handler, which gets called roughly 244 times per second, we compute the desired brightness using a precomputed brightness curve. To disable breathing, we can just disable the respective interrupt vector and reset the brightness to the desired level.","tags":"","url":"Features\/Backlight.html"},{"title":"Bluetooth","text":"Bluetooth Bluetooth Functionality Bluetooth Keycodes Bluetooth Bluetooth Functionality This requires some hardware changes, but can be enabled via the Makefile. The firmware will still output characters via USB, so be aware of this when charging via a computer. It would make sense to have a switch on the Bluefruit to turn it off at will. Bluetooth Keycodes This is used when multiple keyboard outputs can be selected. Currently this only allows for switching between USB and Bluetooth on keyboards that support both. Name Description OUT_AUTO Automatically switch between USB and Bluetooth OUT_USB USB only OUT_BT Bluetooth only","tags":"","url":"Features\/Bluetooth.html"},{"title":"Bootmagic","text":"Bootmagic and Magic Keycodes Enabling Bootmagic Bootmagic Hotkeys and Keycodes Bootmagic Configuration Bootmagic and Magic Keycodes There are 3 separate but related features that allow you to change the behavior of your keyboard without reflashing. While each of them have similar functionality you access that functionality in different ways depending on how your keyboard is configured. Bootmagic is a system for configuring your keyboard while it initializes. To trigger a Bootmagic command you hold down the bootmagic key (KC_SPACE on most keyboards) and one or more command keys. Bootmagic Keycodes allow you to access the Bootmagic functionality after your keyboard has initialized. To use Bootmagic Keycodes you assign keycodes starting with MAGIC_, much in the same way you define any other key. Command is a feature that allows you to control different aspects of your keyboard. Command used to be called Magic. Command is typically accessed by holding Left and Right Shift at the same time, although that can be customized. While it shares some functionality with Bootmagic it also allows you to access functionality that Bootmagic does not. For more information see the Command documentation page. Enabling Bootmagic Bootmagic is disabled by default. To use Bootmagic you need to enable it in your rules.mk file: BOOTMAGIC_ENABLE = yes Bootmagic Hotkeys and Keycodes This table describes the default Hotkeys for Bootmagic and the Keycodes for Magic. These may be overriden at the Keyboard or Keymap level. Some functionality is not available in both methods. To use the Hotkey hold down BOOTMAGIC_KEY_SALT (KC_SPACE by default) and the Hotkey while plugging in your keyboard. To use the Keycode assign that keycode to a layer. For example, if you hold down Space+B while plugging in most keyboards, you will enter bootloader mode. Hotkey Keycode Description ESC Skip bootmagic and saved eeprom configuration B RESET Enter bootloader instead of firmware D DEBUG Enable debugging (writes messages to serial) X Enable matrix debugging K Enable keyboard debugging M Enable mouse debugging BACKSPACE Clear the saved settings from flash CAPSLOCK MAGIC_CAPSLOCK_TO_CONTROL Treat Capslock as Control MAGIC_UNCAPSLOCK_TO_CONTROL Stop treating CapsLock as Control LCTRL MAGIC_SWAP_CONTROL_CAPSLOCK Swap Control and Capslock MAGIC_UNSWAP_CONTROL_CAPSLOCK Unswap Left Control and Caps Lock MAGIC_SWAP_ALT_GUI Swap Alt and GUI on both sides MAGIC_UNSWAP_ALT_GUI Unswap Left Alt and GUI LALT MAGIC_SWAP_LALT_LGUI Swap Left Alt and GUI, e.g. for OSX Opt and Cmd MAGIC_UNSWAP_LALT_LGUI Unswap Left Alt and GUI RALT MAGIC_SWAP_RALT_RGUI Swap Right Alt and GUI MAGIC_UNSWAP_RALT_RGUI Unswap Right Alt and GUI LGUI MAGIC_NO_GUI Disable GUI key - e.g. disable Windows key during gaming MAGIC_UNNO_GUI Enable the GUI key GRAVE MAGIC_SWAP_GRAVE_ESC ~ and ESC MAGIC_UNSWAP_GRAVE_ESC ~ and Escape BACKSLASH MAGIC_SWAP_BACKSLASH_BACKSPACE Swap Blackslash and Backspace MAGIC_UNSWAP_BACKSLASH_BACKSPACE Unswap Backslash and Backspace N MAGIC_HOST_NKRO Force N-Key Rollover (NKRO) on MAGIC_UNHOST_NKRO Force NKRO off MAGIC_TOGGLE_NKRO Toggle NKRO on or off 0 DF(0) Make Layer 0 the default layer at bootup 1 DF(1) Make Layer 1 the default layer at bootup 2 DF(2) Make Layer 2 the default layer at bootup 3 DF(3) Make Layer 3 the default layer at bootup 4 DF(4) Make Layer 4 the default layer at bootup 5 DF(5) Make Layer 5 the default layer at bootup 6 DF(6) Make Layer 6 the default layer at bootup 7 DF(7) Make Layer 7 the default layer at bootup Bootmagic Configuration When setting up your keyboard and\/or keymap there are a number of #defines that control the behavior of Bootmagic. To use these put them in your config.h, either at the keyboard or keymap level. Define Default Description BOOTMAGIC_KEY_SALT KC_SPACE The key to hold down to trigger Bootmagic during initialization. BOOTMAGIC_KEY_SKIP KC_ESC The Hotkey to ignore saved eeprom configuration. BOOTMAGIC_KEY_EEPROM_CLEAR KC_BSPACE The hotkey to clear the saved eeprom configuration. BOOTMAGIC_KEY_BOOTLOADER KC_B The hotkey to enter the bootloader. BOOTMAGIC_KEY_DEBUG_ENABLE KC_D The hotkey to enable debug mode. BOOTMAGIC_KEY_DEBUG_MATRIX KC_X The hotkey to enable matrix debugging mode. BOOTMAGIC_KEY_DEBUG_KEYBOARD KC_K The hotkey to enable keyboard debugging mode. BOOTMAGIC_KEY_DEBUG_MOUSE KC_M The hotkey to enable mouse debugging mode. BOOTMAGIC_KEY_SWAP_CONTROL_CAPSLOCK KC_LCTRL BOOTMAGIC_KEY_CAPSLOCK_TO_CONTROL KC_CAPSLOCK BOOTMAGIC_KEY_SWAP_LALT_LGUI KC_LALT BOOTMAGIC_KEY_SWAP_RALT_RGUI KC_RALT BOOTMAGIC_KEY_NO_GUI KC_LGUI BOOTMAGIC_KEY_SWAP_GRAVE_ESC KC_GRAVE BOOTMAGIC_KEY_SWAP_BACKSLASH_BACKSPACE KC_BSLASH BOOTMAGIC_HOST_NKRO KC_N BOOTMAGIC_KEY_DEFAULT_LAYER_0 KC_0 Hotkey to set Layer 0 as the default layer BOOTMAGIC_KEY_DEFAULT_LAYER_1 KC_1 Hotkey to set Layer 1 as the default layer BOOTMAGIC_KEY_DEFAULT_LAYER_2 KC_2 Hotkey to set Layer 2 as the default layer BOOTMAGIC_KEY_DEFAULT_LAYER_3 KC_3 Hotkey to set Layer 3 as the default layer BOOTMAGIC_KEY_DEFAULT_LAYER_4 KC_4 Hotkey to set Layer 4 as the default layer BOOTMAGIC_KEY_DEFAULT_LAYER_5 KC_5 Hotkey to set Layer 5 as the default layer BOOTMAGIC_KEY_DEFAULT_LAYER_6 KC_6 Hotkey to set Layer 6 as the default layer BOOTMAGIC_KEY_DEFAULT_LAYER_7 KC_7 Hotkey to set Layer 7 as the default layer","tags":"","url":"Features\/Bootmagic.html"},{"title":"Command","text":"Command (Formerly known as Magic) Enabling Command Usage Configuration Command (Formerly known as Magic) Command is a way to change your keyboard's behavior without having to flash or unplug it to use Bootmagic. There is a lot of overlap between this functionality and the Bootmagic Keycodes. Whenever possible we encourage you to use that functionality instead of Command. Enabling Command By default Command is disabled. You can enable it in your rules.mk file: COMMAND_ENABLE = yes Usage To use Command you hold down the key combination defined by IS_COMMAND. By default that combination is both shift keys. While holding the key combination press the key corresponding to the command you want. For example, to write the current QMK version to the QMK Toolbox console, you can press Left Shift+Right Shift+V. Configuration The following values can be defined in config.h to control the behavior of Command. Define Default Description IS_COMMAND() (keyboard_report-&gt;mods == (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) Key combination to activate Command MAGIC_KEY_SWITCH_LAYER_WITH_FKEYS true Do layer switching with Function row MAGIC_KEY_SWITCH_LAYER_WITH_NKEYS true Do layer switching with number keys. MAGIC_KEY_SWITCH_LAYER_WITH_CUSTOM false Do layer switching with custom keys (MAGIC_KEY_LAYER0..9 below.) MAGIC_KEY_HELP1 H Show help. MAGIC_KEY_HELP2 SLASH Show help. MAGIC_KEY_DEBUG D Turn on debug mode. MAGIC_KEY_DEBUG_MATRIX X Turn on matrix debugging. MAGIC_KEY_DEBUG_KBD K Turn on keyboard debugging. MAGIC_KEY_DEBUG_MOUSE M Turn on mouse debugging. MAGIC_KEY_VERSION V Write the QMK version to the console MAGIC_KEY_STATUS S Show the current keyboard status MAGIC_KEY_CONSOLE C Enable the Command Console MAGIC_KEY_LAYER0_ALT1 ESC Alternate access to layer 0 MAGIC_KEY_LAYER0_ALT2 GRAVE Alternate access to layer 0 MAGIC_KEY_LAYER0 0 Change default layer to 0 MAGIC_KEY_LAYER1 1 Change default layer to 1 MAGIC_KEY_LAYER2 2 Change default layer to 2 MAGIC_KEY_LAYER3 3 Change default layer to 3 MAGIC_KEY_LAYER4 4 Change default layer to 4 MAGIC_KEY_LAYER5 5 Change default layer to 5 MAGIC_KEY_LAYER6 6 Change default layer to 6 MAGIC_KEY_LAYER7 7 Change default layer to 7 MAGIC_KEY_LAYER8 8 Change default layer to 8 MAGIC_KEY_LAYER9 9 Change default layer to 9 MAGIC_KEY_BOOTLOADER PAUSE Exit keyboard and enter bootloader MAGIC_KEY_LOCK CAPS Lock the keyboard so nothing can be typed MAGIC_KEY_EEPROM E Erase EEPROM settings MAGIC_KEY_NKRO N Toggle NKRO on\/off MAGIC_KEY_SLEEP_LED Z Toggle LED when computer is sleeping on\/off","tags":"","url":"Features\/Command.html"},{"title":"Dynamic Macros","text":"Dynamic Macros: Record and Replay Macros in Runtime Dynamic Macros: Record and Replay Macros in Runtime QMK supports temporary macros created on the fly. We call these Dynamic Macros. They are defined by the user from the keyboard and are lost when the keyboard is unplugged or otherwise rebooted. You can store one or two macros and they may have a combined total of 128 keypresses. You can increase this size at the cost of RAM. To enable them, first add a new element to the planck_keycodes enum \u2014 DYNAMIC_MACRO_RANGE: enum planck_keycodes { QWERTY = SAFE_RANGE, COLEMAK, DVORAK, PLOVER, LOWER, RAISE, BACKLIT, EXT_PLV, DYNAMIC_MACRO_RANGE, }; It must be the last element because dynamic_macros.h will add some more keycodes after it. Below it, include the dynamic_macro.h header: #include &quot;dynamic_macro.h&quot;` Add the following keys to your keymap: DYN_REC_START1 \u2014 start recording the macro 1, DYN_REC_START2 \u2014 start recording the macro 2, DYN_MACRO_PLAY1 \u2014 replay the macro 1, DYN_MACRO_PLAY2 \u2014 replay the macro 2, DYN_REC_STOP \u2014 finish the macro that is currently being recorded. Add the following code to the very beginning of your process_record_user() function: if (!process_record_dynamic_macro(keycode, record)) { return false; } That should be everything necessary. To start recording the macro, press either DYN_REC_START1 or DYN_REC_START2. To finish the recording, press the DYN_REC_STOP layer button. To replay the macro, press either DYN_MACRO_PLAY1 or DYN_MACRO_PLAY2. Note that it's possible to replay a macro as part of a macro. It's ok to replay macro 2 while recording macro 1 and vice versa but never create recursive macros i.e. macro 1 that replays macro 1. If you do so and the keyboard will get unresponsive, unplug the keyboard and plug it again. For users of the earlier versions of dynamic macros: It is still possible to finish the macro recording using just the layer modifier used to access the dynamic macro keys, without a dedicated DYN_REC_STOP key. If you want this behavior back, use the following snippet instead of the one above: uint16_t macro_kc = (keycode == MO(_DYN) ? DYN_REC_STOP : keycode); if (!process_record_dynamic_macro(macro_kc, record)) { return false; } If the LEDs start blinking during the recording with each keypress, it means there is no more space for the macro in the macro buffer. To fit the macro in, either make the other macro shorter (they share the same buffer) or increase the buffer size by setting the DYNAMIC_MACRO_SIZE preprocessor macro (default value: 128; please read the comments for it in the header). For the details about the internals of the dynamic macros, please read the comments in the dynamic_macro.h header.","tags":"","url":"Features\/Dynamic_Macros.html"},{"title":"Grave Escape","text":"Grave Escape Grave Escape Grave Escape is a feature that allows you to share the grave key (` and ~) on the same key as Escape. When KC_GESC is used it will act as KC_ESC, unless Shift or GUI is pressed, in which case it will act as KC_GRAVE. Key Aliases Description KC_GESC GRAVE_ESC Escape when pressed, ` when Shift or GUI are held There are several possible key combinations this will break, among them Ctrl+Shift+Esc on Windows and Cmd+Opt+Esc on macOS. You can use these options in your config.h to work around this: Option Description GRAVE_ESC_ALT_OVERRIDE Always send Escape if Alt is pressed. GRAVE_ESC_CTRL_OVERRIDE Always send Escape if Ctrl is pressed. GRAVE_ESC_GUI_OVERRIDE Always send Escape if GUI is pressed. GRAVE_ESC_SHIFT_OVERRIDE Always send Escape if SHIFT is pressed.","tags":"","url":"Features\/Grave_Escape.html"},{"title":"Key Lock","text":"Key Lock: Holding Down Keys for You Key Lock: Holding Down Keys for You Sometimes, you need to hold down a specific key for a long period of time. Whether this is while typing in ALL CAPS, or playing a video game that hasn't implemented auto-run, Key Lock is here to help. Key Lock adds a new keycode, KC_LOCK, that will hold down the next key you hit for you. The key is released when you hit it again. Here's an example: let's say you need to type in all caps for a few sentences. You hit KC_LOCK, and then shift. Now, shift will be considered held until you hit it again. You can think of key lock as caps lock, but supercharged. Here's how to use it: Pick a key on your keyboard. This will be the key lock key. Assign it the keycode KC_LOCK. This will be a single-action key: you won't be able to use it for anything else. Enable key lock by including KEY_LOCK_ENABLE = yes in your Makefile. That's it! Important: switching layers does not cancel the key lock. Additionally, key lock is only able to hold standard action keys and One Shot modifier keys (for example, if you have your shift defined as OSM(KC_LSFT); see One Shot Keys). This does not include any of the QMK special functions (except One Shot modifiers), or shifted versions of keys such as KC_LPRN. If it's in the Basic Keycodes list, it can be held. If it's not, then it can't be.","tags":"","url":"Features\/Key_Lock.html"},{"title":"Layouts","text":"Layouts: Using a Keymap with Multiple Keyboards Supporting a Layout Tips for Making Layouts Keyboard-Agnostic Layouts: Using a Keymap with Multiple Keyboards The layouts\/ folder contains different physical key layouts that can apply to different keyboards. layouts\/ + default\/ | + 60_ansi\/ | | + readme.md | | + layout.json | | + a_good_keymap\/ | | | + keymap.c | | | + readme.md | | | + config.h | | | + rules.mk | | + &lt;keymap folder&gt;\/ | | + ... | + &lt;layout folder&gt;\/ + community\/ | + &lt;layout folder&gt;\/ | + ... The layouts\/default\/ and layouts\/community\/ are two examples of layout &quot;repositories&quot; - currently default will contain all of the information concerning the layout, and one default keymap named default_&lt;layout&gt;, for users to use as a reference. community contains all of the community keymaps, with the eventual goal of being split-off into a separate repo for users to clone into layouts\/. QMK searches through all folders in layouts\/, so it's possible to have multiple repositories here. Each layout folder is named ([a-z0-9_]) after the physical aspects of the layout, in the most generic way possible, and contains a readme.md with the layout to be defined by the keyboard: # 60_ansi LAYOUT_60_ansi New names should try to stick to the standards set by existing layouts, and can be discussed in the PR\/Issue. Supporting a Layout For a keyboard to support a layout, the variable must be defined in it's &lt;keyboard&gt;.h, and match the number of arguments\/keys (and preferably the physical layout): #define LAYOUT_60_ansi KEYMAP_ANSI The name of the layout must match this regex: [a-z0-9_]+ The folder name must be added to the keyboard's rules.mk: LAYOUTS = 60_ansi LAYOUTS can be set in any keyboard folder level's rules.mk: LAYOUTS = 60_iso but the LAYOUT_&lt;layout&gt; variable must be defined in &lt;folder&gt;.h as well. Tips for Making Layouts Keyboard-Agnostic Instead of using #include &quot;planck.h&quot;, you can use this line to include whatever &lt;keyboard&gt;.h (&lt;folder&gt;.h should not be included here) file that is being compiled: #include QMK_KEYBOARD_H If you want to keep some keyboard-specific code, you can use these variables to escape it with an #ifdef statement: KEYBOARD_&lt;folder1&gt;_&lt;folder2&gt; For example: #ifdef KEYBOARD_planck #ifdef KEYBOARD_planck_rev4 planck_rev4_function(); #endif #endif Note that the names are lowercase and match the folder\/file names for the keyboard\/revision exactly.","tags":"","url":"Features\/Layouts.html"},{"title":"Leader Key","text":"The Leader Key: A New Kind of Modifier The Leader Key: A New Kind of Modifier If you've ever used Vim, you know what a Leader key is. If not, you're about to discover a wonderful concept. :) Instead of hitting Alt+Shift+W for example (holding down three keys at the same time), what if you could hit a sequence of keys instead? So you'd hit our special modifier (the Leader key), followed by W and then C (just a rapid succession of keys), and something would happen. That's what KC_LEAD does. Here's an example: Pick a key on your keyboard you want to use as the Leader key. Assign it the keycode KC_LEAD. This key would be dedicated just for this -- it's a single action key, can't be used for anything else. Include the line #define LEADER_TIMEOUT 300 somewhere in your keymap.c file, probably near the top. The 300 there is 300ms -- that's how long you have for the sequence of keys following the leader. You can tweak this value for comfort, of course. Within your matrix_scan_user function, do something like this: LEADER_EXTERNS(); void matrix_scan_user(void) { LEADER_DICTIONARY() { leading = false; leader_end(); SEQ_ONE_KEY(KC_F) { register_code(KC_S); unregister_code(KC_S); } SEQ_TWO_KEYS(KC_A, KC_S) { register_code(KC_H); unregister_code(KC_H); } SEQ_THREE_KEYS(KC_A, KC_S, KC_D) { register_code(KC_LGUI); register_code(KC_S); unregister_code(KC_S); unregister_code(KC_LGUI); } } } As you can see, you have three function. you can use - SEQ_ONE_KEY for single-key sequences (Leader followed by just one key), and SEQ_TWO_KEYS and SEQ_THREE_KEYS for longer sequences. Each of these accepts one or more keycodes as arguments. This is an important point: You can use keycodes from any layer on your keyboard. That layer would need to be active for the leader macro to fire, obviously.","tags":"","url":"Features\/Leader_Key.html"},{"title":"Macros","text":"Macros The New Way: SEND_STRING() &amp; process_record_user TAP, DOWN and UP Alternative Keymaps Strings in Memory The Old Way: MACRO() &amp; action_get_macro Macro Commands Mapping a Macro to a Key Naming Your Macros Advanced Macro Functions record-&gt;event.pressed register_code(&lt;kc&gt;); unregister_code(&lt;kc&gt;); clear_keyboard(); clear_mods(); clear_keyboard_but_mods(); Advanced Example: Single-Key Copy\/Paste Macros Macros allow you to send multiple keystrokes when pressing just one key. QMK has a number of ways to define and use macros. These can do anything you want: type common phrases for you, copypasta, repetitive game movements, or even help you code. {% hint style='danger' %} Security Note: While it is possible to use macros to send passwords, credit card numbers, and other sensitive information it is a supremely bad idea to do so. Anyone who gets a hold of your keyboard will be able to access that information by opening a text editor. {% endhint %} The New Way: SEND_STRING() &amp; process_record_user Sometimes you just want a key to type out words or phrases. For the most common situations we've provided SEND_STRING(), which will type out your string (i.e. a sequence of characters) for you. All ASCII characters that are easily translated to a keycode are supported (e.g. \\n\\t). Here is an example keymap.c for a two-key keyboard: enum custom_keycodes { MY_CUSTOM_MACRO = SAFE_RANGE }; bool process_record_user(uint16_t keycode, keyrecord_t *record) { if (record-&gt;event.pressed) { switch(keycode) { case MY_CUSTOM_MACRO: SEND_STRING(&quot;QMK is the best thing ever!&quot;); \/\/ this is our macro! return false; } } return true; }; const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = { [0] = { {MY_CUSTOM_MACRO, KC_ESC} } }; What happens here is this: We first define a new custom keycode in the range not occupied by any other keycodes. Then we use the process_record_user function, which is called whenever a key is pressed or released, to check if our custom keycode has been activated. If yes, we send the string &quot;QMK is the best thing ever!&quot; to the computer via the SEND_STRING macro (this is a C preprocessor macro, not to be confused with QMK macros). We return false to indicate to the caller that the key press we just processed need not be processed any further. Finally, we define the keymap so that the first button activates our macro and the second button is just an escape button. You might want to add more than one macro. You can do that by adding another keycode and adding another case to the switch statement, like so: enum custom_keycodes { MY_CUSTOM_MACRO = SAFE_RANGE, MY_OTHER_MACRO }; bool process_record_user(uint16_t keycode, keyrecord_t *record) { if (record-&gt;event.pressed) { switch(keycode) { case MY_CUSTOM_MACRO: SEND_STRING(&quot;QMK is the best thing ever!&quot;); return false; case MY_OTHER_MACRO: SEND_STRING(SS_LCTRL(&quot;ac&quot;)); \/\/ selects all and copies return false; } } return true; }; const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = { [0] = { {MY_CUSTOM_MACRO, MY_OTHER_MACRO} } }; TAP, DOWN and UP You may want to use keys in your macros that you can't write down, such as Ctrl or Home. You can send arbitrary keycodes by wrapping them in: SS_TAP() presses and releases a key. SS_DOWN() presses (but does not release) a key. SS_UP() releases a key. For example: SEND_STRING(SS_TAP(X_HOME)); Would tap KC_HOME - note how the prefix is now X_, and not KC_. You can also combine this with other strings, like this: SEND_STRING(&quot;VE&quot;SS_TAP(X_HOME)&quot;LO&quot;); Which would send &quot;VE&quot; followed by a KC_HOME tap, and &quot;LO&quot; (spelling &quot;LOVE&quot; if on a newline). There's also a couple of mod shortcuts you can use: SS_LCTRL(string) SS_LGUI(string) SS_LALT(string) SS_LSFT(string) SS_RALT(string) These press the respective modifier, send the supplied string and then release the modifier. They can be used like this: SEND_STRING(SS_LCTRL(&quot;a&quot;)); Which would send LCTRL+a (LCTRL down, a, LCTRL up) - notice that they take strings (eg &quot;k&quot;), and not the X_K keycodes. Alternative Keymaps By default, it assumes a US keymap with a QWERTY layout; if you want to change that (e.g. if your OS uses software Colemak), include this somewhere in your keymap: #include &lt;sendstring_colemak.h&gt; Strings in Memory If for some reason you're manipulating strings and need to print out something you just generated (instead of being a literal, constant string), you can use send_string(), like this: char my_str[4] = &quot;ok.&quot;; send_string(my_str); The shortcuts defined above won't work with send_string(), but you can separate things out to different lines if needed: char my_str[4] = &quot;ok.&quot;; SEND_STRING(&quot;I said: &quot;); send_string(my_str); SEND_STRING(&quot;..&quot;SS_TAP(X_END)); The Old Way: MACRO() &amp; action_get_macro {% hint style='info' %} This is inherited from TMK, and hasn't been updated - it's recommend that you use SEND_STRING and process_record_user instead. {% endhint %} By default QMK assumes you don't have any macros. To define your macros you create an action_get_macro() function. For example: const macro_t *action_get_macro(keyrecord_t *record, uint8_t id, uint8_t opt) { if (record-&gt;event.pressed) { switch(id) { case 0: return MACRO(D(LSFT), T(H), U(LSFT), T(I), D(LSFT), T(1), U(LSFT), END); case 1: return MACRO(D(LSFT), T(B), U(LSFT), T(Y), T(E), D(LSFT), T(1), U(LSFT), END); } } return MACRO_NONE; }; This defines two macros which will be run when the key they are assigned to is pressed. If instead you'd like them to run when the key is released you can change the if statement: if (!record-&gt;event.pressed) { Macro Commands A macro can include the following commands: I() change interval of stroke in milliseconds. D() press key. U() release key. T() type key(press and release). W() wait (milliseconds). END end mark. Mapping a Macro to a Key Use the M() function within your KEYMAP() to call a macro. For example, here is the keymap for a 2-key keyboard: const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = { [0] = KEYMAP( M(0), M(1) ), }; const macro_t *action_get_macro(keyrecord_t *record, uint8_t id, uint8_t opt) { if (record-&gt;event.pressed) { switch(id) { case 0: return MACRO(D(LSFT), T(H), U(LSFT), T(I), D(LSFT), T(1), U(LSFT), END); case 1: return MACRO(D(LSFT), T(B), U(LSFT), T(Y), T(E), D(LSFT), T(1), U(LSFT), END); } } return MACRO_NONE; }; When you press the key on the left it will type &quot;Hi!&quot; and when you press the key on the right it will type &quot;Bye!&quot;. Naming Your Macros If you have a bunch of macros you want to refer to from your keymap while keeping the keymap easily readable you can name them using #define at the top of your file. #define M_HI M(0) #define M_BYE M(1) const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = { [0] = KEYMAP( M_HI, M_BYE ), }; Advanced Macro Functions There are some functions you may find useful in macro-writing. Keep in mind that while you can write some fairly advanced code within a macro if your functionality gets too complex you may want to define a custom keycode instead. Macros are meant to be simple. record-&gt;event.pressed This is a boolean value that can be tested to see if the switch is being pressed or released. An example of this is if (record-&gt;event.pressed) { \/\/ on keydown } else { \/\/ on keyup } register_code(&lt;kc&gt;); This sends the &lt;kc&gt; keydown event to the computer. Some examples would be KC_ESC, KC_C, KC_4, and even modifiers such as KC_LSFT and KC_LGUI. unregister_code(&lt;kc&gt;); Parallel to register_code function, this sends the &lt;kc&gt; keyup event to the computer. If you don't use this, the key will be held down until it's sent. clear_keyboard(); This will clear all mods and keys currently pressed. clear_mods(); This will clear all mods currently pressed. clear_keyboard_but_mods(); This will clear all keys besides the mods currently pressed. Advanced Example: Single-Key Copy\/Paste This example defines a macro which sends Ctrl-C when pressed down, and Ctrl-V when released. const macro_t *action_get_macro(keyrecord_t *record, uint8_t id, uint8_t opt) { switch(id) { case 0: { if (record-&gt;event.pressed) { return MACRO( D(LCTL), T(C), U(LCTL), END ); } else { return MACRO( D(LCTL), T(V), U(LCTL), END ); } break; } } return MACRO_NONE; };","tags":"","url":"Features\/Macros.html"},{"title":"Mouse Keys","text":"Mousekeys Adding Mousekeys to a Keymap Adding Mousekeys Support in the rules.mk Mapping Mouse Actions to Keyboard Keys Configuring the Behavior of Mousekeys MOUSEKEY_DELAY MOUSEKEY_INTERVAL MOUSEKEY_MAX_SPEED MOUSEKEY_TIME_TO_MAX MOUSEKEY_WHEEL_MAX_SPEED MOUSEKEY_WHEEL_TIME_TO_MAX Mousekeys Mousekeys is a feature that allows you to emulate a mouse using your keyboard. You can move the pointer around, click up to 5 buttons, and even scroll in all 4 directions. QMK uses the same algorithm as the X Window System MouseKeysAccel feature. You can read more about it on Wikipedia. Adding Mousekeys to a Keymap There are two steps to adding Mousekeys support to your keyboard. You must enable support in the rules.mk file and you must map mouse actions to keys on your keyboard. Adding Mousekeys Support in the rules.mk To add support for Mousekeys you simply need to add a single line to your keymap's rules.mk: MOUSEKEY_ENABLE = yes You can see an example here: https:\/\/github.com\/qmk\/qmk_firmware\/blob\/master\/keyboards\/clueboard\/66\/keymaps\/mouse_keys\/rules.mk Mapping Mouse Actions to Keyboard Keys You can use these keycodes within your keymap to map button presses to mouse actions: Key Aliases Description KC_MS_UP KC_MS_U Mouse Cursor Up KC_MS_DOWN KC_MS_D Mouse Cursor Down KC_MS_LEFT KC_MS_L Mouse Cursor Left KC_MS_RIGHT KC_MS_R Mouse Cursor Right KC_MS_BTN1 KC_BTN1 Mouse Button 1 KC_MS_BTN2 KC_BTN2 Mouse Button 2 KC_MS_BTN3 KC_BTN3 Mouse Button 3 KC_MS_BTN4 KC_BTN4 Mouse Button 4 KC_MS_BTN5 KC_BTN5 Mouse Button 5 KC_MS_WH_UP KC_WH_U Mouse Wheel Up KC_MS_WH_DOWN KC_WH_D Mouse Wheel Down KC_MS_WH_LEFT KC_WH_L Mouse Wheel Left KC_MS_WH_RIGHT KC_WH_R Mouse Wheel Right KC_MS_ACCEL0 KC_ACL0 Set mouse acceleration to 0 KC_MS_ACCEL1 KC_ACL1 Set mouse acceleration to 1 KC_MS_ACCEL2 KC_ACL2 Set mouse acceleration to 2 You can see an example in the _ML here: https:\/\/github.com\/qmk\/qmk_firmware\/blob\/master\/keyboards\/clueboard\/66\/keymaps\/mouse_keys\/keymap.c#L46 Configuring the Behavior of Mousekeys The default speed for controlling the mouse with the keyboard is intentionally slow. You can adjust these parameters by adding these settings to your keymap's config.h file. All times are specified in milliseconds (ms). #define MOUSEKEY_DELAY 300 #define MOUSEKEY_INTERVAL 50 #define MOUSEKEY_MAX_SPEED 10 #define MOUSEKEY_TIME_TO_MAX 20 #define MOUSEKEY_WHEEL_MAX_SPEED 8 #define MOUSEKEY_WHEEL_TIME_TO_MAX 40 MOUSEKEY_DELAY When one of the mouse movement buttons is pressed this setting is used to define the delay between that button press and the mouse cursor moving. Some people find that small movements are impossible if this setting is too low, while settings that are too high feel sluggish. MOUSEKEY_INTERVAL When a movement key is held down this specifies how long to wait between each movement report. Lower settings will translate into an effectively higher mouse speed. MOUSEKEY_MAX_SPEED As a movement key is held down the speed of the mouse cursor will increase until it reaches MOUSEKEY_MAX_SPEED. MOUSEKEY_TIME_TO_MAX How long you want to hold down a movement key for until MOUSEKEY_MAX_SPEED is reached. This controls how quickly your cursor will accelerate. MOUSEKEY_WHEEL_MAX_SPEED The top speed for scrolling movements. MOUSEKEY_WHEEL_TIME_TO_MAX How long you want to hold down a scroll key for until MOUSEKEY_WHEEL_MAX_SPEED is reached. This controls how quickly your scrolling will accelerate.","tags":"","url":"Features\/Mouse_Keys.html"},{"title":"Pointing Device","text":"Pointing Device Pointing Device Pointing Device is a generic name for a feature intended to be generic: moving the system pointer around. There are certainly other options for it - like mousekeys - but this aims to be easily modifiable and lightweight. You can implement custom keys to control functionality, or you can gather information from other peripherals and insert it directly here - let QMK handle the processing for you. To enable Pointing Device, uncomment the following line in your rules.mk: POINTING_DEVICE_ENABLE = yes To manipulate the mouse report, you can use the following functions: pointing_device_get_report() - Returns the current report_mouse_t that represents the information sent to the host computer pointing_device_set_report(report_mouse_t newMouseReport) - Overrides and saves the report_mouse_t to be sent to the host computer Keep in mind that a report_mouse_t (here &quot;mouseReport&quot;) has the following properties: mouseReport.x - this is a signed int from -127 to 127 (not 128, this is defined in USB HID spec) representing movement (+ to the right, - to the left) on the x axis. mouseReport.y - this is a signed int from -127 to 127 (not 128, this is defined in USB HID spec) representing movement (+ upward, - downward) on the y axis. mouseReport.v - this is a signed int from -127 to 127 (not 128, this is defined in USB HID spec) representing vertical scrolling (+ upward, - downward). mouseReport.h - this is a signed int from -127 to 127 (not 128, this is defined in USB HID spec) representing horizontal scrolling (+ right, - left). mouseReport.buttons - this is a uint8_t in which the last 5 bits are used. These bits represent the mouse button state - bit 3 is mouse button 5, and bit 7 is mouse button 1. When the mouse report is sent, the x, y, v, and h values are set to 0 (this is done in &quot;pointing_device_send()&quot;, which can be overridden to avoid this behavior). This way, button states persist, but movement will only occur once. For further customization, both pointing_device_init and pointing_device_task can be overridden. In the following example, a custom key is used to click the mouse and scroll 127 units vertically and horizontally, then undo all of that when released - because that's a totally useful function. Listen, this is an example: case MS_SPECIAL: report_mouse_t currentReport = pointing_device_get_report(); if (record-&gt;event.pressed) { currentReport.v = 127; currentReport.h = 127; currentReport.buttons |= MOUSE_BTN1; \/\/this is defined in report.h } else { currentReport.v = -127; currentReport.h = -127; currentReport.buttons &amp;= ~MOUSE_BTN1; } pointing_device_set_report(currentReport); break; Recall that the mouse report is set to zero (except the buttons) whenever it is sent, so the scrolling would only occur once in each case.","tags":"","url":"Features\/Pointing_Device.html"},{"title":"PS 2 Mouse","text":"PS\/2 Mouse Support Busywait Version Interrupt Version USART Version Additional Settings PS\/2 Mouse Features Fine Control Scroll Button Invert Mouse and Scroll Axes Debug Settings PS\/2 Mouse Support Its possible to hook up a PS\/2 mouse (for example touchpads or trackpoints) to your keyboard as a composite device. To hook up a Trackpoint, you need to obtain a Trackpoint module (i.e. harvest from a Thinkpad keyboard), identify the function of each pin of the module, and make the necessary circuitry between controller and Trackpoint module. For more information, please refer to Trackpoint Hardware page on Deskthority Wiki. There are three available modes for hooking up PS\/2 devices: USART (best), interrupts (better) or busywait (not recommended). Busywait Version Note: This is not recommended, you may encounter jerky movement or unsent inputs. Please use interrupt or USART version if possible. In rules.mk: PS2_MOUSE_ENABLE = yes PS2_USE_BUSYWAIT = yes In your keyboard config.h: #ifdef PS2_USE_BUSYWAIT # define PS2_CLOCK_PORT PORTD # define PS2_CLOCK_PIN PIND # define PS2_CLOCK_DDR DDRD # define PS2_CLOCK_BIT 1 # define PS2_DATA_PORT PORTD # define PS2_DATA_PIN PIND # define PS2_DATA_DDR DDRD # define PS2_DATA_BIT 2 #endif Interrupt Version The following example uses D2 for clock and D5 for data. You can use any INT or PCINT pin for clock, and any pin for data. In rules.mk: PS2_MOUSE_ENABLE = yes PS2_USE_INT = yes In your keyboard config.h: #ifdef PS2_USE_INT #define PS2_CLOCK_PORT PORTD #define PS2_CLOCK_PIN PIND #define PS2_CLOCK_DDR DDRD #define PS2_CLOCK_BIT 2 #define PS2_DATA_PORT PORTD #define PS2_DATA_PIN PIND #define PS2_DATA_DDR DDRD #define PS2_DATA_BIT 5 #define PS2_INT_INIT() do { \\ EICRA |= ((1&lt;&lt;ISC21) | \\ (0&lt;&lt;ISC20)); \\ } while (0) #define PS2_INT_ON() do { \\ EIMSK |= (1&lt;&lt;INT2); \\ } while (0) #define PS2_INT_OFF() do { \\ EIMSK &amp;= ~(1&lt;&lt;INT2); \\ } while (0) #define PS2_INT_VECT INT2_vect #endif USART Version To use USART on the ATMega32u4, you have to use PD5 for clock and PD2 for data. If one of those are unavailable, you need to use interrupt version. In rules.mk: PS2_MOUSE_ENABLE = yes PS2_USE_USART = yes In your keyboard config.h: #ifdef PS2_USE_USART #define PS2_CLOCK_PORT PORTD #define PS2_CLOCK_PIN PIND #define PS2_CLOCK_DDR DDRD #define PS2_CLOCK_BIT 5 #define PS2_DATA_PORT PORTD #define PS2_DATA_PIN PIND #define PS2_DATA_DDR DDRD #define PS2_DATA_BIT 2 \/* synchronous, odd parity, 1-bit stop, 8-bit data, sample at falling edge *\/ \/* set DDR of CLOCK as input to be slave *\/ #define PS2_USART_INIT() do { \\ PS2_CLOCK_DDR &amp;= ~(1&lt;&lt;PS2_CLOCK_BIT); \\ PS2_DATA_DDR &amp;= ~(1&lt;&lt;PS2_DATA_BIT); \\ UCSR1C = ((1 &lt;&lt; UMSEL10) | \\ (3 &lt;&lt; UPM10) | \\ (0 &lt;&lt; USBS1) | \\ (3 &lt;&lt; UCSZ10) | \\ (0 &lt;&lt; UCPOL1)); \\ UCSR1A = 0; \\ UBRR1H = 0; \\ UBRR1L = 0; \\ } while (0) #define PS2_USART_RX_INT_ON() do { \\ UCSR1B = ((1 &lt;&lt; RXCIE1) | \\ (1 &lt;&lt; RXEN1)); \\ } while (0) #define PS2_USART_RX_POLL_ON() do { \\ UCSR1B = (1 &lt;&lt; RXEN1); \\ } while (0) #define PS2_USART_OFF() do { \\ UCSR1C = 0; \\ UCSR1B &amp;= ~((1 &lt;&lt; RXEN1) | \\ (1 &lt;&lt; TXEN1)); \\ } while (0) #define PS2_USART_RX_READY (UCSR1A &amp; (1&lt;&lt;RXC1)) #define PS2_USART_RX_DATA UDR1 #define PS2_USART_ERROR (UCSR1A &amp; ((1&lt;&lt;FE1) | (1&lt;&lt;DOR1) | (1&lt;&lt;UPE1))) #define PS2_USART_RX_VECT USART1_RX_vect #endif Additional Settings PS\/2 Mouse Features These enable settings supported by the PS\/2 mouse protocol: http:\/\/www.computer-engineering.org\/ps2mouse\/ \/* Use remote mode instead of the default stream mode (see link) *\/ #define PS2_MOUSE_USE_REMOTE_MODE \/* Enable the scrollwheel or scroll gesture on your mouse or touchpad *\/ #define PS2_MOUSE_ENABLE_SCROLLING \/* Some mice will need a scroll mask to be configured. The default is 0xFF. *\/ #define PS2_MOUSE_SCROLL_MASK 0x0F \/* Applies a transformation to the movement before sending to the host (see link) *\/ #define PS2_MOUSE_USE_2_1_SCALING \/* The time to wait after initializing the ps2 host *\/ #define PS2_MOUSE_INIT_DELAY 1000 \/* Default *\/ You can also call the following functions from ps2_mouse.h void ps2_mouse_disable_data_reporting(void); void ps2_mouse_enable_data_reporting(void); void ps2_mouse_set_remote_mode(void); void ps2_mouse_set_stream_mode(void); void ps2_mouse_set_scaling_2_1(void); void ps2_mouse_set_scaling_1_1(void); void ps2_mouse_set_resolution(ps2_mouse_resolution_t resolution); void ps2_mouse_set_sample_rate(ps2_mouse_sample_rate_t sample_rate); Fine Control Use the following defines to change the sensitivity and speed of the mouse. Note: you can also use ps2_mouse_set_resolution for the same effect (not supported on most touchpads). #define PS2_MOUSE_X_MULTIPLIER 3 #define PS2_MOUSE_Y_MULTIPLIER 3 #define PS2_MOUSE_V_MULTIPLIER 1 Scroll Button If you're using a trackpoint, you will likely want to be able to use it for scrolling. Its possible to enable a &quot;scroll button\/s&quot; that when pressed will cause the mouse to scroll instead of moving. To enable the feature, you must set a scroll button mask as follows: #define PS2_MOUSE_SCROLL_BTN_MASK (1&lt;&lt;PS2_MOUSE_BUTTON_MIDDLE) \/* Default *\/ To disable the scroll button feature: #define PS2_MOUSE_SCROLL_BTN_MASK 0 The available buttons are: #define PS2_MOUSE_BTN_LEFT 0 #define PS2_MOUSE_BTN_RIGHT 1 #define PS2_MOUSE_BTN_MIDDLE 2 You can also combine buttons in the mask by |ing them together. Once you've configured your scroll button mask, you must configure the scroll button send interval. This is the interval before which if the scroll buttons were released they would be sent to the host. After this interval, they will cause the mouse to scroll and will not be sent. #define PS2_MOUSE_SCROLL_BTN_SEND 300 \/* Default *\/ To disable sending the scroll buttons: #define PS2_MOUSE_SCROLL_BTN_SEND 0 Fine control over the scrolling is supported with the following defines: #define PS2_MOUSE_SCROLL_DIVISOR_H 2 #define PS2_MOUSE_SCROLL_DIVISOR_V 2 Invert Mouse and Scroll Axes To invert the X and Y axes you can put: #define PS2_MOUSE_INVERT_X #define PS2_MOUSE_INVERT_Y into config.h. To reverse the scroll axes you can put: #define PS2_MOUSE_INVERT_H #define PS2_MOUSE_INVERT_V into config.h. Debug Settings To debug the mouse, add debug_mouse = true or enable via bootmagic. \/* To debug the mouse reports *\/ #define PS2_MOUSE_DEBUG_HID #define PS2_MOUSE_DEBUG_RAW","tags":"","url":"Features\/PS_2_Mouse.html"},{"title":"RGB Lighting","text":"RGB Lighting Selecting Colors Configuration Required Configuration Optional Configuration Animations LED Control RGB Lighting Keycodes Hardware Modification RGB Lighting If you've installed addressable RGB lights on your keyboard you can control them with QMK. Currently we support the following addressable LEDs on Atmel AVR processors: WS2811 and variants (WS2812, WS2812B, WS2812C, etc) SK6812RGBW Some keyboards come with RGB LEDs pre-installed. Others have to have LEDs installed after the fact. See below for information on modifying your keyboard. Selecting Colors QMK uses Hue, Saturation, and Value to set color rather than using RGB. You can use the color wheel below to see how this works. Changing the Hue will cycle around the circle. Saturation will affect the intensity of the color, which you can see as you move from the inner part to the outer part of the wheel. Value sets the overall brightness. If you would like to learn more about HSV you can start with the Wikipedia article. Configuration Before RGB Lighting can be used you have to enable it in rules.mk: RGBLIGHT_ENABLE = yes You can configure the behavior of the RGB lighting by defining values inside config.h. Required Configuration At minimum you have to define the pin your LED strip is connected to and the number of LEDs connected. #define RGB_DI_PIN D7 \/\/ The pin the LED strip is connected to #define RGBLED_NUM 14 \/\/ Number of LEDs in your strip Optional Configuration You can change the behavior of the RGB Lighting by setting these configuration values. Use #define &lt;Option&gt; &lt;Value&gt; in a config.h at the keyboard, revision, or keymap level. Option Default Value Description RGBLIGHT_HUE_STEP 10 How many hues you want to have available. RGBLIGHT_SAT_STEP 17 How many steps of saturation you'd like. RGBLIGHT_VAL_STEP 17 The number of levels of brightness you want. RGBLIGHT_LIMIT_VAL 255 Limit the val of HSV to limit the maximum brightness simply. RGBLIGHT_SLEEP #define this will shut off the lights when the host goes to sleep Animations If you have #define RGBLIGHT_ANIMATIONS in your config.h you will have a number of animation modes you can cycle through using the RGB_MOD key. You can also #define other options to tweak certain animations. Option Default Value Description RGBLIGHT_ANIMATIONS #define this to enable animation modes. RGBLIGHT_EFFECT_BREATHE_CENTER 1.85 Used to calculate the curve for the breathing animation. Valid values 1.0-2.7. RGBLIGHT_EFFECT_BREATHE_MAX 255 The maximum brightness for the breathing mode. Valid values 1-255. RGBLIGHT_EFFECT_SNAKE_LENGTH 4 The number of LEDs to light up for the &quot;snake&quot; animation. RGBLIGHT_EFFECT_KNIGHT_LENGTH 3 The number of LEDs to light up for the &quot;knight&quot; animation. RGBLIGHT_EFFECT_KNIGHT_OFFSET 0 Start the knight animation this many LEDs from the start of the strip. RGBLIGHT_EFFECT_KNIGHT_LED_NUM RGBLED_NUM The number of LEDs to have the &quot;knight&quot; animation travel. RGBLIGHT_EFFECT_CHRISTMAS_INTERVAL 1000 How long to wait between light changes for the &quot;christmas&quot; animation. Specified in ms. RGBLIGHT_EFFECT_CHRISTMAS_STEP 2 How many LED's to group the red\/green colors by for the christmas mode. You can also tweak the behavior of the animations by defining these consts in your keymap.c. These mostly affect the speed different modes animate at. \/\/ How long (in ms) to wait between animation steps for the breathing mode const uint8_t RGBLED_BREATHING_INTERVALS[] PROGMEM = {30, 20, 10, 5}; \/\/ How long (in ms) to wait between animation steps for the rainbow mode const uint8_t RGBLED_RAINBOW_MOOD_INTERVALS[] PROGMEM = {120, 60, 30}; \/\/ How long (in ms) to wait between animation steps for the swirl mode const uint8_t RGBLED_RAINBOW_SWIRL_INTERVALS[] PROGMEM = {100, 50, 20}; \/\/ How long (in ms) to wait between animation steps for the snake mode const uint8_t RGBLED_SNAKE_INTERVALS[] PROGMEM = {100, 50, 20}; \/\/ How long (in ms) to wait between animation steps for the knight modes const uint8_t RGBLED_KNIGHT_INTERVALS[] PROGMEM = {127, 63, 31}; \/\/ These control which colors are selected for the gradient mode const uint16_t RGBLED_GRADIENT_RANGES[] PROGMEM = {360, 240, 180, 120, 90}; LED Control Look in rgblights.h for all available functions, but if you want to control all or some LEDs your goto functions are: rgblight_disable(); \/\/ turn all lights off rgblight_enable(); \/\/ turn lights on, based on their previous state (stored in EEPROM) rgblight_setrgb(r, g, b); \/\/ where r\/g\/b is a number from 0..255. Turns all the LEDs to this color rgblight_sethsv(h, s, v); \/\/ HSV color control - h is a value from 0..360 and s\/v is a value from 0..255 rgblight_setrgb_at(r,g,b, LED); \/\/ control a single LED. 0 &lt;= LED &lt; RGBLED_NUM rgblight_sethsv_at(h,s,v, LED); \/\/ control a single LED. 0 &lt;= LED &lt; RGBLED_NUM You can find a list of predefined colors at quantum\/rgblight_list.h. Free to add to this list! RGB Lighting Keycodes These control the RGB Lighting functionality. Key Aliases Description RGB_TOG Toggle RGB lighting on or off RGB_MODE_FORWARD RGB_MOD Cycle through modes, reverse direction when Shift is held RGB_MODE_REVERSE RGB_RMOD Cycle through modes in reverse, forward direction when Shift is held RGB_HUI Increase hue RGB_HUD Decrease hue RGB_SAI Increase saturation RGB_SAD Decrease saturation RGB_VAI Increase value (brightness) RGB_VAD Decrease value (brightness) RGB_MODE_PLAIN RGB_M_P Static (no animation) mode RGB_MODE_BREATHE RGB_M_B Breathing animation mode RGB_MODE_RAINBOW RGB_M_R Rainbow animation mode RGB_MODE_SWIRL RGB_M_SW Swirl animation mode RGB_MODE_SNAKE RGB_M_SN Snake animation mode RGB_MODE_KNIGHT RGB_M_K &quot;Knight Rider&quot; animation mode RGB_MODE_XMAS RGB_M_X Christmas animation mode RGB_MODE_GRADIENT RGB_M_G Static gradient animation mode note: for backwards compatibility, RGB_SMOD is an alias for RGB_MOD. Hardware Modification Here is a quick demo on Youtube (with NPKC KC60) (https:\/\/www.youtube.com\/watch?v=VKrpPAHlisY). For this mod, you need an unused pin wiring to DI of WS2812 strip. After wiring the VCC, GND, and DI, you can enable the underglow in your Makefile. RGBLIGHT_ENABLE = yes In order to use the underglow animation functions, you need to have #define RGBLIGHT_ANIMATIONS in your config.h. Please add the following options into your config.h, and set them up according your hardware configuration. These settings are for the F4 pin by default: #define RGB_DI_PIN F4 \/\/ The pin your RGB strip is wired to #define RGBLED_NUM 14 \/\/ Number of LEDs You'll need to edit RGB_DI_PIN to the pin you have your DI on your RGB strip wired to.","tags":"","url":"Features\/RGB_Lighting.html"},{"title":"Space Cadet Shift","text":"Space Cadet Shift: The Future, Built In Space Cadet Shift: The Future, Built In Steve Losh described the Space Cadet Shift quite well. Essentially, you hit the left Shift on its own, and you get an opening parenthesis; hit the right Shift on its own, and you get the closing one. When hit with other keys, the Shift key keeps working as it always does. Yes, it's as cool as it sounds. To use it, use KC_LSPO (Left Shift, Parenthesis Open) for your left Shift on your keymap, and KC_RSPC (Right Shift, Parenthesis Close) for your right Shift. It's defaulted to work on US keyboards, but if your layout uses different keys for parenthesis, you can define those in your config.h like this: #define LSPO_KEY KC_9 #define RSPC_KEY KC_0 You can also choose between different rollover behaviors of the shift keys by defining: #define DISABLE_SPACE_CADET_ROLLOVER in your config.h. Disabling rollover allows you to use the opposite shift key to cancel the space cadet state in the event of an erroneous press instead of emitting a pair of parentheses when the keys are released. The only other thing you're going to want to do is create a Makefile in your keymap directory and set the following: COMMAND_ENABLE = no # Commands for debug and configuration This is just to keep the keyboard from going into command mode when you hold both Shift keys at the same time.","tags":"","url":"Features\/Space_Cadet_Shift.html"},{"title":"Space Cadet Shift Enter","text":"Space Cadet Shift Enter: The future, built in Space Cadet Shift Enter: The future, built in Based on the Space Cadet Shift by Steve Losh described Essentially, you hit the Shift on its own, and it acts as the enter key. When hit with other keys, the Shift key keeps working as it always does. Yes, it's as cool as it sounds. This solution works better than using a macro since the timers defined in quantum allow us to tell when another key is pressed, rather than just having a janky timer than results in accidental endlines. To use it, use KC_SFTENT (Shift, Enter) for any Shift on your keymap. It's defaulted to work on US keyboards, but if you'd like to use a different key for Enter, you can define those in your config.h like this: #define SFTENT_KEY KC_ENT The only other thing you're going to want to do is create a rules.mk in your keymap directory and set the following: COMMAND_ENABLE = no # Commands for debug and configuration This is just to keep the keyboard from going into command mode when you hold both Shift keys at the same time. PLEASE NOTE: this feature uses the same timers as the Space Cadet Shift feature, so using them in tandem may produce unwanted results.","tags":"","url":"Features\/Space_Cadet_Shift_Enter.html"},{"title":"Stenography","text":"Stenography in QMK Plover with QWERTY Keyboard Plover with Steno Protocol TX Bolt GeminiPR Configuring QMK for Steno Learning Stenography Interfacing with the code Keycode Reference Stenography in QMK Stenography is a method of writing most often used by court reports, closed-captioning, and real-time transcription for the deaf. In stenography words are chorded syllable by syllable with a mixture of spelling, phonetic, and shortcut (briefs) strokes. Professional stenographers can reach 200-300 WPM without any of the strain usually found in standard typing and with far fewer errors (&gt;99.9% accuracy). The Open Steno Project has built an open-source program called Plover that provides real-time translation of steno strokes into words and commands. It has an established dictionary and supports Plover with QWERTY Keyboard Plover can work with any standard QWERTY keyboard, although it is more efficient if the keyboard supports NKRO (n-key rollover) to allow Plover to see all the pressed keys at once. An example keymap for Plover can be found in planck\/keymaps\/default. Switching to the PLOVER layer adjusts the position of the keyboard to support the number bar. To use Plover with QMK just enable NKRO and optionally adjust your layout if you have anything other than a standard layout. You may also want to purchase some steno-friendly keycaps to make it easier to hit multiple keys. Plover with Steno Protocol Plover also understands the language of several steno machines. QMK can speak a couple of these languages, TX Bolt and GeminiPR. An example layout can be found in planck\/keymaps\/steno. When QMK speaks to Plover over a steno protocol Plover will not use the keyboard as input. This means that you can switch back and forth between a standard keyboard and your steno keyboard, or even switch layers from Plover to standard and back without needing to activate\/deactivate Plover. In this mode Plover expects to speak with a steno machine over a serial port so QMK will present itself to the operating system as a virtual serial port in addition to a keyboard. By default QMK will speak the TX Bolt protocol but can be switched to GeminiPR; the last protocol used is stored in non-volatile memory so QMK will use the same protocol on restart. Note: Due to hardware limitations you may not be able to run both a virtual serial port and mouse emulation at the same time. TX Bolt TX Bolt communicates the status of 24 keys over a very simple protocol in variable-sized (1-5 byte) packets. GeminiPR GeminiPR encodes 42 keys into a 6-byte packet. While TX Bolt contains everything that is necessary for standard stenography, GeminiPR opens up many more options, including supporting non-English theories. Configuring QMK for Steno Firstly, enable steno in your keymap's Makefile. You may also need disable mousekeys, extra keys, or another USB endpoint to prevent conflicts. The builtin USB stack for some processors only supports a certain number of USB endpoints and the virtual serial port needed for steno fills 3 of them. STENO_ENABLE = yes MOUSEKEY_ENABLE = no In your keymap create a new layer for Plover. You will need to include keymap_steno.h. See planck\/keymaps\/steno\/keymap.c for an example. Remember to create a key to switch to the layer as well as a key for exiting the layer. If you would like to switch modes on the fly you can use the keycodes QK_STENO_BOLT and QK_STENO_GEMINI. If you only want to use one of the protocols you may set it up in your initialization function: void matrix_init_user() { steno_set_mode(STENO_MODE_GEMINI); \/\/ or STENO_MODE_BOLT } Once you have your keyboard flashed launch Plover. Click the 'Configure...' button. In the 'Machine' tab select the Stenotype Machine that corresponds to your desired protocol. Click the 'Configure...' button on this tab and enter the serial port or click 'Scan'. Baud rate is fine at 9600 (although you should be able to set as high as 115200 with no issues). Use the default settings for everything else (Data Bits: 8, Stop Bits: 1, Parity: N, no flow control). On the display tab click 'Open stroke display'. With Plover disabled you should be able to hit keys on your keyboard and see them show up in the stroke display window. Use this to make sure you have set up your keymap correctly. You are now ready to steno! Learning Stenography Learn Plover! QWERTY Steno Steno Jig More resources at the Plover Learning Stenography wiki Interfacing with the code The steno code has three interceptible hooks. If you define these functions, they will be called at certain points in processing; if they return true, processing continues, otherwise it's assumed you handled things. bool send_steno_chord_user(steno_mode_t mode, uint8_t chord[6]); This function is called when a chord is about to be sent. Mode will be one of STENO_MODE_BOLT or STENO_MODE_GEMINI. This represents the actual chord that would be sent via whichever protocol. You can modify the chord provided to alter what gets sent. Remember to return true if you want the regular sending process to happen. bool process_steno_user(uint16_t keycode, keyrecord_t *record) { return true; } This function is called when a keypress has come in, before it is processed. The keycode should be one of QK_STENO_BOLT, QK_STENO_GEMINI, or one of the STN_* key values. bool postprocess_steno_user(uint16_t keycode, keyrecord_t *record, steno_mode_t mode, uint8_t chord[6], int8_t pressed); This function is called after a key has been processed, but before any decision about whether or not to send a chord. If IS_PRESSED(record-&gt;event) is false, and pressed is 0 or 1, the chord will be sent shortly, but has not yet been sent. This is where to put hooks for things like, say, live displays of steno chords or keys. Keycode Reference As defined in keymap_steno.h. Note: TX Bolt does not support the full set of keys. The TX Bolt implementation in QMK will map the GeminiPR keys to the nearest TX Bolt key so that one key map will work for both. GeminiPR TX Bolt Steno Key STN_N1 STN_NUM Number bar #1 STN_N2 STN_NUM Number bar #2 STN_N3 STN_NUM Number bar #3 STN_N4 STN_NUM Number bar #4 STN_N5 STN_NUM Number bar #5 STN_N6 STN_NUM Number bar #6 STN_N7 STN_NUM Number bar #7 STN_N8 STN_NUM Number bar #8 STN_N9 STN_NUM Number bar #9 STN_NA STN_NUM Number bar #A STN_NB STN_NUM Number bar #B STN_NC STN_NUM Number bar #C STN_S1 STN_SL S- upper STN_S2 STN_SL S- lower STN_TL STN_TL T- STN_KL STN_KL K- STN_PL STN_PL P- STN_WL STN_WL W- STN_HL STN_HL H- STN_RL STN_RL R- STN_A STN_A A vowel STN_O STN_O O vowel STN_ST1 STN_STR * upper-left STN_ST2 STN_STR * lower-left STN_ST3 STN_STR * upper-right STN_ST4 STN_STR * lower-right STN_E STN_E E vowel STN_U STN_U U vowel STN_FR STN_FR -F STN_PR STN_PR -P STN_RR STN_RR -R STN_BR STN_BR -B STN_LR STN_LR -L STN_GR STN_GR -G STN_TR STN_TR -T STN_SR STN_SR -S STN_DR STN_DR -D STN_ZR STN_ZR -Z STN_FN (GeminiPR only) STN_RES1 (GeminiPR only) STN_RES2 (GeminiPR only) STN_PWR (GeminiPR only)","tags":"","url":"Features\/Stenography.html"},{"title":"Swap Hands","text":"Swap-Hands Action Configuration Swap Keycodes Swap-Hands Action The swap-hands action allows support for one-handed typing without requiring a separate layer. Set SWAP_HANDS_ENABLE in the Makefile and define a hand_swap_config entry in your keymap. Now whenever the ACTION_SWAP_HANDS command key is pressed the keyboard is mirrored. For instance, to type &quot;Hello, World&quot; on QWERTY you would type ^Ge^s^s^w^c W^wr^sd Configuration The configuration table is a simple 2-dimensional array to map from column\/row to new column\/row. Example hand_swap_config for Planck: const keypos_t hand_swap_config[MATRIX_ROWS][MATRIX_COLS] = { {{11, 0}, {10, 0}, {9, 0}, {8, 0}, {7, 0}, {6, 0}, {5, 0}, {4, 0}, {3, 0}, {2, 0}, {1, 0}, {0, 0}}, {{11, 1}, {10, 1}, {9, 1}, {8, 1}, {7, 1}, {6, 1}, {5, 1}, {4, 1}, {3, 1}, {2, 1}, {1, 1}, {0, 1}}, {{11, 2}, {10, 2}, {9, 2}, {8, 2}, {7, 2}, {6, 2}, {5, 2}, {4, 2}, {3, 2}, {2, 2}, {1, 2}, {0, 2}}, {{11, 3}, {10, 3}, {9, 3}, {8, 3}, {7, 3}, {6, 3}, {5, 3}, {4, 3}, {3, 3}, {2, 3}, {1, 3}, {0, 3}}, }; Note that the array indices are reversed same as the matrix and the values are of type keypos_t which is {col, row} and all values are zero-based. In the example above, hand_swap_config[2][4] (third row, fifth column) would return {7, 2} (third row, eighth column). Yes, this is confusing. Swap Keycodes Key Description SH_T(key) Sends key with a tap; momentary swap when held. SW_ON Turns on swapping and leaves it on. SW_OFF Turn off swapping and leaves it off. Good for returning to a known state. SW_MON Swaps hands when pressed, returns to normal when released (momentary). SW_MOFF Momentarily turns off swap. SH_TG Toggles swap on and off with every key press. SH_TT Toggles with a tap; momentary when held.","tags":"","url":"Features\/Swap_Hands.html"},{"title":"Tap Dance","text":"Tap Dance: A Single Key Can Do 3, 5, or 100 Different Things Examples Simple Example Complex Examples Example 1: Send : on Single Tap, ; on Double Tap Example 2: Send &quot;Safety Dance!&quot; After 100 Taps Example 3: Turn LED Lights On Then Off, One at a Time Example 4: 'Quad Function Tap-Dance' Setup In \/qmk_firmware\/users\/&lt;your_name&gt;\/rules.mk In \/qmk_firmware\/users\/&lt;your_name&gt;\/&lt;you_name&gt;.h In \/qmk_firmware\/users\/&lt;your_name&gt;\/&lt;your_name&gt;.c Tap Dance: A Single Key Can Do 3, 5, or 100 Different Things Hit the semicolon key once, send a semicolon. Hit it twice, rapidly -- send a colon. Hit it three times, and your keyboard's LEDs do a wild dance. That's just one example of what Tap Dance can do. It's one of the nicest community-contributed features in the firmware, conceived and created by algernon in #451. Here's how algernon describes the feature: With this feature one can specify keys that behave differently, based on the amount of times they have been tapped, and when interrupted, they get handled before the interrupter. To make it clear how this is different from ACTION_FUNCTION_TAP, lets explore a certain setup! We want one key to send Space on single tap, but Enter on double-tap. With ACTION_FUNCTION_TAP, it is quite a rain-dance to set this up, and has the problem that when the sequence is interrupted, the interrupting key will be send first. Thus, SPC a will result in a SPC being sent, if they are typed within TAPPING_TERM. With the tap dance feature, that'll come out as SPC a, correctly. The implementation hooks into two parts of the system, to achieve this: into process_record_quantum(), and the matrix scan. We need the latter to be able to time out a tap sequence even when a key is not being pressed, so SPC alone will time out and register after TAPPING_TERM time. But lets start with how to use it, first! First, you will need TAP_DANCE_ENABLE=yes in your rules.mk, because the feature is disabled by default. This adds a little less than 1k to the firmware size. Next, you will want to define some tap-dance keys, which is easiest to do with the TD() macro, that - similar to F(), takes a number, which will later be used as an index into the tap_dance_actions array. This array specifies what actions shall be taken when a tap-dance key is in action. Currently, there are three possible options: ACTION_TAP_DANCE_DOUBLE(kc1, kc2): Sends the kc1 keycode when tapped once, kc2 otherwise. When the key is held, the appropriate keycode is registered: kc1 when pressed and held, kc2 when tapped once, then pressed and held. ACTION_TAP_DANCE_FN(fn): Calls the specified function - defined in the user keymap - with the final tap count of the tap dance action. ACTION_TAP_DANCE_FN_ADVANCED(on_each_tap_fn, on_dance_finished_fn, on_dance_reset_fn): Calls the first specified function - defined in the user keymap - on every tap, the second function on when the dance action finishes (like the previous option), and the last function when the tap dance action resets. The first option is enough for a lot of cases, that just want dual roles. For example, ACTION_TAP_DANCE_DOUBLE(KC_SPC, KC_ENT) will result in Space being sent on single-tap, Enter otherwise. And that's the bulk of it! And now, on to the explanation of how it works! The main entry point is process_tap_dance(), called from process_record_quantum(), which is run for every keypress, and our handler gets to run early. This function checks whether the key pressed is a tap-dance key. If it is not, and a tap-dance was in action, we handle that first, and enqueue the newly pressed key. If it is a tap-dance key, then we check if it is the same as the already active one (if there's one active, that is). If it is not, we fire off the old one first, then register the new one. If it was the same, we increment the counter and the timer. This means that you have TAPPING_TERM time to tap the key again, you do not have to input all the taps within that timeframe. This allows for longer tap counts, with minimal impact on responsiveness. Our next stop is matrix_scan_tap_dance(). This handles the timeout of tap-dance keys. For the sake of flexibility, tap-dance actions can be either a pair of keycodes, or a user function. The latter allows one to handle higher tap counts, or do extra things, like blink the LEDs, fiddle with the backlighting, and so on. This is accomplished by using an union, and some clever macros. Examples Simple Example Here's a simple example for a single definition: In your rules.mk, add TAP_DANCE_ENABLE = yes In your config.h (which you can copy from qmk_firmware\/keyboards\/planck\/config.h to your keymap directory), add #define TAPPING_TERM 200 In your keymap.c file, define the variables and definitions, then add to your keymap: \/\/Tap Dance Declarations enum { TD_ESC_CAPS = 0 }; \/\/Tap Dance Definitions qk_tap_dance_action_t tap_dance_actions[] = { \/\/Tap once for Esc, twice for Caps Lock [TD_ESC_CAPS] = ACTION_TAP_DANCE_DOUBLE(KC_ESC, KC_CAPS) \/\/ Other declarations would go here, separated by commas, if you have them }; \/\/In Layer declaration, add tap dance item in place of a key code TD(TD_ESC_CAPS) Complex Examples This section details several complex tap dance examples. All the enums used in the examples are declared like this: \/\/ Enums defined for all examples: enum { CT_SE = 0, CT_CLN, CT_EGG, CT_FLSH, X_TAP_DANCE }; Example 1: Send : on Single Tap, ; on Double Tap void dance_cln_finished (qk_tap_dance_state_t *state, void *user_data) { if (state-&gt;count == 1) { register_code (KC_RSFT); register_code (KC_SCLN); } else { register_code (KC_SCLN); } } void dance_cln_reset (qk_tap_dance_state_t *state, void *user_data) { if (state-&gt;count == 1) { unregister_code (KC_RSFT); unregister_code (KC_SCLN); } else { unregister_code (KC_SCLN); } } \/\/All tap dance functions would go here. Only showing this one. qk_tap_dance_action_t tap_dance_actions[] = { [CT_CLN] = ACTION_TAP_DANCE_FN_ADVANCED (NULL, dance_cln_finished, dance_cln_reset) }; Example 2: Send &quot;Safety Dance!&quot; After 100 Taps void dance_egg (qk_tap_dance_state_t *state, void *user_data) { if (state-&gt;count &gt;= 100) { SEND_STRING (&quot;Safety dance!&quot;); reset_tap_dance (state); } } qk_tap_dance_action_t tap_dance_actions[] = { [CT_EGG] = ACTION_TAP_DANCE_FN (dance_egg) }; Example 3: Turn LED Lights On Then Off, One at a Time \/\/ on each tap, light up one led, from right to left \/\/ on the forth tap, turn them off from right to left void dance_flsh_each(qk_tap_dance_state_t *state, void *user_data) { switch (state-&gt;count) { case 1: ergodox_right_led_3_on(); break; case 2: ergodox_right_led_2_on(); break; case 3: ergodox_right_led_1_on(); break; case 4: ergodox_right_led_3_off(); _delay_ms(50); ergodox_right_led_2_off(); _delay_ms(50); ergodox_right_led_1_off(); } } \/\/ on the fourth tap, set the keyboard on flash state void dance_flsh_finished(qk_tap_dance_state_t *state, void *user_data) { if (state-&gt;count &gt;= 4) { reset_keyboard(); reset_tap_dance(state); } } \/\/ if the flash state didn't happen, then turn off LEDs, left to right void dance_flsh_reset(qk_tap_dance_state_t *state, void *user_data) { ergodox_right_led_1_off(); _delay_ms(50); ergodox_right_led_2_off(); _delay_ms(50); ergodox_right_led_3_off(); } \/\/All tap dances now put together. Example 3 is &quot;CT_FLASH&quot; qk_tap_dance_action_t tap_dance_actions[] = { [CT_SE] = ACTION_TAP_DANCE_DOUBLE (KC_SPC, KC_ENT) ,[CT_CLN] = ACTION_TAP_DANCE_FN_ADVANCED (NULL, dance_cln_finished, dance_cln_reset) ,[CT_EGG] = ACTION_TAP_DANCE_FN (dance_egg) ,[CT_FLSH] = ACTION_TAP_DANCE_FN_ADVANCED (dance_flsh_each, dance_flsh_finished, dance_flsh_reset) }; Example 4: 'Quad Function Tap-Dance' By DanielGGordon Allow one key to have 4 (or more) functions, depending on number of presses, and if the key is held or tapped. Below is a specific example: Tap = Send x Hold = Send Control Double Tap = Send Escape Double Tap and Hold = Send Alt Setup You will need a few things that can be used for 'Quad Function Tap-Dance'. The suggested setup is to create a user directory for yourself. This directory will contain rules.mk &lt;your_name&gt;.c and &lt;your_name&gt;.h. This directory should be called &lt;your_name&gt;, and located in the top level users directory. There should already be a few examples to look at there. In \/qmk_firmware\/users\/&lt;your_name&gt;\/rules.mk Put the following: TAP_DANCE_ENABLE = yes SRC += your_name.c Pretty simple. It is a nice way to keep some rules common on all your keymaps. In \/qmk_firmware\/users\/&lt;your_name&gt;\/&lt;you_name&gt;.h You will need a few things in this file: #ifndef YOUR_NAME #define YOUR_NAME #include &quot;quantum.h&quot; #include &quot;process_keycode\/process_tap_dance.h&quot; typedef struct { bool is_press_action; int state; } xtap; enum { SINGLE_TAP = 1, SINGLE_HOLD = 2, DOUBLE_TAP = 3, DOUBLE_HOLD = 4, DOUBLE_SINGLE_TAP = 5, \/\/send two single taps TRIPLE_TAP = 6, TRIPLE_HOLD = 7 }; \/\/Tap dance enums enum { CTL_X = 0, SOME_OTHER_DANCE } int cur_dance (qk_tap_dance_state_t *state); \/\/for the x tap dance. Put it here so it can be used in any keymap void x_finished (qk_tap_dance_state_t *state, void *user_data); void x_reset (qk_tap_dance_state_t *state, void *user_data); In \/qmk_firmware\/users\/&lt;your_name&gt;\/&lt;your_name&gt;.c And then in your user's .c file you implement the functions above: #include &quot;gordon.h&quot; #include &quot;quantum.h&quot; #include &quot;action.h&quot; #include &quot;process_keycode\/process_tap_dance.h&quot; \/* Return an integer that corresponds to what kind of tap dance should be executed. * * How to figure out tap dance state: interrupted and pressed. * * Interrupted: If the state of a dance dance is &quot;interrupted&quot;, that means that another key has been hit * under the tapping term. This is typically indicitive that you are trying to &quot;tap&quot; the key. * * Pressed: Whether or not the key is still being pressed. If this value is true, that means the tapping term * has ended, but the key is still being pressed down. This generally means the key is being &quot;held&quot;. * * One thing that is currenlty not possible with qmk software in regards to tap dance is to mimic the &quot;permissive hold&quot; * feature. In general, advanced tap dances do not work well if they are used with commonly typed letters. * For example &quot;A&quot;. Tap dances are best used on non-letter keys that are not hit while typing letters. * * Good places to put an advanced tap dance: * z,q,x,j,k,v,b, any function key, home\/end, comma, semi-colon * * Criteria for &quot;good placement&quot; of a tap dance key: * Not a key that is hit frequently in a sentence * Not a key that is used frequently to double tap, for example 'tab' is often double tapped in a terminal, or * in a web form. So 'tab' would be a poor choice for a tap dance. * Letters used in common words as a double. For example 'p' in 'pepper'. If a tap dance function existed on the * letter 'p', the word 'pepper' would be quite frustating to type. * * For the third point, there does exist the 'DOUBLE_SINGLE_TAP', however this is not fully tested * *\/ int cur_dance (qk_tap_dance_state_t *state) { if (state-&gt;count == 1) { if (state-&gt;interrupted || !state-&gt;pressed) return SINGLE_TAP; \/\/key has not been interrupted, but they key is still held. Means you want to send a 'HOLD'. else return SINGLE_HOLD; } else if (state-&gt;count == 2) { \/* * DOUBLE_SINGLE_TAP is to distinguish between typing &quot;pepper&quot;, and actually wanting a double tap * action when hitting 'pp'. Suggested use case for this return value is when you want to send two * keystrokes of the key, and not the 'double tap' action\/macro. *\/ if (state-&gt;interrupted) return DOUBLE_SINGLE_TAP; else if (state-&gt;pressed) return DOUBLE_HOLD; else return DOUBLE_TAP; } \/\/Assumes no one is trying to type the same letter three times (at least not quickly). \/\/If your tap dance key is 'KC_W', and you want to type &quot;www.&quot; quickly - then you will need to add \/\/an exception here to return a 'TRIPLE_SINGLE_TAP', and define that enum just like 'DOUBLE_SINGLE_TAP' if (state-&gt;count == 3) { if (state-&gt;interrupted || !state-&gt;pressed) return TRIPLE_TAP; else return TRIPLE_HOLD; } else return 8; \/\/magic number. At some point this method will expand to work for more presses } \/\/instanalize an instance of 'tap' for the 'x' tap dance. static tap xtap_state = { .is_press_action = true, .state = 0 }; void x_finished (qk_tap_dance_state_t *state, void *user_data) { xtap_state.state = cur_dance(state); switch (xtap_state.state) { case SINGLE_TAP: register_code(KC_X); break; case SINGLE_HOLD: register_code(KC_LCTRL); break; case DOUBLE_TAP: register_code(KC_ESC); break; case DOUBLE_HOLD: register_code(KC_LALT); break; case DOUBLE_SINGLE_TAP: register_code(KC_X); unregister_code(KC_X); register_code(KC_X); \/\/Last case is for fast typing. Assuming your key is `f`: \/\/For example, when typing the word `buffer`, and you want to make sure that you send `ff` and not `Esc`. \/\/In order to type `ff` when typing fast, the next character will have to be hit within the `TAPPING_TERM`, which by default is 200ms. } } void x_reset (qk_tap_dance_state_t *state, void *user_data) { switch (xtap_state.state) { case SINGLE_TAP: unregister_code(KC_X); break; case SINGLE_HOLD: unregister_code(KC_LCTRL); break; case DOUBLE_TAP: unregister_code(KC_ESC); break; case DOUBLE_HOLD: unregister_code(KC_LALT); case DOUBLE_SINGLE_TAP: unregister_code(KC_X); } xtap_state.state = 0; } qk_tap_dance_action_t tap_dance_actions[] = { [X_CTL] = ACTION_TAP_DANCE_FN_ADVANCED(NULL,x_finished, x_reset) }; And then simply use TD(X_CTL) anywhere in your keymap.","tags":"","url":"Features\/Tap_Dance.html"},{"title":"Terminal","text":"Terminal Future Ideas Current Commands about print-buffer flush-buffer help keycode &lt;layer&gt; &lt;row&gt; &lt;col&gt; keymap &lt;layer&gt; exit Terminal This feature is currently huge at 4400 bytes, and should probably only be put on boards with a lot of memory, or for fun. The terminal feature is a command-line-like interface designed to communicate through a text editor with keystrokes. It's beneficial to turn off auto-indent features in your editor. To enable, stick this in your rules.mk or Makefile: TERMINAL_ENABLE = yes And use the TERM_ON and TERM_OFF keycodes to turn it on or off. When enabled, a &gt; prompt will appear, where you'll be able to type, backspace (a bell will ding if you reach the beginning and audio is enabled), and hit enter to send the command. Arrow keys are currently disabled so it doesn't get confused. Moving your cursor around with the mouse is discouraged. #define TERMINAL_HELP enables some other output helpers that aren't really needed with this page. Pressing &quot;up&quot; and &quot;down&quot; will allow you to cycle through the past 5 commands entered. Future Ideas Keyboard\/user-extensible commands Smaller footprint Arrow key support Command history - Done SD card support LCD support for buffer display Keycode -&gt; name string LUT Layer status Analog\/digital port read\/write RGB mode stuff Macro definitions EEPROM read\/write Audio control Current Commands about Prints out the current version of QMK with a build date: &gt; about QMK Firmware v0.5.115-7-g80ed73-dirty Built: 2017-08-29-20:24:44 print-buffer Outputs the last 5 commands entered &gt; print-buffer 0. print-buffer 1. help 2. about 3. keymap 0 4. help 5. flush-buffer flush-buffer Clears command buffer &gt; flush-buffer Buffer cleared! help Prints out the available commands: &gt; help commands available: about help keycode keymap exit print-buffer flush-buffer keycode &lt;layer&gt; &lt;row&gt; &lt;col&gt; Prints out the keycode value of a certain layer, row, and column: &gt; keycode 0 1 0 0x29 (41) keymap &lt;layer&gt; Prints out the entire keymap for a certain layer &gt; keymap 0 0x002b, 0x0014, 0x001a, 0x0008, 0x0015, 0x0017, 0x001c, 0x0018, 0x000c, 0x0012, 0x0013, 0x002a, 0x0029, 0x0004, 0x0016, 0x0007, 0x0009, 0x000a, 0x000b, 0x000d, 0x000e, 0x000f, 0x0033, 0x0034, 0x00e1, 0x001d, 0x001b, 0x0006, 0x0019, 0x0005, 0x0011, 0x0010, 0x0036, 0x0037, 0x0038, 0x0028, 0x5cd6, 0x00e0, 0x00e2, 0x00e3, 0x5cd4, 0x002c, 0x002c, 0x5cd5, 0x0050, 0x0051, 0x0052, 0x004f, &gt; exit Exits the terminal - same as TERM_OFF.","tags":"","url":"Features\/Terminal.html"},{"title":"Thermal Printer","text":"Thermal Printer Thermal Printer Keycodes Thermal Printer Thermal Printer Keycodes Key Description PRINT_ON Start printing everything the user types PRINT_OFF Stop printing everything the user types","tags":"","url":"Features\/Thermal_Printer.html"},{"title":"Unicode","text":"Unicode Support UNICODE_ENABLE UNICODEMAP_ENABLE UCIS_ENABLE Additional Language Support International Characters on Windows Unicode Support There are three Unicode keymap definition method available in QMK: UNICODE_ENABLE Supports Unicode input up to 0xFFFF. The keycode function is UC(n) in keymap file, where n is a 4 digit hexadecimal. UNICODEMAP_ENABLE Supports Unicode up to 0xFFFFFFFF. You need to maintain a separate mapping table const uint32_t PROGMEM unicode_map[] = {...} in your keymap file. The keycode function is X(n) where n is the array index of the mapping table. UCIS_ENABLE TBD Unicode input in QMK works by inputing a sequence of characters to the OS, sort of like macro. Unfortunately, each OS has different ideas on how Unicode is inputted. This is the current list of Unicode input method in QMK: UC_OSX: MacOS Unicode Hex Input support. Works only up to 0xFFFF. Disabled by default. To enable: go to System Preferences -&gt; Keyboard -&gt; Input Sources, and enable Unicode Hex. UC_OSX_RALT: Same as UC_OSX, but sends the Right Alt key for unicode input UC_LNX: Unicode input method under Linux. Works up to 0xFFFFF. Should work almost anywhere on ibus enabled distros. Without ibus, this works under GTK apps, but rarely anywhere else. UC_WIN: (not recommended) Windows built-in Unicode input. To enable: create registry key under HKEY_CURRENT_USER\\Control Panel\\Input Method\\EnableHexNumpad of type REG_SZ called EnableHexNumpad, set its value to 1, and reboot. This method is not recommended because of reliability and compatibility issue, use WinCompose method below instead. UC_WINC: Windows Unicode input using WinCompose. Requires WinCompose. Works reliably under many (all?) variations of Windows. Additional Language Support In quantum\/keymap_extras\/, you'll see various language files - these work the same way as the alternative layout ones do. Most are defined by their two letter country\/language code followed by an underscore and a 4-letter abbreviation of its name. FR_UGRV which will result in a \u00f9 when using a software-implemented AZERTY layout. It's currently difficult to send such characters in just the firmware. International Characters on Windows AutoHotkey allows Windows users to create custom hotkeys among others. The method does not require Unicode support in the keyboard itself but depends instead of AutoHotkey running in the background. First you need to select a modifier combination that is not in use by any of your programs. CtrlAltWin is not used very widely and should therefore be perfect for this. There is a macro defined for a mod-tab combo LCAG_T. Add this mod-tab combo to a key on your keyboard, e.g.: LCAG_T(KC_TAB). This makes the key behave like a tab key if pressed and released immediately but changes it to the modifier if used with another key. In the default script of AutoHotkey you can define custom hotkeys. &lt;^&lt;!&lt;#a::Send, \u00e4 &lt;^&lt;!&lt;#&lt;+a::Send, \u00c4 The hotkeys above are for the combination CtrlAltGui and CtrlAltGuiShift plus the letter a. AutoHotkey inserts the Text right of Send, when this combination is pressed.","tags":"","url":"Features\/Unicode.html"},{"title":"Userspace","text":"Userspace: Sharing Code Between Keymaps Readme Config.h Example Consolidated Macros Override default userspace Userspace: Sharing Code Between Keymaps If you use more than one keyboard with a similar keymap, you might see the benefit in being able to share code between them. Create your own folder in users\/ named the same as your keymap (ideally your github username, &lt;name&gt;) with the following structure: \/users\/&lt;name&gt;\/ (added to the path automatically) readme.md (optional, recommended) rules.mk (included automatically) &lt;name&gt;.h (optional) &lt;name&gt;.c (optional) config.h (optional) &lt;name&gt;.c will need to be added to the SRC in rules.mk like this: SRC += &lt;name&gt;.c Additional files may be added in the same way - it's recommended you have one named &lt;name&gt;.c\/.h though. All this only happens when you build a keymap named &lt;name&gt;, like this: make planck:&lt;name&gt; For example, make planck:jack Will include the \/users\/jack\/ folder in the path, along with \/users\/jack\/rules.mk. Additionally, config.h here will be processed like the same file in your keymap folder. This is handled separately from the &lt;name&gt;.h file. The reason for this, is that &lt;name&gt;.h won't be added in time to add settings (such as #define TAPPING_TERM 100), and including the &lt;name.h&gt; file in any config.h files will result in compile issues. So you should use the config.h for QMK settings, and the &lt;name&gt;.h file for user or keymap specific settings. Readme Please include authorship (your name, github username, email), and optionally a license that's GPL compatible. Config.h If you do add a config,h file, you want to make sure that it only gets processed once. So you may want to start off with something like this: #ifndef USERSPACE_CONFIG_H #define USERSPACE_CONFIG_H \/\/ Put normal config.h settings here: #endif \/\/ !USERSPACE_CONFIG_H You can use any option hre that you could use in your keymap's config.h file. You can find a list of vales here. Example For a brief example, checkout \/users\/_example\/ , or for a more detailed examples check out template.h and template.c in \/users\/drashna\/ . Consolidated Macros If you wanted to consolidate macros and other functions into your userspace for all of your keymaps, you can do that. The issue is that you then cannot call any function defined in your userspace, or it gets complicated. To better handle this, you can call the functions here and create new functions to use in individual keymaps. First, you'd want to go through all of your keymap.c files and replace process_record_user with process_record_keymap instead. This way, you can still use keyboard specific codes on those boards, and use your custom &quot;global&quot; keycodes as well. You'll also want to replace SAFE_RANGE with NEW_SAFE_RANGE so that you wont have any overlapping keycodes Then add #include &lt;name.h&gt; to all of your keymap.c files. This allows you to use these new keycodes without having to redefine them in each keymap. Once you've done that, you'll want to set the keycode definitions that you need to the &lt;name&gt;.h file. For instance: #ifndef USERSPACE #define USERSPACE #include &quot;quantum.h&quot; \/\/ Define all of enum custom_keycodes { KC_MAKE = SAFE_RANGE, NEW_SAFE_RANGE \/\/use &quot;NEW_SAFE_RANGE&quot; for keymap specific codes }; #endif Now you want to create the &lt;name&gt;.c file, and add this content to it: #include &quot;&lt;name&gt;.h&quot; #include &quot;quantum.h&quot; #include &quot;action.h&quot; #include &quot;version.h&quot; __attribute__ ((weak)) bool process_record_keymap(uint16_t keycode, keyrecord_t *record) { return true; } bool process_record_user(uint16_t keycode, keyrecord_t *record) { switch (keycode) { case KC_MAKE: if (!record-&gt;event.pressed) { SEND_STRING(&quot;make &quot; QMK_KEYBOARD &quot;:&quot; QMK_KEYMAP #if (defined(BOOTLOADER_DFU) || defined(BOOTLOADER_LUFA_DFU) || defined(BOOTLOADER_QMK_DFU)) &quot;:dfu &quot; #elif defined(BOOTLOADER_HALFKAY) &quot;:teensy &quot; #elif defined(BOOTLOADER_CATERINA) &quot;:avrdude &quot; #endif SS_TAP(X_ENTER)); } return false; break; } return process_record_keymap(keycode, record); } This will add a new KC_MAKE keycode that can be used in any of your keymaps. And this keycode will output make &lt;keyboard&gt;:&lt;keymap&quot;&gt;, making frequent compiling easier. And this will work with any keyboard and any keymap as it will output the current boards info, so that you don't have to type this out every time. Additionally, this should flash the newly compiled firmware automatically, using the correct utility, based on the bootloader settings (or default to just generating the HEX file). However, it should be noted that this may not work on all systems. AVRDUDE doesn't work on WSL, namely (and will dump the HEX in the &quot;.build&quot; folder instead). Override default userspace By default the userspace used will be the same as the keymap name. In some situations this isn't desirable. For instance, if you use the layout feature you can't use the same name for different keymaps (e.g. ANSI and ISO). You can name your layouts mylayout-ansi and mylayout-iso and add the following line to your layout's rules.mk: USER_NAME := mylayout","tags":"","url":"Features\/Userspace.html"},{"title":"Keycodes","text":"Keycodes Overview Basic Keycodes Mouse Keys Quantum Keycodes Bootmagic Backlighting RGB Lighting Thermal Printer Bluetooth Modifiers Mod-Tap Keys US ANSI Shifted Keys Switching and Toggling Layers One Shot Keys Unicode Support Swap Hands Keycodes Overview When defining a keymap each key needs a valid key definition. This page documents the symbols that correspond to keycodes that are available to you in QMK. This is a reference only. Each group of keys links to the page documenting their functionality in more detail. Basic Keycodes Key Aliases Description KC_1 1 and ! KC_2 2 and @ KC_3 3 and # KC_4 4 and $ KC_5 5 and % KC_6 6 and ^ KC_7 7 and &amp; KC_8 8 and * KC_9 9 and ( KC_0 0 and ) KC_F1 KC_F2 KC_F3 KC_F4 KC_F5 KC_F6 KC_F7 KC_F8 KC_F9 KC_F10 KC_F11 KC_F12 KC_F13 KC_F14 KC_F15 KC_F16 KC_F17 KC_F18 KC_F19 KC_F20 KC_F21 KC_F22 KC_F23 KC_F24 KC_A a and A KC_B b and B KC_C c and C KC_D d and D KC_E e and E KC_F f and F KC_G g and G KC_H h and H KC_I i and I KC_J j and J KC_K k and K KC_L l and L KC_M m and M KC_N n and N KC_O o and O KC_P p and P KC_Q q and Q KC_R r and R KC_S s and S KC_T t and T KC_U u and U KC_V v and V KC_W w and W KC_X x and X KC_Y y and Y KC_Z z and Z KC_ENTER KC_ENT Return (Enter) KC_ESCAPE KC_ESC Escape KC_BSPACE KC_BSPC Delete (Backspace) KC_TAB Tab KC_SPACE KC_SPC Spacebar KC_MINUS KC_MINS - and _ KC_EQUAL KC_EQL = and + KC_LBRACKET KC_LBRC [ and { KC_RBRACKET KC_RBRC ] and } KC_BSLASH KC_BSLS \\ and | KC_NONUS_HASH KC_NUHS Non-US # and ~ KC_NONUS_BSLASH KC_NUBS Non-US \\ and | KC_INT1 KC_RO JIS \\ and | KC_INT2 KC_KANA JIS Katakana\/Hiragana KC_INT3 KC_JYEN JIS \u00a5 KC_SCOLON KC_SCLN ; and : KC_QUOTE KC_QUOT ' and &quot; KC_GRAVE KC_GRV ` and ~ KC_COMMA KC_COMM , and &lt; KC_DOT . and &gt; KC_SLASH KC_SLSH \/ and ? KC_CAPSLOCK KC_CAPS Caps Lock KC_LCTRL KC_LCTL Left Control KC_LSHIFT KC_LSFT Left Shift KC_LALT Left Alt KC_LGUI KC_LCMD, KC_LWIN Left GUI (Windows\/Command\/Meta key) KC_RCTRL KC_RCTL Right Control KC_RSHIFT KC_RSFT Right Shift KC_RALT Right Alt KC_RGUI KC_RCMD, KC_RWIN Right GUI (Windows\/Command\/Meta key) KC_LOCKING_CAPS KC_LCAP Locking Caps Lock KC_LOCKING_NUM KC_LNUM Locking Num Lock KC_LOCKING_SCROLL KC_LSCR Locking Scroll Lock KC_INT4 KC_HENK JIS Henkan KC_INT5 KC_MHEN JIS Muhenkan KC_PSCREEN KC_PSCR Print Screen KC_SCROLLLOCK KC_SLCK Scroll Lock KC_PAUSE KC_PAUS Pause KC_INSERT KC_INS Insert KC_HOME Home KC_PGUP Page Up KC_DELETE KC_DEL Forward Delete KC_END End KC_PGDOWN KC_PGDN Page Down KC_RIGHT KC_RGHT Right Arrow KC_LEFT Left Arrow KC_DOWN Down Arrow KC_UP Up Arrow KC_APPLICATION KC_APP Application (Windows Menu Key) KC_POWER Deprecated by MS in favor of KC_SYSTEM_POWER. KC_EXECUTE Execute KC_HELP Help KC_MENU Menu KC_SELECT Select KC_AGAIN Again KC_UNDO Undo KC_CUT Cut KC_COPY Copy KC_PASTE Paste KC_FIND Find KC_ALT_ERASE Alternate Erase KC_SYSREQ SysReq\/Attention KC_CANCEL Cancel KC_CLEAR Clear KC_PRIOR Prior KC_RETURN Return KC_SEPARATOR Separator KC_OUT Out KC_OPER Oper KC_CLEAR_AGAIN Clear\/Again KC_CRSEL CrSel\/Props KC_EXSEL ExSel KC_SYSTEM_POWER KC_PWR System Power Down. Recommended over KC_POWER. KC_SYSTEM_SLEEP KC_SLEP System Sleep KC_SYSTEM_WAKE KC_WAKE System Wake KC_MAIL KC_MAIL KC_CALCULATOR KC_CALC KC_MY_COMPUTER KC_MYCM KC_WWW_SEARCH KC_WSCH KC_WWW_HOME KC_WHOM KC_WWW_BACK KC_WBAK KC_WWW_FORWARD KC_WFWD KC_WWW_STOP KC_WSTP KC_WWW_REFRESH KC_WREF KC_WWW_FAVORITES KC_WFAV KC_STOP Stop KC__MUTE Mute (macOS) KC__VOLUP Volume Up (macOS) KC__VOLDOWN Volume Down (macOS) KC_AUDIO_MUTE KC_MUTE Mute (Windows\/macOS\/Linux) KC_AUDIO_VOL_UP KC_VOLU Volume Up (Windows\/macOS\/Linux) KC_AUDIO_VOL_DOWN KC_VOLD Volume Down (Windows\/macOS\/Linux) KC_MEDIA_NEXT_TRACK KC_MNXT Next Track (Windows) KC_MEDIA_PREV_TRACK KC_MPRV Previous Track (Windows) KC_MEDIA_FAST_FORWARD KC_MFFD Next Track (macOS) KC_MEDIA_REWIND KC_MRWD Previous Track (macOS) KC_MEDIA_STOP KC_MSTP Stop Track KC_MEDIA_PLAY_PAUSE KC_MPLY Play\/Pause Track KC_MEDIA_SELECT KC_MSEL KC_NUMLOCK KC_NLCK Keypad Num Lock and Clear KC_KP_SLASH KC_PSLS Keypad \/ KC_KP_ASTERISK KC_PAST Keypad * KC_KP_MINUS KC_PMNS Keypad - KC_KP_PLUS KC_PPLS Keypad + KC_KP_ENTER KC_PENT Keypad Enter KC_KP_1 KC_P1 Keypad 1 and End KC_KP_2 KC_P2 Keypad 2 and Down Arrow KC_KP_3 KC_P3 Keypad 3 and Page Down KC_KP_4 KC_P4 Keypad 4 and Left Arrow KC_KP_5 KC_P5 Keypad 5 KC_KP_6 KC_P6 Keypad 6 and Right Arrow KC_KP_7 KC_P7 Keypad 7 and Home KC_KP_8 KC_P8 Keypad 8 and Up Arrow KC_KP_9 KC_P9 Keypad 9 and Page Up KC_KP_0 KC_P0 Keypad 0 and Insert KC_KP_DOT KC_PDOT Keypad . and Delete KC_KP_EQUAL KC_PEQL Keypad = KC_KP_COMMA KC_PCMM Keypad , KC_KP_EQUAL_AS400 Keypad = on AS\/400 keyboards KC_NO Ignore this key (NOOP) KC_TRANSPARENT KC_TRNS Use the next lowest non-transparent key Mouse Keys Key Aliases Description KC_MS_UP KC_MS_U Mouse Cursor Up KC_MS_DOWN KC_MS_D Mouse Cursor Down KC_MS_LEFT KC_MS_L Mouse Cursor Left KC_MS_RIGHT KC_MS_R Mouse Cursor Right KC_MS_BTN1 KC_BTN1 Mouse Button 1 KC_MS_BTN2 KC_BTN2 Mouse Button 2 KC_MS_BTN3 KC_BTN3 Mouse Button 3 KC_MS_BTN4 KC_BTN4 Mouse Button 4 KC_MS_BTN5 KC_BTN5 Mouse Button 5 KC_MS_WH_UP KC_WH_U Mouse Wheel Up KC_MS_WH_DOWN KC_WH_D Mouse Wheel Down KC_MS_WH_LEFT KC_WH_L Mouse Wheel Left KC_MS_WH_RIGHT KC_WH_R Mouse Wheel Right KC_MS_ACCEL0 KC_ACL0 Set mouse acceleration to 0 KC_MS_ACCEL1 KC_ACL1 Set mouse acceleration to 1 KC_MS_ACCEL2 KC_ACL2 Set mouse acceleration to 2 Quantum Keycodes Key Aliases Description RESET Put the keyboard into DFU mode for flashing DEBUG Toggle debug mode KC_GESC GRAVE_ESC Escape when tapped, ` when pressed with Shift or GUI KC_LSPO Left Shift when held, ( when tapped KC_RSPC Right Shift when held, ) when tapped KC_LEAD The Leader key KC_LOCK The Lock key FUNC(n) F(n) Call fn_action(n) (deprecated) M(n) Call macro n MACROTAP(n) Macro-tap n idk FIXME Bootmagic Key Aliases Description MAGIC_SWAP_CONTROL_CAPSLOCK Swap Caps Lock and Left Control MAGIC_CAPSLOCK_TO_CONTROL Treat Caps Lock as Control MAGIC_SWAP_LALT_LGUI Swap Left Alt and GUI MAGIC_SWAP_RALT_RGUI Swap Right Alt and GUI MAGIC_NO_GUI Disable the GUI key MAGIC_SWAP_GRAVE_ESC Swap ` and Escape MAGIC_SWAP_BACKSLASH_BACKSPACE Swap \\ and Backspace MAGIC_HOST_NKRO Force NKRO on MAGIC_SWAP_ALT_GUI AG_SWAP Swap Alt and GUI on both sides MAGIC_UNSWAP_CONTROL_CAPSLOCK Unswap Caps Lock and Left Control MAGIC_UNCAPSLOCK_TO_CONTROL Stop treating Caps Lock as Control MAGIC_UNSWAP_LALT_LGUI Unswap Left Alt and GUI MAGIC_UNSWAP_RALT_RGUI Unswap Right Alt and GUI MAGIC_UNNO_GUI Enable the GUI key MAGIC_UNSWAP_GRAVE_ESC Unswap ` and Escape MAGIC_UNSWAP_BACKSLASH_BACKSPACE Unswap \\ and Backspace MAGIC_UNHOST_NKRO Force NKRO off MAGIC_UNSWAP_ALT_GUI AG_NORM Unswap Alt and GUI on both sides MAGIC_TOGGLE_NKRO Turn NKRO on or off Backlighting Key Description BL_TOGG Turn the backlight on or off BL_STEP Cycle through backlight levels BL_ON Set the backlight to max brightness BL_OFF Turn the backlight off BL_INC Increase the backlight level BL_DEC Decrease the backlight level BL_BRTG Toggle backlight breathing RGB Lighting Key Aliases Description RGB_TOG Toggle RGB lighting on or off RGB_MODE_FORWARD RGB_MOD Cycle through modes, reverse direction when Shift is held RGB_MODE_REVERSE RGB_RMOD Cycle through modes in reverse, forward direction when Shift is held RGB_HUI Increase hue RGB_HUD Decrease hue RGB_SAI Increase saturation RGB_SAD Decrease saturation RGB_VAI Increase value (brightness) RGB_VAD Decrease value (brightness) RGB_MODE_PLAIN RGB_M_P Static (no animation) mode RGB_MODE_BREATHE RGB_M_B Breathing animation mode RGB_MODE_RAINBOW RGB_M_R Rainbow animation mode RGB_MODE_SWIRL RGB_M_SW Swirl animation mode RGB_MODE_SNAKE RGB_M_SN Snake animation mode RGB_MODE_KNIGHT RGB_M_K &quot;Knight Rider&quot; animation mode RGB_MODE_XMAS RGB_M_X Christmas animation mode RGB_MODE_GRADIENT RGB_M_G Static gradient animation mode Thermal Printer Key Description PRINT_ON Start printing everything the user types PRINT_OFF Stop printing everything the user types Bluetooth Key Description OUT_AUTO Automatically switch between USB and Bluetooth OUT_USB USB only OUT_BT Bluetooth only Modifiers Key Aliases Description KC_HYPR Hold Left Control, Shift, Alt and GUI KC_MEH Hold Left Control, Shift and Alt LCTL(kc) Hold Left Control and press kc LSFT(kc) S(kc) Hold Left Shift and press kc LALT(kc) Hold Left Alt and press kc LGUI(kc) LCMD(kc), LWIN(kc) Hold Left GUI and press kc RCTL(kc) Hold Right Control and press kc RSFT(kc) Hold Right Shift and press kc RALT(kc) Hold Right Alt and press kc RGUI(kc) RCMD(kc), LWIN(kc) Hold Right GUI and press kc HYPR(kc) Hold Left Control, Shift, Alt and GUI and press kc MEH(kc) Hold Left Control, Shift and Alt and press kc LCAG(kc) Hold Left Control, Alt and GUI and press kc ALTG(kc) Hold Right Control and Alt and press kc SGUI(kc) SCMD(kc), SWIN(kc) Hold Left Shift and GUI and press kc LCA(kc) Hold Left Control and Alt and press kc Mod-Tap Keys Key Aliases Description LCTL_T(kc) CTL_T(kc) Left Control when held, kc when tapped RCTL_T(kc) Right Control when held, kc when tapped LSFT_T(kc) SFT_T(kc) Left Shift when held, kc when tapped RSFT_T(kc) Right Shift when held, kc when tapped LALT_T(kc) ALT_T(kc) Left Alt when held, kc when tapped RALT_T(kc) ALGR_T(kc) Right Alt when held, kc when tapped LGUI_T(kc) LCMD_T(kc), RWIN_T(kc), GUI_T(kc) Left GUI when held, kc when tapped RGUI_T(kc) RCMD_T(kc), RWIN_T(kc) Right GUI when held, kc when tapped C_S_T(kc) Left Control and Shift when held, kc when tapped MEH_T(kc) Left Control, Shift and Alt when held, kc when tapped LCAG_T(kc) Left Control, Alt and GUI when held, kc when tapped RCAG_T(kc) Right Control, Alt and GUI when held, kc when tapped ALL_T(kc) Left Control, Shift, Alt and GUI when held, kc when tapped - more info here SCMD_T(kc) SWIN_T(kc) Left Shift and GUI when held, kc when tapped LCA_T(kc) Left Control and Alt when held, kc when tapped US ANSI Shifted Keys Key Aliases Description KC_TILDE KC_TILD ~ KC_EXCLAIM KC_EXLM ! KC_AT @ KC_HASH # KC_DOLLAR KC_DLR $ KC_PERCENT KC_PERC % KC_CIRCUMFLEX KC_CIRC ^ KC_AMPERSAND KC_AMPR &amp; KC_ASTERISK KC_ASTR * KC_LEFT_PAREN KC_LPRN ( KC_RIGHT_PAREN KC_RPRN ) KC_UNDERSCORE KC_UNDS _ KC_PLUS + KC_LEFT_CURLY_BRACE KC_LCBR { KC_RIGHT_CURLY_BRACE KC_RCBR } KC_PIPE | KC_COLON KC_COLN : KC_DOUBLE_QUOTE KC_DQT\/KC_DQUO &quot; KC_LEFT_ANGLE_BRACKET KC_LT\/KC_LABK &lt; KC_RIGHT_ANGLE_BRACKET KC_GT\/KC_RABK &gt; KC_QUESTION KC_QUES ? Switching and Toggling Layers Key Description LT(layer, kc) Turn on layer when held, kc when tapped TO(layer) Turn on layer when pressed MO(layer) Momentarily turn on layer when pressed (requires KC_TRNS on destination layer) DF(layer) Set the base (default) layer TG(layer) Toggle layer on or off TT(layer) Normally acts like MO unless it's tapped multiple times, which toggles layer on LM(layer, mod) Momentarily turn on layer (like MO) with mod active as well. One Shot Keys Key Description OSM(mod) Hold mod for one keypress OSL(layer) Switch to layer for one keypress Unicode Support Key Aliases UNICODE(n) UC(n) Send Unicode character n X(n) Send Unicode character n via a different method Swap Hands Key Description SH_T(key) Sends key with a tap; momentary swap when held. SW_ON Turns on swapping and leaves it on. SW_OFF Turn off swapping and leaves it off. Good for returning to a known state. SH_MON Swaps hands when pressed, returns to normal when released (momentary). SH_MOFF Momentarily turns off swap. SH_TG Toggles swap on and off with every key press. SH_TT Toggles with a tap; momentary when held.","tags":"","url":"Keycodes\/index.html"},{"title":"Advanced Keycodes","text":"Advanced Keycodes Assigning Custom Names Limits of These Aliases Switching and Toggling Layers Working with Layers Beginners Intermediate Users Advanced Users Modifier Keys Shifted Keycodes Mod Tap One Shot Keys Permissive Hold Advanced Keycodes Your keymap can include keycodes that are more advanced than normal, for example shifted keys. This page documents the functions that are available to you. Assigning Custom Names People often define custom names using #define. For example: #define FN_CAPS LT(_FL, KC_CAPSLOCK) #define ALT_TAB LALT(KC_TAB) This will allow you to use FN_CAPS and ALT_TAB in your KEYMAP(), keeping it more readable. Limits of These Aliases Currently, the keycodes able to used with these functions are limited to the Basic Keycodes, meaning you can't use keycodes like KC_TILD, or anything greater than 0xFF. For a full list of the keycodes able to be used see Basic Keycodes. Switching and Toggling Layers These functions allow you to activate layers in various ways. Note that layers are not generally independent layouts -- multiple layers can be activated at once, and it's typical for layers to use KC_TRNS to allow keypresses to pass through to lower layers. For a detailed explanation of layers, see Keymap Overview DF(layer) - switches the default layer. The default layer is the always-active base layer that other layers stack on top of. See below for more about the default layer. This might be used to switch from QWERTY to Dvorak layout. (Note that this is a temporary switch that only persists until the keyboard loses power. To modify the default layer in a persistent way requires deeper customization, such as calling the set_single_persistent_default_layer function inside of process_record_user.) MO(layer) - momentarily activates layer. As soon as you let go of the key, the layer is deactivated. LM(layer, mod) - Momentarily activates layer (like MO), but with modifier(s) mod active. Only supports layers 0-15 and the left modifiers. LT(layer, kc) - momentarily activates layer when held, and sends kc when tapped. TG(layer) - toggles layer, activating it if it's inactive and vice versa TO(layer) - activates layer and de-activates all other layers (except your default layer). This function is special, because instead of just adding\/removing one layer to your active layer stack, it will completely replace your current active layers, uniquely allowing you to replace higher layers with a lower one. This is activated on keydown (as soon as the key is pressed). TT(layer) - Layer Tap-Toggle. If you hold the key down, layer is activated, and then is de-activated when you let go (like MO). If you repeatedly tap it, the layer will be toggled on or off (like TG). It needs 5 taps by default, but you can change this by defining TAPPING_TOGGLE -- for example, #define TAPPING_TOGGLE 2 to toggle on just two taps. Working with Layers Care must be taken when switching layers, it's possible to lock yourself into a layer with no way to deactivate that layer (without unplugging your keyboard.) We've created some guidelines to help users avoid the most common problems. Beginners If you are just getting started with QMK you will want to keep everything simple. Follow these guidelines when setting up your layers: Setup layer 0 as your default, &quot;base&quot; layer. This is your normal typing layer, and could be whatever layout you want (qwerty, dvorak, colemak, etc.). It's important to set this as the lowest layer since it will typically have most or all of the keyboard's keys defined, so would block other layers from having any effect if it were above them (i.e., had a higher layer number). Arrange your layers in a &quot;tree&quot; layout, with layer 0 as the root. Do not try to enter the same layer from more than one other layer. In a layer's keymap, only reference higher-numbered layers. Because layers are processed from the highest-numbered (topmost) active layer down, modifying the state of lower layers can be tricky and error-prone. Intermediate Users Sometimes you need more than one base layer. For example, if you want to switch between QWERTY and Dvorak, switch between layouts for different countries, or switch your layout for different videogames. Your base layers should always be the lowest numbered layers. When you have multiple base layers you should always treat them as mutually exclusive. When one base layer is on the others are off. Advanced Users Once you have a good feel for how layers work and what you can do, you can get more creative. The rules listed in the beginner section will help you be successful by avoiding some of the tricker details but they can be constraining, especially for ultra-compact keyboard users. Understanding how layers work will allow you to use them in more advanced ways. Layers stack on top of each other in numerical order. When determining what a keypress does, QMK scans the layers from the top down, stopping when it reaches the first active layer that is not set to KC_TRNS. As a result if you activate a layer that is numerically lower than your current layer, and your current layer (or another layer that is active and higher than your target layer) has something other than KC_TRNS, that is the key that will be sent, not the key on the layer you just activated. This is the cause of most people's &quot;why doesn't my layer get switched&quot; problem. Sometimes, you might want to switch between layers in a macro or as part of a tap dance routine. layer_on activates a layer, and layer_off deactivates it. More layer-related functions can be found in action_layer.h. Modifier Keys These functions allow you to combine a mod with a keycode. When pressed the keydown for the mod will be sent first, and then kc will be sent. When released the keyup for kc will be sent and then the mod will be sent. LSFT(kc) or S(kc) - applies left Shift to kc (keycode) RSFT(kc) - applies right Shift to kc LCTL(kc) - applies left Control to kc RCTL(kc) - applies right Control to kc LALT(kc) - applies left Alt to kc RALT(kc) - applies right Alt to kc LGUI(kc) - applies left GUI (command\/win) to kc RGUI(kc) - applies right GUI (command\/win) to kc HYPR(kc) - applies Hyper (all modifiers) to kc MEH(kc) - applies Meh (all modifiers except Win\/Cmd) to kc LCAG(kc) - applies CtrlAltGui to kc You can also chain these, like this: LALT(LCTL(KC_DEL)) -- this makes a key that sends Alt, Control, and Delete in a single keypress. Shifted Keycodes The following shortcuts automatically add LSFT() to keycodes to get commonly used symbols. Key Aliases Description KC_TILDE KC_TILD ~ KC_EXCLAIM KC_EXLM ! KC_AT @ KC_HASH # KC_DOLLAR KC_DLR $ KC_PERCENT KC_PERC % KC_CIRCUMFLEX KC_CIRC ^ KC_AMPERSAND KC_AMPR &amp; KC_ASTERISK KC_ASTR * KC_LEFT_PAREN KC_LPRN ( KC_RIGHT_PAREN KC_RPRN ) KC_UNDERSCORE KC_UNDS _ KC_PLUS + KC_LEFT_CURLY_BRACE KC_LCBR { KC_RIGHT_CURLY_BRACE KC_RCBR } KC_PIPE | KC_COLON KC_COLN : KC_DOUBLE_QUOTE KC_DQT\/KC_DQUO &quot; KC_LEFT_ANGLE_BRACKET KC_LT\/KC_LABK &lt; KC_RIGHT_ANGLE_BRACKET KC_GT\/KC_RABK &gt; KC_QUESTION KC_QUES ? Mod Tap MT(mod, kc) - is mod (modifier key - MOD_LCTL, MOD_LSFT) when held, and kc when tapped. In other words, you can have a key that sends Esc (or the letter O or whatever) when you tap it, but works as a Control key or a Shift key when you hold it down. These are the values you can use for the mod in MT() and OSM(): MOD_LCTL MOD_LSFT MOD_LALT MOD_LGUI MOD_RCTL MOD_RSFT MOD_RALT MOD_RGUI MOD_HYPR MOD_MEH These can also be combined like MOD_LCTL | MOD_LSFT e.g. MT(MOD_LCTL | MOD_LSFT, KC_ESC) which would activate Control and Shift when held, and send Escape when tapped. We've added shortcuts to make common modifier\/tap (mod-tap) mappings more compact: CTL_T(kc) - is LCTL when held and kc when tapped SFT_T(kc) - is LSFT when held and kc when tapped ALT_T(kc) - is LALT when held and kc when tapped ALGR_T(kc) - is AltGr when held and kc when tapped GUI_T(kc) - is LGUI when held and kc when tapped ALL_T(kc) - is Hyper (all mods) when held and kc when tapped. To read more about what you can do with a Hyper key, see this blog post by Brett Terpstra LCAG_T(kc) - is CtrlAltGui when held and kc when tapped MEH_T(kc) - is like Hyper, but not as cool -- does not include the Cmd\/Win key, so just sends Alt+Ctrl+Shift. {% hint style='info' %} Due to the way that keycodes are structured, any modifiers specified as part of kc, such as LCTL() or KC_LPRN, will only activate when held instead of tapped. Additionally, if there is at least one right modifier, any other modifiers will turn into their right equivalents, so it is not possible to &quot;mix and match&quot; the two. {% endhint %} One Shot Keys One shot keys are keys that remain active until the next key is pressed, and then are released. This allows you to type keyboard combinations without pressing more than one key at a time. These keys are usually called &quot;Sticky keys&quot; or &quot;Dead keys&quot;. For example, if you define a key as OSM(MOD_LSFT), you can type a capital A character by first pressing and releasing shift, and then pressing and releasing A. Your computer will see the shift key being held the moment shift is pressed, and it will see the shift key being released immediately after A is released. One shot keys also work as normal modifiers. If you hold down a one shot key and type other keys, your one shot will be released immediately after you let go of the key. You can control the behavior of one shot keys by defining these in config.h: #define ONESHOT_TAP_TOGGLE 5 \/* Tapping this number of times holds the key until tapped this number of times again. *\/ #define ONESHOT_TIMEOUT 5000 \/* Time (in ms) before the one shot key is released *\/ OSM(mod) - Momentarily hold down mod. You must use the MOD_* keycodes as shown in Mod Tap, not the KC_* codes. OSL(layer) - momentary switch to layer. Sometimes, you want to activate a one-shot layer as part of a macro or tap dance routine. To do this, you need to call set_oneshot_layer(LAYER, ONESHOT_START) on key down, and set_oneshot_layer(ONESHOT_PRESSED) on key up. If you want to cancel the oneshot, call reset_oneshot_layer(). For more complicated actions, take a look at the oneshot implementation in process_record. If you're having issues with OSM translating over Remote Desktop Connection, this can be fixed by opening the settings, going to the &quot;Local Resources&quot; tap, and in the keyboard section, change the drop down to &quot;On this Computer&quot;. This will fix the issue and allow OSM to function properly over Remote Desktop. Permissive Hold As of PR#1359, there is a new config.h option: #define PERMISSIVE_HOLD This makes it easier for fast typists to use dual-function keys. Without this, if you let go of a held key inside the tapping term, it won't register. Example: (Tapping Term = 200ms) SHFT_T(KC_A) Down KC_X Down KC_X Up SHFT_T(KC_A) Up With defaults, if above is typed within tapping term, this will emit ax. With permissive hold, if above is typed within tapping term, this will emit X (so, Shift+X).","tags":"","url":"Keycodes\/Advanced_Keycodes.html"},{"title":"Backlight","text":"Backlighting Backlight Keycodes Configuration Options in config.h Notes on Implementation Backlighting Backlight Keycodes These keycodes control the backlight. Most keyboards use this for single color in-switch lighting. Key Description BL_TOGG Turn the backlight on or off BL_STEP Cycle through backlight levels BL_ON Set the backlight to max brightness BL_OFF Turn the backlight off BL_INC Increase the backlight level BL_DEC Decrease the backlight level BL_BRTG Toggle backlight breathing Note that for backlight breathing, you need to have #define BACKLIGHT_BREATHING in your config.h. Configuration Options in config.h BACKLIGHT_PIN B7 defines the pin that controlls the LEDs. Unless you design your own keyboard, you don't need to set this. BACKLIGHT_LEVELS 3 defines the number of brightness levels (maximum 15 excluding off). BACKLIGHT_BREATHING if defined, enables backlight breathing. Note that this is only available if BACKLIGHT_PIN is B5, B6 or B7. BREATHING_PERIOD 6 defines the length of one backlight &quot;breath&quot; in seconds. Notes on Implementation To change the brightness when using pins B5, B6 or B7, the PWM (Pulse Width Modulation) functionality of the on-chip timer is used. The timer is a counter that counts up to a certain TOP value (0xFFFF set in ICR1) before resetting to 0. We also set an OCR1x register. When the counter reaches the value stored in that register, the PWM pin drops to low. The PWM pin is pulled high again when the counter resets to 0. Therefore, OCR1x basically sets the duty cycle of the LEDs and as such the brightness where 0 is the darkest and 0xFFFF the brightest setting. To enable the breathing effect, we register an interrupt handler to be called whenever the counter resets (with ISR(TIMER1_OVF_vect)). In this handler, which gets called roughly 244 times per second, we compute the desired brightness using a precomputed brightness curve. To disable breathing, we can just disable the respective interrupt vector and reset the brightness to the desired level.","tags":"","url":"Keycodes\/Backlight.html"},{"title":"Basic","text":"Basic Keycodes Letters and Numbers F Keys Punctuation Modifiers Commands Media Keys Number Pad Special Keys Basic Keycodes The basic set of keycodes are based on the HID Keyboard\/Keypad Usage Page (0x07) with the exception of KC_NO, KC_TRNS and keycodes in the 0xA5-DF range. See below for more details. Letters and Numbers Key Description KC_A a and A KC_B b and B KC_C c and C KC_D d and D KC_E e and E KC_F f and F KC_G g and G KC_H h and H KC_I i and I KC_J j and J KC_K k and K KC_L l and L KC_M m and M KC_N n and N KC_O o and O KC_P p and P KC_Q q and Q KC_R r and R KC_S s and S KC_T t and T KC_U u and U KC_V v and V KC_W w and W KC_X x and X KC_Y y and Y KC_Z z and Z KC_1 1 and ! KC_2 2 and @ KC_3 3 and # KC_4 4 and $ KC_5 5 and % KC_6 6 and ^ KC_7 7 and &amp; KC_8 8 and * KC_9 9 and ( KC_0 0 and ) F Keys Key Description KC_F1 KC_F2 KC_F3 KC_F4 KC_F5 KC_F6 KC_F7 KC_F8 KC_F9 KC_F10 KC_F11 KC_F12 KC_F13 KC_F14 KC_F15 KC_F16 KC_F17 KC_F18 KC_F19 KC_F20 KC_F21 KC_F22 KC_F23 KC_F24 Punctuation Key Aliases Description KC_ENTER KC_ENT Return (Enter) KC_ESCAPE KC_ESC Escape KC_BSPACE KC_BSPC Delete (Backspace) KC_TAB Tab KC_SPACE KC_SPC Spacebar KC_MINUS KC_MINS - and _ KC_EQUAL KC_EQL = and + KC_LBRACKET KC_LBRC [ and { KC_RBRACKET KC_RBRC ] and } KC_BSLASH KC_BSLS \\ and | KC_NONUS_HASH KC_NUHS Non-US # and ~ KC_NONUS_BSLASH KC_NUBS Non-US \\ and | KC_INT1 KC_RO JIS \\ and | KC_INT2 KC_KANA JIS Katakana\/Hiragana KC_INT3 KC_JYEN JIS \u00a5 KC_SCOLON KC_SCLN ; and : KC_QUOTE KC_QUOT ' and &quot; KC_GRAVE KC_GRV ` and ~ KC_COMMA KC_COMM , and &lt; KC_DOT . and &gt; KC_SLASH KC_SLSH \/ and ? KC_CAPSLOCK KC_CAPS Caps Lock Modifiers Key Aliases Description KC_LCTRL KC_LCTL Left Control KC_LSHIFT KC_LSFT Left Shift KC_LALT Left Alt KC_LGUI KC_LCMD, KC_LWIN Left GUI (Windows\/Command\/Meta key) KC_RCTRL KC_RCTL Right Control KC_RSHIFT KC_RSFT Right Shift KC_RALT Right Alt KC_RGUI KC_RCMD, KC_RWIN Right GUI (Windows\/Command\/Meta key) KC_LOCKING_CAPS KC_LCAP Locking Caps Lock KC_LOCKING_NUM KC_LNUM Locking Num Lock KC_LOCKING_SCROLL KC_LSCR Locking Scroll Lock KC_INT4 KC_HENK JIS Henkan KC_INT5 KC_MHEN JIS Muhenkan Commands Key Aliases Description KC_PSCREEN KC_PSCR Print Screen KC_SCROLLLOCK KC_SLCK Scroll Lock KC_PAUSE KC_PAUS Pause KC_INSERT KC_INS Insert KC_HOME Home KC_PGUP Page Up KC_DELETE KC_DEL Forward Delete KC_END End KC_PGDOWN KC_PGDN Page Down KC_RIGHT KC_RGHT Right Arrow KC_LEFT Left Arrow KC_DOWN Down Arrow KC_UP Up Arrow KC_APPLICATION KC_APP Application (Windows Menu Key) KC_POWER Power KC_EXECUTE Execute KC_HELP Help KC_MENU Menu KC_SELECT Select KC_AGAIN Again KC_UNDO Undo KC_CUT Cut KC_COPY Copy KC_PASTE Paste KC_FIND Find KC_ALT_ERASE Alternate Erase KC_SYSREQ SysReq\/Attention KC_CANCEL Cancel KC_CLEAR Clear KC_PRIOR Prior KC_RETURN Return KC_SEPARATOR Separator KC_OUT Out KC_OPER Oper KC_CLEAR_AGAIN Clear\/Again KC_CRSEL CrSel\/Props KC_EXSEL ExSel Media Keys These keycodes are not part of the Keyboard\/Keypad usage page. The SYSTEM_ keycodes are found in the Generic Desktop page, and the rest are located in the Consumer page. Windows and macOS use different keycodes for &quot;next track&quot; and &quot;previous track&quot;. Make sure you choose the keycode that corresponds to your OS. Key Aliases Description KC_SYSTEM_POWER KC_PWR System Power Down KC_SYSTEM_SLEEP KC_SLEP System Sleep KC_SYSTEM_WAKE KC_WAKE System Wake KC_MAIL KC_MAIL KC_CALCULATOR KC_CALC KC_MY_COMPUTER KC_MYCM KC_WWW_SEARCH KC_WSCH KC_WWW_HOME KC_WHOM KC_WWW_BACK KC_WBAK KC_WWW_FORWARD KC_WFWD KC_WWW_STOP KC_WSTP KC_WWW_REFRESH KC_WREF KC_STOP Stop KC_WWW_FAVORITES KC_WFAV KC__MUTE Mute (macOS) KC__VOLUP Volume Up (macOS) KC__VOLDOWN Volume Down (macOS) KC_AUDIO_MUTE KC_MUTE Mute (Windows\/macOS\/Linux) KC_AUDIO_VOL_UP KC_VOLU Volume Up (Windows\/macOS\/Linux) KC_AUDIO_VOL_DOWN KC_VOLD Volume Down (Windows\/macOS\/Linux) KC_MEDIA_NEXT_TRACK KC_MNXT Next Track (Windows) KC_MEDIA_PREV_TRACK KC_MPRV Previous Track (Windows) KC_MEDIA_FAST_FORWARD KC_MFFD Next Track (macOS) KC_MEDIA_REWIND KC_MRWD Previous Track (macOS) KC_MEDIA_STOP KC_MSTP Stop Track KC_MEDIA_PLAY_PAUSE KC_MPLY Play\/Pause Track KC_MEDIA_SELECT KC_MSEL Number Pad Key Aliases Description KC_NUMLOCK KC_NLCK Keypad Num Lock and Clear KC_KP_SLASH KC_PSLS Keypad \/ KC_KP_ASTERISK KC_PAST Keypad * KC_KP_MINUS KC_PMNS Keypad - KC_KP_PLUS KC_PPLS Keypad + KC_KP_ENTER KC_PENT Keypad Enter KC_KP_1 KC_P1 Keypad 1 and End KC_KP_2 KC_P2 Keypad 2 and Down Arrow KC_KP_3 KC_P3 Keypad 3 and Page Down KC_KP_4 KC_P4 Keypad 4 and Left Arrow KC_KP_5 KC_P5 Keypad 5 KC_KP_6 KC_P6 Keypad 6 and Right Arrow KC_KP_7 KC_P7 Keypad 7 and Home KC_KP_8 KC_P8 Keypad 8 and Up Arrow KC_KP_9 KC_P9 Keypad 9 and Page Up KC_KP_0 KC_P0 Keypad 0 and Insert KC_KP_DOT KC_PDOT Keypad . and Delete KC_KP_EQUAL KC_PEQL Keypad = KC_KP_COMMA KC_PCMM Keypad , KC_KP_EQUAL_AS400 Keypad = on AS\/400 keyboards Special Keys In addition to these, keycodes in the range of 0xA5-DF are reserved for internal use by TMK. Key Aliases Description KC_NO Ignore this key (NOOP) KC_TRANSPARENT KC_TRNS Use the next lowest non-transparent key","tags":"","url":"Keycodes\/Basic.html"},{"title":"Bluetooth","text":"Bluetooth Bluetooth Functionality Bluetooth Keycodes Bluetooth Bluetooth Functionality This requires some hardware changes, but can be enabled via the Makefile. The firmware will still output characters via USB, so be aware of this when charging via a computer. It would make sense to have a switch on the Bluefruit to turn it off at will. Bluetooth Keycodes This is used when multiple keyboard outputs can be selected. Currently this only allows for switching between USB and Bluetooth on keyboards that support both. Name Description OUT_AUTO Automatically switch between USB and Bluetooth OUT_USB USB only OUT_BT Bluetooth only","tags":"","url":"Keycodes\/Bluetooth.html"},{"title":"Bootmagic","text":"Bootmagic and Magic Keycodes Enabling Bootmagic Bootmagic Hotkeys and Keycodes Bootmagic Configuration Bootmagic and Magic Keycodes There are 3 separate but related features that allow you to change the behavior of your keyboard without reflashing. While each of them have similar functionality you access that functionality in different ways depending on how your keyboard is configured. Bootmagic is a system for configuring your keyboard while it initializes. To trigger a Bootmagic command you hold down the bootmagic key (KC_SPACE on most keyboards) and one or more command keys. Bootmagic Keycodes allow you to access the Bootmagic functionality after your keyboard has initialized. To use Bootmagic Keycodes you assign keycodes starting with MAGIC_, much in the same way you define any other key. Command is a feature that allows you to control different aspects of your keyboard. Command used to be called Magic. Command is typically accessed by holding Left and Right Shift at the same time, although that can be customized. While it shares some functionality with Bootmagic it also allows you to access functionality that Bootmagic does not. For more information see the Command documentation page. Enabling Bootmagic Bootmagic is disabled by default. To use Bootmagic you need to enable it in your rules.mk file: BOOTMAGIC_ENABLE = yes Bootmagic Hotkeys and Keycodes This table describes the default Hotkeys for Bootmagic and the Keycodes for Magic. These may be overriden at the Keyboard or Keymap level. Some functionality is not available in both methods. To use the Hotkey hold down BOOTMAGIC_KEY_SALT (KC_SPACE by default) and the Hotkey while plugging in your keyboard. To use the Keycode assign that keycode to a layer. For example, if you hold down Space+B while plugging in most keyboards, you will enter bootloader mode. Hotkey Keycode Description ESC Skip bootmagic and saved eeprom configuration B RESET Enter bootloader instead of firmware D DEBUG Enable debugging (writes messages to serial) X Enable matrix debugging K Enable keyboard debugging M Enable mouse debugging BACKSPACE Clear the saved settings from flash CAPSLOCK MAGIC_CAPSLOCK_TO_CONTROL Treat Capslock as Control MAGIC_UNCAPSLOCK_TO_CONTROL Stop treating CapsLock as Control LCTRL MAGIC_SWAP_CONTROL_CAPSLOCK Swap Control and Capslock MAGIC_UNSWAP_CONTROL_CAPSLOCK Unswap Left Control and Caps Lock MAGIC_SWAP_ALT_GUI Swap Alt and GUI on both sides MAGIC_UNSWAP_ALT_GUI Unswap Left Alt and GUI LALT MAGIC_SWAP_LALT_LGUI Swap Left Alt and GUI, e.g. for OSX Opt and Cmd MAGIC_UNSWAP_LALT_LGUI Unswap Left Alt and GUI RALT MAGIC_SWAP_RALT_RGUI Swap Right Alt and GUI MAGIC_UNSWAP_RALT_RGUI Unswap Right Alt and GUI LGUI MAGIC_NO_GUI Disable GUI key - e.g. disable Windows key during gaming MAGIC_UNNO_GUI Enable the GUI key GRAVE MAGIC_SWAP_GRAVE_ESC ~ and ESC MAGIC_UNSWAP_GRAVE_ESC ~ and Escape BACKSLASH MAGIC_SWAP_BACKSLASH_BACKSPACE Swap Blackslash and Backspace MAGIC_UNSWAP_BACKSLASH_BACKSPACE Unswap Backslash and Backspace N MAGIC_HOST_NKRO Force N-Key Rollover (NKRO) on MAGIC_UNHOST_NKRO Force NKRO off MAGIC_TOGGLE_NKRO Toggle NKRO on or off 0 DF(0) Make Layer 0 the default layer at bootup 1 DF(1) Make Layer 1 the default layer at bootup 2 DF(2) Make Layer 2 the default layer at bootup 3 DF(3) Make Layer 3 the default layer at bootup 4 DF(4) Make Layer 4 the default layer at bootup 5 DF(5) Make Layer 5 the default layer at bootup 6 DF(6) Make Layer 6 the default layer at bootup 7 DF(7) Make Layer 7 the default layer at bootup Bootmagic Configuration When setting up your keyboard and\/or keymap there are a number of #defines that control the behavior of Bootmagic. To use these put them in your config.h, either at the keyboard or keymap level. Define Default Description BOOTMAGIC_KEY_SALT KC_SPACE The key to hold down to trigger Bootmagic during initialization. BOOTMAGIC_KEY_SKIP KC_ESC The Hotkey to ignore saved eeprom configuration. BOOTMAGIC_KEY_EEPROM_CLEAR KC_BSPACE The hotkey to clear the saved eeprom configuration. BOOTMAGIC_KEY_BOOTLOADER KC_B The hotkey to enter the bootloader. BOOTMAGIC_KEY_DEBUG_ENABLE KC_D The hotkey to enable debug mode. BOOTMAGIC_KEY_DEBUG_MATRIX KC_X The hotkey to enable matrix debugging mode. BOOTMAGIC_KEY_DEBUG_KEYBOARD KC_K The hotkey to enable keyboard debugging mode. BOOTMAGIC_KEY_DEBUG_MOUSE KC_M The hotkey to enable mouse debugging mode. BOOTMAGIC_KEY_SWAP_CONTROL_CAPSLOCK KC_LCTRL BOOTMAGIC_KEY_CAPSLOCK_TO_CONTROL KC_CAPSLOCK BOOTMAGIC_KEY_SWAP_LALT_LGUI KC_LALT BOOTMAGIC_KEY_SWAP_RALT_RGUI KC_RALT BOOTMAGIC_KEY_NO_GUI KC_LGUI BOOTMAGIC_KEY_SWAP_GRAVE_ESC KC_GRAVE BOOTMAGIC_KEY_SWAP_BACKSLASH_BACKSPACE KC_BSLASH BOOTMAGIC_HOST_NKRO KC_N BOOTMAGIC_KEY_DEFAULT_LAYER_0 KC_0 Hotkey to set Layer 0 as the default layer BOOTMAGIC_KEY_DEFAULT_LAYER_1 KC_1 Hotkey to set Layer 1 as the default layer BOOTMAGIC_KEY_DEFAULT_LAYER_2 KC_2 Hotkey to set Layer 2 as the default layer BOOTMAGIC_KEY_DEFAULT_LAYER_3 KC_3 Hotkey to set Layer 3 as the default layer BOOTMAGIC_KEY_DEFAULT_LAYER_4 KC_4 Hotkey to set Layer 4 as the default layer BOOTMAGIC_KEY_DEFAULT_LAYER_5 KC_5 Hotkey to set Layer 5 as the default layer BOOTMAGIC_KEY_DEFAULT_LAYER_6 KC_6 Hotkey to set Layer 6 as the default layer BOOTMAGIC_KEY_DEFAULT_LAYER_7 KC_7 Hotkey to set Layer 7 as the default layer","tags":"","url":"Keycodes\/Bootmagic.html"},{"title":"Quantum Keycodes","text":"Quantum Keycodes QMK Keycodes Quantum Keycodes Quantum keycodes allow for easier customisation of your keymap than the basic ones provide, without having to define custom actions. All keycodes within quantum are numbers between 0x0000 and 0xFFFF. Within your keymap.c it may look like you have functions and other special cases, but ultimately the C preprocessor will translate those into a single 4 byte integer. QMK has reserved 0x0000 through 0x00FF for standard keycodes. These are keycodes such as KC_A, KC_1, and KC_LCTL, which are basic keys defined in the USB HID specification. On this page we have documented keycodes between 0x00FF and 0xFFFF which are used to implement advanced quantum features. If you define your own custom keycodes they will be put into this range as well. QMK Keycodes Key Aliases Description RESET Put the keyboard into DFU mode for flashing DEBUG Toggle debug mode KC_GESC GRAVE_ESC Escape when tapped, ` when pressed with Shift or GUI KC_LSPO Left Shift when held, ( when tapped KC_RSPC Right Shift when held, ) when tapped KC_LEAD The Leader key KC_LOCK The Lock key FUNC(n) F(n) Call fn_action(n) (deprecated) M(n) Call macro n MACROTAP(n) Macro-tap n idk FIXME","tags":"","url":"Keycodes\/Quantum_Keycodes.html"},{"title":"RGB Lighting","text":"RGB Lighting Selecting Colors Configuration Required Configuration Optional Configuration Animations LED Control RGB Lighting Keycodes Hardware Modification RGB Lighting If you've installed addressable RGB lights on your keyboard you can control them with QMK. Currently we support the following addressable LEDs on Atmel AVR processors: WS2811 and variants (WS2812, WS2812B, WS2812C, etc) SK6812RGBW Some keyboards come with RGB LEDs pre-installed. Others have to have LEDs installed after the fact. See below for information on modifying your keyboard. Selecting Colors QMK uses Hue, Saturation, and Value to set color rather than using RGB. You can use the color wheel below to see how this works. Changing the Hue will cycle around the circle. Saturation will affect the intensity of the color, which you can see as you move from the inner part to the outer part of the wheel. Value sets the overall brightness. If you would like to learn more about HSV you can start with the Wikipedia article. Configuration Before RGB Lighting can be used you have to enable it in rules.mk: RGBLIGHT_ENABLE = yes You can configure the behavior of the RGB lighting by defining values inside config.h. Required Configuration At minimum you have to define the pin your LED strip is connected to and the number of LEDs connected. #define RGB_DI_PIN D7 \/\/ The pin the LED strip is connected to #define RGBLED_NUM 14 \/\/ Number of LEDs in your strip Optional Configuration You can change the behavior of the RGB Lighting by setting these configuration values. Use #define &lt;Option&gt; &lt;Value&gt; in a config.h at the keyboard, revision, or keymap level. Option Default Value Description RGBLIGHT_HUE_STEP 10 How many hues you want to have available. RGBLIGHT_SAT_STEP 17 How many steps of saturation you'd like. RGBLIGHT_VAL_STEP 17 The number of levels of brightness you want. RGBLIGHT_LIMIT_VAL 255 Limit the val of HSV to limit the maximum brightness simply. RGBLIGHT_SLEEP #define this will shut off the lights when the host goes to sleep Animations If you have #define RGBLIGHT_ANIMATIONS in your config.h you will have a number of animation modes you can cycle through using the RGB_MOD key. You can also #define other options to tweak certain animations. Option Default Value Description RGBLIGHT_ANIMATIONS #define this to enable animation modes. RGBLIGHT_EFFECT_BREATHE_CENTER 1.85 Used to calculate the curve for the breathing animation. Valid values 1.0-2.7. RGBLIGHT_EFFECT_BREATHE_MAX 255 The maximum brightness for the breathing mode. Valid values 1-255. RGBLIGHT_EFFECT_SNAKE_LENGTH 4 The number of LEDs to light up for the &quot;snake&quot; animation. RGBLIGHT_EFFECT_KNIGHT_LENGTH 3 The number of LEDs to light up for the &quot;knight&quot; animation. RGBLIGHT_EFFECT_KNIGHT_OFFSET 0 Start the knight animation this many LEDs from the start of the strip. RGBLIGHT_EFFECT_KNIGHT_LED_NUM RGBLED_NUM The number of LEDs to have the &quot;knight&quot; animation travel. RGBLIGHT_EFFECT_CHRISTMAS_INTERVAL 1000 How long to wait between light changes for the &quot;christmas&quot; animation. Specified in ms. RGBLIGHT_EFFECT_CHRISTMAS_STEP 2 How many LED's to group the red\/green colors by for the christmas mode. You can also tweak the behavior of the animations by defining these consts in your keymap.c. These mostly affect the speed different modes animate at. \/\/ How long (in ms) to wait between animation steps for the breathing mode const uint8_t RGBLED_BREATHING_INTERVALS[] PROGMEM = {30, 20, 10, 5}; \/\/ How long (in ms) to wait between animation steps for the rainbow mode const uint8_t RGBLED_RAINBOW_MOOD_INTERVALS[] PROGMEM = {120, 60, 30}; \/\/ How long (in ms) to wait between animation steps for the swirl mode const uint8_t RGBLED_RAINBOW_SWIRL_INTERVALS[] PROGMEM = {100, 50, 20}; \/\/ How long (in ms) to wait between animation steps for the snake mode const uint8_t RGBLED_SNAKE_INTERVALS[] PROGMEM = {100, 50, 20}; \/\/ How long (in ms) to wait between animation steps for the knight modes const uint8_t RGBLED_KNIGHT_INTERVALS[] PROGMEM = {127, 63, 31}; \/\/ These control which colors are selected for the gradient mode const uint16_t RGBLED_GRADIENT_RANGES[] PROGMEM = {360, 240, 180, 120, 90}; LED Control Look in rgblights.h for all available functions, but if you want to control all or some LEDs your goto functions are: rgblight_disable(); \/\/ turn all lights off rgblight_enable(); \/\/ turn lights on, based on their previous state (stored in EEPROM) rgblight_setrgb(r, g, b); \/\/ where r\/g\/b is a number from 0..255. Turns all the LEDs to this color rgblight_sethsv(h, s, v); \/\/ HSV color control - h is a value from 0..360 and s\/v is a value from 0..255 rgblight_setrgb_at(r,g,b, LED); \/\/ control a single LED. 0 &lt;= LED &lt; RGBLED_NUM rgblight_sethsv_at(h,s,v, LED); \/\/ control a single LED. 0 &lt;= LED &lt; RGBLED_NUM You can find a list of predefined colors at quantum\/rgblight_list.h. Free to add to this list! RGB Lighting Keycodes These control the RGB Lighting functionality. Key Aliases Description RGB_TOG Toggle RGB lighting on or off RGB_MODE_FORWARD RGB_MOD Cycle through modes, reverse direction when Shift is held RGB_MODE_REVERSE RGB_RMOD Cycle through modes in reverse, forward direction when Shift is held RGB_HUI Increase hue RGB_HUD Decrease hue RGB_SAI Increase saturation RGB_SAD Decrease saturation RGB_VAI Increase value (brightness) RGB_VAD Decrease value (brightness) RGB_MODE_PLAIN RGB_M_P Static (no animation) mode RGB_MODE_BREATHE RGB_M_B Breathing animation mode RGB_MODE_RAINBOW RGB_M_R Rainbow animation mode RGB_MODE_SWIRL RGB_M_SW Swirl animation mode RGB_MODE_SNAKE RGB_M_SN Snake animation mode RGB_MODE_KNIGHT RGB_M_K &quot;Knight Rider&quot; animation mode RGB_MODE_XMAS RGB_M_X Christmas animation mode RGB_MODE_GRADIENT RGB_M_G Static gradient animation mode note: for backwards compatibility, RGB_SMOD is an alias for RGB_MOD. Hardware Modification Here is a quick demo on Youtube (with NPKC KC60) (https:\/\/www.youtube.com\/watch?v=VKrpPAHlisY). For this mod, you need an unused pin wiring to DI of WS2812 strip. After wiring the VCC, GND, and DI, you can enable the underglow in your Makefile. RGBLIGHT_ENABLE = yes In order to use the underglow animation functions, you need to have #define RGBLIGHT_ANIMATIONS in your config.h. Please add the following options into your config.h, and set them up according your hardware configuration. These settings are for the F4 pin by default: #define RGB_DI_PIN F4 \/\/ The pin your RGB strip is wired to #define RGBLED_NUM 14 \/\/ Number of LEDs You'll need to edit RGB_DI_PIN to the pin you have your DI on your RGB strip wired to.","tags":"","url":"Keycodes\/RGB_Lighting.html"},{"title":"Stenography","text":"Stenography in QMK Plover with QWERTY Keyboard Plover with Steno Protocol TX Bolt GeminiPR Configuring QMK for Steno Learning Stenography Interfacing with the code Keycode Reference Stenography in QMK Stenography is a method of writing most often used by court reports, closed-captioning, and real-time transcription for the deaf. In stenography words are chorded syllable by syllable with a mixture of spelling, phonetic, and shortcut (briefs) strokes. Professional stenographers can reach 200-300 WPM without any of the strain usually found in standard typing and with far fewer errors (&gt;99.9% accuracy). The Open Steno Project has built an open-source program called Plover that provides real-time translation of steno strokes into words and commands. It has an established dictionary and supports Plover with QWERTY Keyboard Plover can work with any standard QWERTY keyboard, although it is more efficient if the keyboard supports NKRO (n-key rollover) to allow Plover to see all the pressed keys at once. An example keymap for Plover can be found in planck\/keymaps\/default. Switching to the PLOVER layer adjusts the position of the keyboard to support the number bar. To use Plover with QMK just enable NKRO and optionally adjust your layout if you have anything other than a standard layout. You may also want to purchase some steno-friendly keycaps to make it easier to hit multiple keys. Plover with Steno Protocol Plover also understands the language of several steno machines. QMK can speak a couple of these languages, TX Bolt and GeminiPR. An example layout can be found in planck\/keymaps\/steno. When QMK speaks to Plover over a steno protocol Plover will not use the keyboard as input. This means that you can switch back and forth between a standard keyboard and your steno keyboard, or even switch layers from Plover to standard and back without needing to activate\/deactivate Plover. In this mode Plover expects to speak with a steno machine over a serial port so QMK will present itself to the operating system as a virtual serial port in addition to a keyboard. By default QMK will speak the TX Bolt protocol but can be switched to GeminiPR; the last protocol used is stored in non-volatile memory so QMK will use the same protocol on restart. Note: Due to hardware limitations you may not be able to run both a virtual serial port and mouse emulation at the same time. TX Bolt TX Bolt communicates the status of 24 keys over a very simple protocol in variable-sized (1-5 byte) packets. GeminiPR GeminiPR encodes 42 keys into a 6-byte packet. While TX Bolt contains everything that is necessary for standard stenography, GeminiPR opens up many more options, including supporting non-English theories. Configuring QMK for Steno Firstly, enable steno in your keymap's Makefile. You may also need disable mousekeys, extra keys, or another USB endpoint to prevent conflicts. The builtin USB stack for some processors only supports a certain number of USB endpoints and the virtual serial port needed for steno fills 3 of them. STENO_ENABLE = yes MOUSEKEY_ENABLE = no In your keymap create a new layer for Plover. You will need to include keymap_steno.h. See planck\/keymaps\/steno\/keymap.c for an example. Remember to create a key to switch to the layer as well as a key for exiting the layer. If you would like to switch modes on the fly you can use the keycodes QK_STENO_BOLT and QK_STENO_GEMINI. If you only want to use one of the protocols you may set it up in your initialization function: void matrix_init_user() { steno_set_mode(STENO_MODE_GEMINI); \/\/ or STENO_MODE_BOLT } Once you have your keyboard flashed launch Plover. Click the 'Configure...' button. In the 'Machine' tab select the Stenotype Machine that corresponds to your desired protocol. Click the 'Configure...' button on this tab and enter the serial port or click 'Scan'. Baud rate is fine at 9600 (although you should be able to set as high as 115200 with no issues). Use the default settings for everything else (Data Bits: 8, Stop Bits: 1, Parity: N, no flow control). On the display tab click 'Open stroke display'. With Plover disabled you should be able to hit keys on your keyboard and see them show up in the stroke display window. Use this to make sure you have set up your keymap correctly. You are now ready to steno! Learning Stenography Learn Plover! QWERTY Steno Steno Jig More resources at the Plover Learning Stenography wiki Interfacing with the code The steno code has three interceptible hooks. If you define these functions, they will be called at certain points in processing; if they return true, processing continues, otherwise it's assumed you handled things. bool send_steno_chord_user(steno_mode_t mode, uint8_t chord[6]); This function is called when a chord is about to be sent. Mode will be one of STENO_MODE_BOLT or STENO_MODE_GEMINI. This represents the actual chord that would be sent via whichever protocol. You can modify the chord provided to alter what gets sent. Remember to return true if you want the regular sending process to happen. bool process_steno_user(uint16_t keycode, keyrecord_t *record) { return true; } This function is called when a keypress has come in, before it is processed. The keycode should be one of QK_STENO_BOLT, QK_STENO_GEMINI, or one of the STN_* key values. bool postprocess_steno_user(uint16_t keycode, keyrecord_t *record, steno_mode_t mode, uint8_t chord[6], int8_t pressed); This function is called after a key has been processed, but before any decision about whether or not to send a chord. If IS_PRESSED(record-&gt;event) is false, and pressed is 0 or 1, the chord will be sent shortly, but has not yet been sent. This is where to put hooks for things like, say, live displays of steno chords or keys. Keycode Reference As defined in keymap_steno.h. Note: TX Bolt does not support the full set of keys. The TX Bolt implementation in QMK will map the GeminiPR keys to the nearest TX Bolt key so that one key map will work for both. GeminiPR TX Bolt Steno Key STN_N1 STN_NUM Number bar #1 STN_N2 STN_NUM Number bar #2 STN_N3 STN_NUM Number bar #3 STN_N4 STN_NUM Number bar #4 STN_N5 STN_NUM Number bar #5 STN_N6 STN_NUM Number bar #6 STN_N7 STN_NUM Number bar #7 STN_N8 STN_NUM Number bar #8 STN_N9 STN_NUM Number bar #9 STN_NA STN_NUM Number bar #A STN_NB STN_NUM Number bar #B STN_NC STN_NUM Number bar #C STN_S1 STN_SL S- upper STN_S2 STN_SL S- lower STN_TL STN_TL T- STN_KL STN_KL K- STN_PL STN_PL P- STN_WL STN_WL W- STN_HL STN_HL H- STN_RL STN_RL R- STN_A STN_A A vowel STN_O STN_O O vowel STN_ST1 STN_STR * upper-left STN_ST2 STN_STR * lower-left STN_ST3 STN_STR * upper-right STN_ST4 STN_STR * lower-right STN_E STN_E E vowel STN_U STN_U U vowel STN_FR STN_FR -F STN_PR STN_PR -P STN_RR STN_RR -R STN_BR STN_BR -B STN_LR STN_LR -L STN_GR STN_GR -G STN_TR STN_TR -T STN_SR STN_SR -S STN_DR STN_DR -D STN_ZR STN_ZR -Z STN_FN (GeminiPR only) STN_RES1 (GeminiPR only) STN_RES2 (GeminiPR only) STN_PWR (GeminiPR only)","tags":"","url":"Keycodes\/Stenography.html"},{"title":"Thermal Printer","text":"Thermal Printer Thermal Printer Keycodes Thermal Printer Thermal Printer Keycodes Key Description PRINT_ON Start printing everything the user types PRINT_OFF Stop printing everything the user types","tags":"","url":"Keycodes\/Thermal_Printer.html"},{"title":"US ANSI Shifted keys","text":"US ANSI Shifted Symbols US ANSI Shifted Keycodes US ANSI Shifted Symbols These keycodes correspond to characters that are &quot;shifted&quot; on a standard US ANSI keyboards. They do not have dedicated keycodes but are instead typed by holding down shift and then sending a keycode. It's important to remember that all of these keycodes send a left shift - this may cause unintended actions if unaccounted for. The short code is preferred in most situations. US ANSI Shifted Keycodes Key Aliases Description KC_TILDE KC_TILD ~ KC_EXCLAIM KC_EXLM ! KC_AT @ KC_HASH # KC_DOLLAR KC_DLR $ KC_PERCENT KC_PERC % KC_CIRCUMFLEX KC_CIRC ^ KC_AMPERSAND KC_AMPR &amp; KC_ASTERISK KC_ASTR * KC_LEFT_PAREN KC_LPRN ( KC_RIGHT_PAREN KC_RPRN ) KC_UNDERSCORE KC_UNDS _ KC_PLUS + KC_LEFT_CURLY_BRACE KC_LCBR { KC_RIGHT_CURLY_BRACE KC_RCBR } KC_PIPE | KC_COLON KC_COLN : KC_DOUBLE_QUOTE KC_DQT\/KC_DQUO &quot; KC_LEFT_ANGLE_BRACKET KC_LT\/KC_LABK &lt; KC_RIGHT_ANGLE_BRACKET KC_GT\/KC_RABK &gt; KC_QUESTION KC_QUES ?","tags":"","url":"Keycodes\/US_ANSI_Shifted_keys.html"},{"title":"Reference","text":"Keyboard Guidelines Compatable Microcontrollers Config Options Custom Code Documentation Best Practices Documentation Templates Glossary Keymap Overview Unit Testing","tags":"","url":"Reference\/index.html"},{"title":"Keyboard Guidelines","text":"QMK Keyboard Guidelines Naming Your Keyboard\/Project readme.md Image\/Hardware Files Keyboard Defaults Bootmagic and Command Custom Keyboard Programming Keyboard Metadata info.json Format Layout Format Key Dictionary Format How is the Metadata Exposed? Non-Production\/Handwired Projects Warnings as Errors Copyright Blurb License Technical Details QMK Keyboard Guidelines We welcome all keyboard projects into QMK, but ask that you try to stick to a couple guidelines that help us keep things organised and consistent. Naming Your Keyboard\/Project All names should be lowercase alphanumeric, and separated by an underscore (_), but not begin with one. Your directory and your .h and .c files should have exactly the same name. All folders should follow the same format. test, keyboard, and all are reserved by make and are not a valid name for a keyboard. readme.md All projects need to have a readme.md file that explains what the keyboard is, who made it, where it is available, and links to more information. Please follow the published template. Image\/Hardware Files In an effort to keep the repo size down, we're no longer accepting images of any format in the repo, with few exceptions. Hosting them elsewhere (imgur) and linking them in the readme.md is the preferred method. Any sort of hardware file (plate, case, pcb) can't be stored in qmk_firmware, but we have the qmk.fm repo where such files (as well as in-depth info) can be stored and viewed on qmk.fm. Downloadable files are stored in \/&lt;keyboard&gt;\/ (name follows the same format as above) which are served at http:\/\/qmk.fm\/&lt;keyboard&gt;\/, and pages are generated from \/_pages\/&lt;keyboard&gt;\/ which are served at the same location (.md files are generated into .html files through Jekyll). Check out the lets_split directory for an example. Keyboard Defaults Given the amount of functionality that QMK exposes it's very easy to confuse new users. When putting together the default firmware for your keyboard we recommend limiting your enabled features and options to the minimal set needed to support your hardware. Recommendations for specific features follow. Bootmagic and Command Bootmagic and Command are two related features that allow a user to control their keyboard in non-obvious ways. We recommend you think long and hard about if you're going to enable either feature, and how you will expose this functionality. Keep in mind that users who want this functionality can enable it in their personal keymaps without affecting all the novice users who may be using your keyboard as their first programmable board. By far the most common problem new users encounter is accidentally triggering Bootmagic while they're plugging in their keyboard. They're holding the keyboard by the bottom, unknowingly pressing in alt and spacebar, and then they find that these keys have been swapped on them. We recommend leaving this feature disabled by default, but if you do turn it on consider setting BOOTMAGIC_KEY_SALT to a key that is hard to press while plugging your keyboard in. If your keyboard does not have 2 shift keys you should provide a working default for IS_COMMAND, even when you have set COMMAND_ENABLE = no. This will give your users a default to conform to if they do enable Command. Custom Keyboard Programming As documented on Customizing Functionality you can define custom functions for your keyboard. Please keep in mind that your users may want to customize that behavior as well, and make it possible for them to do that. If you are providing a custom function, for example process_record_kb(), make sure that your function calls the _user() version of the call too. You should also take into account the return value of the _user() version, and only run your custom code if the user returns true. Keyboard Metadata As QMK grows so does the ecosystem surrounding QMK. To make it easier for projects in that ecosystem to tie into QMK as we make changes we are developing a metadata system to expose information about keyboards in QMK. You can create info.json files at every level under qmk_firmware\/keyboards\/&lt;name&gt; to specify this metadata. These files are combined, with more specific files overriding keys in less specific files. This means you do not need to duplicate your metadata information. For example, qmk_firmware\/keyboards\/clueboard\/info.json specifies manufacturer and maintainer, while qmk_firmware\/keyboards\/clueboard\/66\/info.json specifies more specific information about Clueboard 66%. info.json Format The info.json file is a JSON formatted dictionary with the following keys available to be set. You do not have to set all of them, merely the keys that apply to your keyboard. keyboard_name A free-form text string describing the keyboard. Example: Clueboard 66% url A URL to the keyboard's product page, QMK.fm\/keyboards page, or other page describing information about the keyboard. bootloader What bootloader this keyboard uses. Available options: atmel-dfu kiibohd-dfu-util lufa-dfu qmk-dfu stm32-dfu-util caterina halfkay bootloadHID maintainer GitHub username of the maintainer, or qmk for community maintained boards width Width of the board in Key Units height Height of the board in Key Units layouts Physical Layout representations. See the next section for more detail. Layout Format Within our info.json file the layouts portion of the dictionary contains several nested dictionaries. The outer layer consists of QMK layout macros, for example LAYOUT_ansi or LAYOUT_iso. Within each layout macro are keys for width, height, and key_count, each of which should be self-explanatory. width Optional: The width of the layout in Key Units height Optional: The height of the layout in Key Units key_count Required: The number of keys in this layout layout A list of Key Dictionaries describing the physical layout. See the next section for more details. Key Dictionary Format Each Key Dictionary in a layout describes the physical properties of a key. If you are familiar with the Raw Code for http:\/\/keyboard-layout-editor.com you will find many of the concepts the same. We re-use the same key names and layout choices wherever possible, but unlike keyboard-layout-editor each key is stateless, inheriting no properties from the keys that came before it. All key positions and rotations are specified in relation to the top-left corner of the keyboard, and the top-left corner of each key. X Required: The absolute position of the key in the horizontal axis, in Key Units. Y Required: The absolute position of the key in the vertical axis, in Key Units. W The width of the key, in Key Units. Ignored if ks is provided. Default: 1 H The height of the key, in Key Units. Ignored if ks is provided. Default: 1 R How many degrees clockwise to rotate the key. RX The absolute position of the point to rotate the key around in the horizontal axis. Default: x RY The absolute position of the point to rotate the key around in the vertical axis. Default: y KS Key Shape: define a polygon by providing a list of points, in Key Units. Important: These are relative to the top-left of the key, not absolute. Example ISO Enter: [ [0,0], [1.5,0], [1.5,2], [0.25,2], [0.25,1], [0,1], [0,0] ] How is the Metadata Exposed? This metadata is primarily used in two ways: To allow web-based configurators to dynamically generate UI To support the new make keyboard:keymap:qmk target, which bundles this metadata up with the firmware to allow QMK Toolbox to be smarter. Configurator authors can see the QMK Compiler docs for more information on using the JSON API. Non-Production\/Handwired Projects We're happy to accept any project that uses QMK, including prototypes and handwired ones, but we have a separate \/keyboards\/handwired\/ folder for them, so the main \/keyboards\/ folder doesn't get overcrowded. If a prototype project becomes a production project at some point in the future, we'd be happy to move it to the main \/keyboards\/ folder! Warnings as Errors When developing your keyboard, keep in mind that all warnings will be treated as errors - these small warnings can build-up and cause larger errors down the road (and keeping them is generally a bad practice). Copyright Blurb If you're adapting your keyboard's setup from another project, but not using the same code, but sure to update the copyright header at the top of the files to show your name, in this format: Copyright 2017 Your Name &lt;your@email.com&gt; If you are modifying someone else's code and have made only trivial changes you should leave their name in the copyright statement. If you have done significant work on the file you should add your name to theirs, like so: Copyright 2017 Their Name &lt;original_author@example.com&gt; Your Name &lt;you@example.com&gt; The year should be the first year the file is created. If work was done to that file in later years you can reflect that by appending the second year to the first, like so: Copyright 2015-2017 Your Name &lt;you@example.com&gt; License The core of QMK is licensed under the GNU General Public License. If you are shipping binaries for AVR processors you may choose either GPLv2 or GPLv3. If you are shipping binaries for ARM processors you must choose GPL Version 3 to comply with the ChibiOS GPLv3 license. If your keyboard makes use of the uGFX features within QMK you must comply with the uGFX License, which requires a separate commercial license before selling a device containing uGFX. Technical Details If you're looking for more information on making your keyboard work with QMK, check out the hardware section!","tags":"","url":"Reference\/Keyboard_Guidelines.html"},{"title":"Compatable Microcontrollers","text":"Atmel AVR ARM Atmel AVR QMK should run on any Atmel AVR processor with enough Flash. It has been tested on the following: ATmega32U4 (PJRC Teensy 2.0) AT90USB1286 (PJRC Teensy++ 2.0) AT90USB1287 (Atmel USBKEY) ATmega168P with using V-USB ATmega328P with using V-USB ATmega32U2 AT90USB1286, 646, 647 should work AT90USB162 testing... NOTE: To enable full features of firmware you'll need 32KB flash size. Please add any tested microcontrollers to this list. ARM You can also use any ARM processor that ChibiOS supports. The following processors have been tested: Kinetis MKL26Z64 Kinetis MK20DX128 Kinetis MK20DX128 Kinetis MK20DX256","tags":"","url":"Reference\/Compatable_Microcontrollers.html"},{"title":"Config Options","text":"Configuring QMK QMK Default Keyboard Folders Keymap The config.h File Hardware Options Features That Can Be Disabled Features That Can Be Enabled Behaviors That Can Be Configured RGB Light Configuration Mouse Key Options The rules.mk File Build Options AVR MCU Options Feature Options Configuring QMK QMK is nearly infinitely configurable. Wherever possible we err on the side of allowing users to customize their keyboard, even at the expense of code size. That level of flexibility makes for a daunting configuration experience, however. There are two main types of configuration files in QMK- config.h and rules.mk. These files exist at various levels in QMK and all files of the same type are combined to build the final configuration. The levels, from lowest priority to highest priority, are: QMK Default Keyboard Folders (Up to 5 levels deep) Keymap QMK Default Every available setting in QMK has a default. If that setting is not set at the Keyboard, Folder, or Keymap level this is the setting that will be used. Keyboard This level contains config options that should apply to the whole keyboard. Some settings won't change in revisions, or most keymaps. Other settings are merely defaults for this keyboard and can be overridden by folders and\/or keymaps. Folders Some keyboards have folders and sub-folders to allow for different hardware configurations. Most keyboards only go 1 folder deep, but QMK supports structures up to 5 folders deep. Each folder can have its own config.h and rules.mk files that are incorporated into the final configuration. Keymap This level contains all of the options for that particular keymap. If you wish to override a previous declaration, you can use #undef &lt;variable&gt; to undefine it, where you can then redefine it without an error. The config.h File This is a C header file that is one of the first things included, and will persist over the whole project (if included). Lots of variables can be set here and accessed elsewhere. The config.h file shouldn't be including other config.h files, or anything besides this: #include &quot;config_common.h&quot; Hardware Options #define VENDOR_ID 0x1234 defines your VID, and for most DIY projects, can be whatever you want #define PRODUCT_ID 0x5678 defines your PID, and for most DIY projects, can be whatever you want #define DEVICE_VER 0 defines the device version (often used for revisions) #define MANUFACTURER Me generally who\/whatever brand produced the board #define PRODUCT Board the name of the keyboard #define DESCRIPTION a keyboard a short description of what the keyboard is #define MATRIX_ROWS 5 the number of rows in your keyboard's matrix #define MATRIX_COLS 15 the number of columns in your keyboard's matrix #define MATRIX_ROW_PINS { D0, D5, B5, B6 } pins of the rows, from top to bottom #define MATRIX_COL_PINS { F1, F0, B0, C7, F4, F5, F6, F7, D4, D6, B4, D7 } pins of the columns, from left to right #define UNUSED_PINS { D1, D2, D3, B1, B2, B3 } pins unused by the keyboard for reference #define MATRIX_HAS_GHOST define is matrix has ghost (unlikely) #define DIODE_DIRECTION COL2ROW COL2ROW or ROW2COL - how your matrix is configured. COL2ROW means the black mark on your diode is facing to the rows, and between the switch and the rows. #define AUDIO_VOICES turns on the alternate audio voices (to cycle through) #define C4_AUDIO enables audio on pin C4 #define C5_AUDIO enables audio on pin C5 #define C6_AUDIO enables audio on pin C6 #define B5_AUDIO enables audio on pin B5 (duophony is enables if one of B[5-7]_AUDIO is enabled along with one of C[4-6]_AUDIO) #define B6_AUDIO enables audio on pin B6 (duophony is enables if one of B[5-7]_AUDIO is enabled along with one of C[4-6]_AUDIO) #define B7_AUDIO enables audio on pin B7 (duophony is enables if one of B[5-7]_AUDIO is enabled along with one of C[4-6]_AUDIO) #define BACKLIGHT_PIN B7 pin of the backlight - B5, B6, B7 use PWM, others use softPWM #define BACKLIGHT_LEVELS 3 number of levels your backlight will have (maximum 15 excluding off) #define BACKLIGHT_BREATHING enables backlight breathing (only works with backlight pins B5, B6 and B7) #define BREATHING_PERIOD 6 the length of one backlight &quot;breath&quot; in seconds #define DEBOUNCING_DELAY 5 the delay when reading the value of the pin (5 is default) #define LOCKING_SUPPORT_ENABLE mechanical locking support. Use KC_LCAP, KC_LNUM or KC_LSCR instead in keymap #define LOCKING_RESYNC_ENABLE tries to keep switch state consistent with keyboard LED state #define IS_COMMAND() ( keyboard_report-&gt;mods == (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT)) ) key combination that allows the use of magic commands (useful for debugging) #define USB_MAX_POWER_CONSUMPTION sets the maximum power (in mA) over USB for the device (default: 500) Features That Can Be Disabled If you define these options you will disable the associated feature, which can save on code size. #define NO_DEBUG disable debugging #define NO_PRINT disable printing\/debugging using hid_listen #define NO_ACTION_LAYER disable layers #define NO_ACTION_TAPPING disable tap dance and other tapping features #define NO_ACTION_ONESHOT disable one-shot modifiers #define NO_ACTION_MACRO disable all macro handling #define NO_ACTION_FUNCTION disable the action function (deprecated) Features That Can Be Enabled If you define these options you will enable the associated feature, which may increase your code size. #define FORCE_NKRO NKRO by default requires to be turned on, this forces it on during keyboard startup regardless of EEPROM setting. NKRO can still be turned off but will be turned on again if the keyboard reboots. #define PREVENT_STUCK_MODIFIERS stores the layer a key press came from so the same layer is used when the key is released, regardless of which layers are enabled Behaviors That Can Be Configured #define TAPPING_TERM 200 how long before a tap becomes a hold #define RETRO_TAPPING tap anyway, even after TAPPING_TERM, if there was no other key interruption between press and release #define TAPPING_TOGGLE 2 how many taps before triggering the toggle #define PERMISSIVE_HOLD makes tap and hold keys work better for fast typers who don't want tapping term set above 500 #define LEADER_TIMEOUT 300 how long before the leader key times out #define ONESHOT_TIMEOUT 300 how long before oneshot times out #define ONESHOT_TAP_TOGGLE 2 how many taps before oneshot toggle is triggered #define IGNORE_MOD_TAP_INTERRUPT makes it possible to do rolling combos (zx) with keys that convert to other keys on hold #define QMK_KEYS_PER_SCAN 4 Allows sending more than one key per scan. By default, only one key event gets sent via process_record() per scan. This has little impact on most typing, but if you're doing a lot of chords, or your scan rate is slow to begin with, you can have some delay in processing key events. Each press and release is a separate event. For a keyboard with 1ms or so scan times, even a very fast typist isn't going to produce the 500 keystrokes a second needed to actually get more than a few ms of delay from this. But if you're doing chording on something with 3-4ms scan times? You probably want this. RGB Light Configuration #define RGB_DI_PIN D7 pin the DI on the ws2812 is hooked-up to #define RGBLIGHT_ANIMATIONS run RGB animations #define RGBLED_NUM 15 number of LEDs #define RGBLIGHT_HUE_STEP 12 units to step when in\/decreasing hue #define RGBLIGHT_SAT_STEP 25 units to step when in\/decreasing saturation #define RGBLIGHT_VAL_STEP 12 units to step when in\/decreasing value (brightness) #define RGBW_BB_TWI bit-bangs TWI to EZ RGBW LEDs (only required for Ergodox EZ) Mouse Key Options #define MOUSEKEY_INTERVAL 20 #define MOUSEKEY_DELAY 0 #define MOUSEKEY_TIME_TO_MAX 60 #define MOUSEKEY_MAX_SPEED 7 #define MOUSEKEY_WHEEL_DELAY 0 The rules.mk File This is a make file that is included by the top-level Makefile. It is used to set some information about the MCU that we will be compiling for as well as enabling and disabling certain features. Build Options DEFAULT_FOLDER Used to specify a default folder when a keyboard has more than one sub-folder. SRC Used to add files to the compilation\/linking list. LAYOUTS A list of layouts this keyboard supports. AVR MCU Options MCU = atmega32u4 F_CPU = 16000000 ARCH = AVR8 F_USB = $(F_CPU) OPT_DEFS += -DINTERRUPT_CONTROL_ENDPOINT BOOTLOADER = atmel-dfu with the following options: atmel-dfu lufa-dfu qmk-dfu halfkay caterina bootloadHID Feature Options Use these to enable or disable building certain features. The more you have enabled the bigger your firmware will be, and you run the risk of building a firmware too large for your MCU. BOOTMAGIC_ENABLE Virtual DIP switch configuration(+1000) MOUSEKEY_ENABLE Mouse keys(+4700) EXTRAKEY_ENABLE Audio control and System control(+450) CONSOLE_ENABLE Console for debug(+400) COMMAND_ENABLE Commands for debug and configuration NKRO_ENABLE USB N-Key Rollover - if this doesn't work, see here: https:\/\/github.com\/tmk\/tmk_keyboard\/wiki\/FAQ#nkro-doesnt-work AUDIO_ENABLE Enable the audio subsystem. RGBLIGHT_ENABLE Enable keyboard underlight functionality MIDI_ENABLE MIDI controls UNICODE_ENABLE Unicode BLUETOOTH_ENABLE Enable Bluetooth with the Adafruit EZ-Key HID","tags":"","url":"Reference\/Config_Options.html"},{"title":"Custom Code","text":"How to Customize Your Keyboard's Behavior A Word on Core vs Keyboards vs Keymap Custom Keycodes Defining a New Keycode Programming the Behavior of Any Keycode Example process_record_user() Implementation process_record_* Function Documentation LED Control Example led_set_user() Implementation led_set_* Function Documentation Matrix Initialization Code Example matrix_init_user() Implementation matrix_init_* Function Documentation Matrix Scanning Code Example matrix_scan_* Implementation matrix_scan_* Function Documentation Layer Change Code Example layer_state_set_* Implementation layer_state_set_* Function Documentation How to Customize Your Keyboard's Behavior For a lot of people a custom keyboard is about more than sending button presses to your computer. You want to be able to do things that are more complex than simple button presses and macros. QMK has hooks that allow you to inject code, override functionality, and otherwise customize how your keyboard behaves in different situations. This page does not assume any special knowledge about QMK, but reading Understanding QMK will help you understand what is going on at a more fundamental level. A Word on Core vs Keyboards vs Keymap We have structured QMK as a hierarchy: Core (_quantum) Keyboard\/Revision (_kb) Keymap (_user) Each of the functions described below can be defined with a _kb() suffix or a _user() suffix. We intend for you to use the _kb() suffix at the Keyboard\/Revision level, while the _user() suffix should be used at the Keymap level. When defining functions at the Keyboard\/Revision level it is important that your _kb() implementation call _user() before executing anything else- otherwise the keymap level function will never be called. Custom Keycodes By far the most common task is to change the behavior of an existing keycode or to create a new keycode. From a code standpoint the mechanism for each is very similar. Defining a New Keycode The first step to creating your own custom keycode(s) is to enumerate them. This means both naming them and assigning a unique number to that keycode. Rather than limit custom keycodes to a fixed range of numbers QMK provides the SAFE_RANGE macro. You can use SAFE_RANGE when enumerating your custom keycodes to guarantee that you get a unique number. Here is an example of enumerating 2 keycodes. After adding this block to your keymap.c you will be able to use FOO and BAR inside your keymap. enum my_keycodes { FOO = SAFE_RANGE, BAR }; Programming the Behavior of Any Keycode When you want to override the behavior of an existing key, or define the behavior for a new key, you should use the process_record_kb() and process_record_user() functions. These are called by QMK during key processing before the actual key event is handled. If these functions return true QMK will process the keycodes as usual. That can be handy for extending the functionality of a key rather than replacing it. If these functions return false QMK will skip the normal key handling, and it will be up to you to send any key up or down events that are required. These function are called every time a key is pressed or released. Example process_record_user() Implementation This example does two things. It defines the behavior for a custom keycode called FOO, and it supplements our Enter key by playing a tone whenever it is pressed. bool process_record_user(uint16_t keycode, keyrecord_t *record) { switch (keycode) { case FOO: if (record-&gt;event.pressed) { \/\/ Do something when pressed } else { \/\/ Do something else when release } return false; \/\/ Skip all further processing of this key case KC_ENTER: \/\/ Play a tone when enter is pressed if (record-&gt;event.pressed) { PLAY_NOTE_ARRAY(tone_qwerty); } return true; \/\/ Let QMK send the enter press\/release events default: return true; \/\/ Process all other keycodes normally } } process_record_* Function Documentation Keyboard\/Revision: bool process_record_kb(uint16_t keycode, keyrecord_t *record) Keymap: bool process_record_user(uint16_t keycode, keyrecord_t *record) The keycode argument is whatever is defined in your keymap, eg MO(1), KC_L, etc. You should use a switch...case block to handle these events. The record argument contains information about the actual press: keyrecord_t record { +-keyevent_t event { | +-keypos_t key { | | +-uint8_t col | | +-uint8_t row | | } | +-bool pressed | +-uint16_t time | } } LED Control This allows you to control the 5 LED's defined as part of the USB Keyboard spec. It will be called when the state of one of those 5 LEDs changes. USB_LED_NUM_LOCK USB_LED_CAPS_LOCK USB_LED_SCROLL_LOCK USB_LED_COMPOSE USB_LED_KANA Example led_set_user() Implementation void led_set_user(uint8_t usb_led) { if (usb_led &amp; (1&lt;&lt;USB_LED_NUM_LOCK)) { PORTB |= (1&lt;&lt;0); } else { PORTB &amp;= ~(1&lt;&lt;0); } if (usb_led &amp; (1&lt;&lt;USB_LED_CAPS_LOCK)) { PORTB |= (1&lt;&lt;1); } else { PORTB &amp;= ~(1&lt;&lt;1); } if (usb_led &amp; (1&lt;&lt;USB_LED_SCROLL_LOCK)) { PORTB |= (1&lt;&lt;2); } else { PORTB &amp;= ~(1&lt;&lt;2); } if (usb_led &amp; (1&lt;&lt;USB_LED_COMPOSE_LOCK)) { PORTB |= (1&lt;&lt;3); } else { PORTB &amp;= ~(1&lt;&lt;3); } if (usb_led &amp; (1&lt;&lt;USB_LED_KANA_LOCK)) { PORTB |= (1&lt;&lt;4); } else { PORTB &amp;= ~(1&lt;&lt;4); } } led_set_* Function Documentation Keyboard\/Revision: void led_set_kb(uint8_t usb_led) Keymap: void led_set_user(uint8_t usb_led) Matrix Initialization Code Before a keyboard can be used the hardware must be initialized. QMK handles initialization of the keyboard matrix itself, but if you have other hardware like LED's or i\u00b2c controllers you will need to set up that hardware before it can be used. Example matrix_init_user() Implementation This example, at the keyboard level, sets up B1, B2, and B3 as LED pins. void matrix_init_user(void) { \/\/ Call the keymap level matrix init. \/\/ Set our LED pins as output DDRB |= (1&lt;&lt;1); DDRB |= (1&lt;&lt;2); DDRB |= (1&lt;&lt;3); } matrix_init_* Function Documentation Keyboard\/Revision: void matrix_init_kb(void) Keymap: void matrix_init_user(void) Matrix Scanning Code Whenever possible you should customize your keyboard by using process_record_*() and hooking into events that way, to ensure that your code does not have a negative performance impact on your keyboard. However, in rare cases it is necessary to hook into the matrix scanning. Be extremely careful with the performance of code in these functions, as it will be called at least 10 times per second. Example matrix_scan_* Implementation This example has been deliberately omitted. You should understand enough about QMK internals to write this without an example before hooking into such a performance sensitive area. If you need help please open an issue or chat with us on gitter. matrix_scan_* Function Documentation Keyboard\/Revision: void matrix_scan_kb(void) Keymap: void matrix_scan_user(void) This function gets called at every matrix scan, which is basically as often as the MCU can handle. Be careful what you put here, as it will get run a lot. You should use this function if you need custom matrix scanning code. It can also be used for custom status output (such as LED's or a display) or other functionality that you want to trigger regularly even when the user isn't typing. Layer Change Code Thir runs code every time that the layers get changed. This can be useful for layer indication, or custom layer handling. Example layer_state_set_* Implementation This example shows how to set the RGB Underglow lights based on the layer, using the Planck as an example uint32_t layer_state_set_user(uint32_t state) { switch (biton32(state)) { case _RAISE: rgblight_setrgb (0x00, 0x00, 0xFF); break; case _LOWER: rgblight_setrgb (0xFF, 0x00, 0x00); break; case _PLOVER: rgblight_setrgb (0x00, 0xFF, 0x00); break; case _ADJUST: rgblight_setrgb (0x7A, 0x00, 0xFF); break; default: \/\/ for any other layers, or the default layer rgblight_setrgb (0x00, 0xFF, 0xFF); break; } return state; } layer_state_set_* Function Documentation Keyboard\/Revision: void uint32_t layer_state_set_kb(uint32_t state) Keymap: uint32_t layer_state_set_user(uint32_t state) The state is the bitmask of the active layers, as explained in the Keymap Overview","tags":"","url":"Reference\/Custom_Code.html"},{"title":"Documentation Best Practices","text":"Documentation Best Practices Page Opening Headings Styled Hint Blocks Examples: Styled Terminal Blocks Example Documenting Features Documentation Best Practices This page exists to document best practices when writing documentation for QMK. Following these guidelines will help to keep a consistent tone and style, which will in turn help other people more easily understand QMK. Page Opening Your documentation page should generally start with an H1 heading, followed by a 1 paragraph description of what the user will find on this page. Keep in mind that this heading and paragraph will sit next to the Table of Contents, so keep the heading short and avoid long strings with no whitespace. Example: # My Page Title This page covers my super cool feature. You can use this feature to make coffee, squeeze fresh oj, and have an egg mcmuffin and hashbrowns delivered from your local macca's by drone. Headings Your page should generally have multiple &quot;H1&quot; headings. Only H1 and H2 headings will included in the Table of Contents, so plan them out appropriately. Excess width should be avoided in H1 and H2 headings to prevent the Table of Contents from getting too wide. Styled Hint Blocks You can have styled hint blocks drawn around text to draw attention to it. {% hint style='info' %} This uses `hint style='info'` {% endhint %} Examples: {% hint style='info' %} This uses hint style='info' {% endhint %} {% hint style='tip' %} This uses hint style='tip' {% endhint %} {% hint style='danger' %} This uses hint style='danger' {% endhint %} {% hint style='working' %} This uses hint style='working' {% endhint %} Styled Terminal Blocks You can present styled terminal blocks by including special tokens inside your text block. \\`\\`\\` **[terminal] **[prompt foo@joe]**[path ~]**[delimiter $ ]**[command .\/myscript] Normal output line. Nothing special here... But... You can add some colors. What about a warning message? **[warning [WARNING] The color depends on the theme. Could look normal too] What about an error message? **[error [ERROR] This is not the error you are looking for] \\`\\`\\` Example **[terminal] **[prompt foo@joe]**[path ~]**[delimiter $ ]**[command .\/myscript] Normal output line. Nothing special here... But... You can add some colors. What about a warning message? **[warning [WARNING] The color depends on the theme. Could look normal too] What about an error message? **[error [ERROR] This is not the error you are looking for] Documenting Features If you create a new feature for QMK, create a documentation page for it. It doesn't have to be very long, a few sentences describing your feature and a table listing any relevant keycodes is enough. Here is a basic template: # My Cool Feature This page describes my cool feature. You can use my cool feature to make coffee and order cream and sugar to be delivered via drone. ## My Cool Feature Keycodes |Long Name|Short Name|Description| |---------|----------|-----------| |KC_COFFEE||Make Coffee| |KC_CREAM||Order Cream| |KC_SUGAR||Order Sugar| Place your documentation into docs\/feature_&lt;my_cool_feature&gt;.md, and add that file to the appropriate place in docs\/_summary.md. If you have added any keycodes be sure to add them to docs\/06_Keycodes\/index.md with a link back to your feature page.","tags":"","url":"Reference\/Documentation_Best_Practices.html"},{"title":"Documentation Templates","text":"Documentation Templates Keymap readme.md Template Keyboard readme.md Template Documentation Templates This page documents the templates you should use when submitting new Keymaps and Keyboards to QMK. Keymap readme.md Template Most keymaps have an image depicting the layout. You can use Keyboard Layout Editor to create an image. Upload it to Imgur or another hosting service, please do not include images in your Pull Request. Below the image you should write a short description to help people understand your keymap. ![Clueboard Layout Image](http:\/\/i.imgur.com\/7Capi8W.png) # Default Clueboard Layout This is the default layout that comes flashed on every Clueboard. For the most part it's a straightforward and easy to follow layout. The only unusual key is the key in the upper left, which sends Escape normally, but Grave when any of the Ctrl, Alt, or GUI modifiers are held down. Keyboard readme.md Template # Planck ![Planck](http:\/\/i.imgur.com\/q2M3uEU.jpg) A compact 40% (12x4) ortholinear keyboard kit made and sold by OLKB and Massdrop. [More info on qmk.fm](http:\/\/qmk.fm\/planck\/) Keyboard Maintainer: [Jack Humbert](https:\/\/github.com\/jackhumbert) Hardware Supported: Planck PCB rev1, rev2, rev3, rev4, Teensy 2.0 Hardware Availability: [OLKB.com](https:\/\/olkb.com), [Massdrop](https:\/\/www.massdrop.com\/buy\/planck-mechanical-keyboard?mode=guest_open) Make example for this keyboard (after setting up your build environment): make planck\/rev4:default See [build environment setup](https:\/\/docs.qmk.fm\/build_environment_setup.html) then the [make instructions](https:\/\/docs.qmk.fm\/make_instructions.html) for more information. There needs to be two spaces at the end of the Keyboard Maintainer and Hardware Supported lines for it to render correctly with Markdown.","tags":"","url":"Reference\/Documentation_Templates.html"},{"title":"Glossary","text":"Glossary of QMK Terms ARM AVR AZERTY Backlight Bluetooth Bootloader Bootmagic C Colemak Compile Dvorak Dynamic Macro Eclipse Firmware FLIP git GitHub ISP hid_listen Keycode Key Down Key Up Keymap Layer Leader Key LED Make Matrix Macro MCU Modifier Mousekeys N-Key Rollover (NKRO) Oneshot Modifier ProMicro Pull Request QWERTY QWERTZ Rollover Scancode Space Cadet Shift Tap Tap Dance Teensy Underlight Unicode Unit Testing USB USB Host (or simply Host) Couldn't Find the Term You're Looking For? Glossary of QMK Terms ARM A line of 32-bit MCU's produced by a number of companies, such as Atmel, Cypress, Kinetis, NXP, ST, and TI. AVR A line of 8-bit MCU's produced by Atmel. AVR was the original platform that TMK supported. AZERTY The standard Fran\u00e7ais (French) keyboard layout. Named for the first 6 keys on the keyboard. Backlight A generic term for lighting on a keyboard. The backlight is typically, but not always, an array of LED's that shine through keycaps and\/or switches. Bluetooth A short range peer to peer wireless protocol. Most common wireless protocol for a keyboard. Bootloader A special program that is written to a protected area of your MCU that allows the MCU to upgrade its own firmware, typically over USB. Bootmagic A feature that allows for various keyboard behavior changes to happen on the fly, such as swapping or disabling common keys. C A low-level programming language suitable for system code. Most QMK code is written in C. Colemak An alternative keyboard layout that is gaining in popularity. Compile The process of turning human readable code into machine code your MCU can run. Dvorak An alternative keyboard layout developed by Dr. August Dvorak in the 1930's. A shortened form of the Dvorak Simplified Keyboard. Dynamic Macro A macro which has been recorded on the keyboard and which will be lost when the keyboard is unplugged or the computer rebooted. Dynamic Macro Documentation Eclipse An IDE that is popular with many C developers. Eclipse Setup Instructions Firmware The software that controls your MCU. FLIP Software provided by Atmel for flashing AVR devices. We generally recommend QMK Flasher instead, but for some advanced use cases FLIP is required. git Versioning software used at the command line GitHub The website that hosts most of the QMK project. It provides integration with git, issue tracking, and other features that help us run QMK. ISP In-system programming, a method of programming an AVR chip using external hardware and the JTAG pins. hid_listen An interface for receiving debugging messages from your keyboard. You can view these messages using QMK Flasher or PJRC's hid_listen Keycode A 2-byte number that represents a particular key. 0x00-0xFF are used for Basic Keycodes while 0x100-0xFFFF are used for Quantum Keycodes. Key Down An event that happens when a key is pressed down, but is completed before a key is released. Key Up An event that happens when a key is released. Keymap An array of keycodes mapped to a physical keyboard layout, which are processed on key presses and releases Layer An abstraction used to allow a key to serve multiple purposes. The highest active layer takes precedence. Leader Key A feature that allows you to tap the leader key followed by a sequence of 1, 2, or 3 keys to activate key presses or other quantum features. Leader Key Documentation LED Light Emitting Diode, the most common device used for indicators on a keyboard. Make Software package that is used to compile all the source files. You run make with various options to compile your keyboard firmware. Matrix A wiring pattern of columns and rows that enables the MCU to detect keypresses with a fewer number of pins. The matrix often incorporates diodes to allow for NKRO. Macro A feature that lets you send multiple keypress events (hid reports) after having pressed only a single key. Macro Documentation MCU Microcontrol Unit, the processor that powers your keyboard. Modifier A key that is held down while typing another key to modify the action of that key. Examples include Ctrl, Alt, and Shift. Mousekeys A feature that lets you control your mouse cursor and click from your keyboard. Mousekeys Documentation N-Key Rollover (NKRO) A term that applies to keyboards that are capable of reporting any number of key-presses at once. Oneshot Modifier A modifier that acts as if it is held down until another key is released, so you can press the mod and then press the key, rather than holding the mod while pressing the key. Also known as a Sticky key or a Dead key. ProMicro A low cost AVR development board. Clones of this device are often found on ebay very inexpensively (under $5) but people often struggle with flashing their pro micros. Pull Request A request to submit code to QMK. We encourage all users to submit Pull Requests for their personal keymaps. QWERTY The standard English keyboard layout, and often a shortcut for other language's standard layouts. Named for the first 6 letters on the keyboard. QWERTZ The standard Deutsche (German) keyboard layout. Named for the first 6 letters on the keyboard. Rollover The term for pressing a key while a key is already held down. Variants include 2KRO, 6KRO, and NKRO. Scancode A 1 byte number that is sent as part of a HID report over USB that represents a single key. These numbers are documented in the HID Usage Tables published by the USB-IF. Space Cadet Shift A special set of shift keys which allow you to type various types of braces by tapping the left or right shift one or more times. Space Cadet Shift Documentation Tap Pressing and releasing a key. In some situations you will need to distinguish between a key down and a key up event, and Tap always refers to both at once. Tap Dance A feature that lets you assign multiple keycodes to the same key based on how many times you press it. Tap Dance Documentation Teensy A low-cost AVR development board that is commonly used for hand-wired builds. A teensy is often chosen despite costing a few dollars more due to its halfkay bootloader, which makes flashing very simple. Underlight A generic term for LEDs that light the underside of the board. These LED's typically shine away from the bottom of the PCB and towards the surface the keyboard rests on. Unicode In the larger computer world Unicode is a set of encoding schemes for representing characters in any language. As it relates to QMK it means using various OS schemes to send unicode codepoints instead of scancodes. Unicode Documentation Unit Testing A framework for running automated tests against QMK. Unit testing helps us be confident that our changes do not break anything. Unit Testing Documentation USB Universal Serial Bus, the most common wired interface for a keyboard. USB Host (or simply Host) The USB Host is your computer, or whatever device your keyboard is plugged into. Couldn't Find the Term You're Looking For? Open an issue with your question and the term in question could be added here. Better still, open a pull request with the definition. :)","tags":"","url":"Reference\/Glossary.html"},{"title":"Keymap Overview","text":"Keymap Overview Keymap and Layers Keymap Layer Status Layer Precedence and Transparency Anatomy of a keymap.c Definitions Layers and Keymaps Base Layer Function Overlay Layer Custom Functions fn_actions[] action_function() Nitty Gritty Details Keymap Overview QMK keymaps are defined inside a C source file. The data structure is an array of arrays. The outer array is a list of layer arrays while the inner layer array is a list of keys. Most keyboards define a KEYMAP() macro to help you create this array of arrays. Keymap and Layers In QMK, const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] holds multiple layers of keymap information in 16 bit data holding the action code. You can define 32 layers at most. For trivial key definitions, the higher 8 bits of the action code are all 0 and the lower 8 bits holds the USB HID usage code generated by the key as keycode. Respective layers can be validated simultaneously. Layers are indexed with 0 to 31 and higher layer has precedence. Keymap: 32 Layers Layer: action code matrix ----------------- --------------------- stack of layers array_of_action_code[row][column] ____________ precedence _______________________ \/ \/ | high \/ ESC \/ F1 \/ F2 \/ F3 .... 31 \/___________\/\/ | \/-----\/-----\/-----\/----- 30 \/___________\/\/ | \/ TAB \/ Q \/ W \/ E .... 29 \/___________\/ | \/-----\/-----\/-----\/----- : _:_:_:_:_:__ | : \/LCtrl\/ A \/ S \/ D .... : \/ : : : : : \/ | : \/ : : : : 2 \/___________\/\/ | 2 `-------------------------- 1 \/___________\/\/ | 1 `-------------------------- 0 \/___________\/ V low 0 `-------------------------- Sometimes, the action code stored in keymap may be referred as keycode in some documents due to the TMK history. Keymap Layer Status The state of the Keymap layer is determined by two 32 bit parameters: default_layer_state indicates a base keymap layer (0-31) which is always valid and to be referred (the default layer). layer_state has current on\/off status of each layer in its bits. Keymap layer '0' is usually the default_layer, with other layers initially off after booting up the firmware, although this can configured differently in config.h. It is useful to change default_layer when you completely switch a key layout, for example, if you want to switch to Colemak instead of Qwerty. Initial state of Keymap Change base layout ----------------------- ------------------ 31 31 30 30 29 29 : : : : ____________ 2 ____________ 2 \/ \/ 1 \/ \/ ,-&gt;1 \/___________\/ ,-&gt;0 \/___________\/ | 0 | | `--- default_layer = 0 `--- default_layer = 1 layer_state = 0x00000001 layer_state = 0x00000002 On the other hand, you can change layer_state to overlay the base layer with other layers for features such as navigation keys, function keys (F1-F12), media keys, and\/or special actions. Overlay feature layer --------------------- bit|status ____________ ---+------ 31 \/ \/ 31 | 0 30 \/___________\/\/ -----&gt; 30 | 1 29 \/___________\/ -----&gt; 29 | 1 : : | : : ____________ : | : 2 \/ \/ 2 | 0 ,-&gt;1 \/___________\/ -----&gt; 1 | 1 | 0 0 | 0 | + `--- default_layer = 1 | layer_state = 0x60000002 &lt;-' Layer Precedence and Transparency Note that higher layer has higher priority on stack of layers, namely firmware falls down from top layer to bottom to look up keycode. Once it spots keycode other than KC_TRNS(transparent) on a layer it stops searching and lower layers aren't referred. You can place KC_TRANS on overlay layer changes just part of layout to fall back on lower or base layer. Key with KC_TRANS (KC_TRNS and _______ are the alias) doesn't has its own keycode and refers to lower valid layers for keycode, instead. Anatomy of a keymap.c For this example we will walk through an older version of the default Clueboard 66% keymap. You'll find it helpful to open that file in another browser window so you can look at everything in context. There are 3 main sections of a keymap.c file you'll want to concern yourself with: The Definitions The Layer\/Keymap Datastructure Custom Functions, if any Definitions At the top of the file you'll find this: #include &quot;clueboard.h&quot; \/\/ Helpful defines #define GRAVE_MODS (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)|MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)|MOD_BIT(KC_LALT)|MOD_BIT(KC_RALT)) #define _______ KC_TRNS \/\/ Each layer gets a name for readability. \/\/ The underscores don't mean anything - you can \/\/ have a layer called STUFF or any other name. \/\/ Layer names don't all need to be of the same \/\/ length, and you can also skip them entirely \/\/ and just use numbers. #define _BL 0 #define _FL 1 #define _CL 2 These are some handy definitions we can use when building our keymap and our custom function. The GRAVE_MODS definition will be used later in our custom function. The _______ define makes it easier to see what keys a layer is overriding, while the _BL, _FL, and _CL defines make it easier to refer to each of our layers. Layers and Keymaps The main part of this file is the keymaps[] definition. This is where you list your layers and the contents of those layers. This part of the file begins with this definition: const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = { After this you'll find a list of KEYMAP() macros. A KEYMAP() is simply a list of keys to define a single layer. Typically you'll have one or more &quot;base layers&quot; (such as QWERTY, Dvorak, or Colemak) and then you'll layer on top of that one or more &quot;function&quot; layers. Due to the way layers are processed you can't overlay a &quot;lower&quot; layer on top of a &quot;higher&quot; layer. keymaps[][MATRIX_ROWS][MATRIX_COLS] in QMK holds the 16 bit action code (sometimes referred as the quantum keycode) in it. For the keycode representing typical keys, its high byte is 0 and its low byte is the USB HID usage ID for keyboard. TMK from which QMK was forked uses const uint8_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] instead and holds the 8 bit keycode. Some keycode values are reserved to induce execution of certain action codes via the fn_actions[] array. Base Layer Here is an example of the Clueboard's base layer: \/* Keymap _BL: Base Layer (Default Layer) *\/ [_BL] = KEYMAP( F(0), KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_MINS, KC_EQL, KC_GRV, KC_BSPC, KC_PGUP, \\ KC_TAB, KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, KC_LBRC, KC_RBRC, KC_BSLS, KC_PGDN, \\ KC_CAPS, KC_A, KC_S, KC_D, KC_F, KC_G, KC_H, KC_J, KC_K, KC_L, KC_SCLN, KC_QUOT, KC_NUHS, KC_ENT, \\ KC_LSFT, KC_NUBS, KC_Z, KC_X, KC_C, KC_V, KC_B, KC_N, KC_M, KC_COMM, KC_DOT, KC_SLSH, KC_RO, KC_RSFT, KC_UP, \\ KC_LCTL, KC_LGUI, KC_LALT, KC_MHEN, KC_SPC,KC_SPC, KC_HENK, KC_RALT, KC_RCTL, MO(_FL), KC_LEFT, KC_DOWN, KC_RGHT), Some interesting things to note about this: From a C source point of view it's only a single array, but we have embedded whitespace to more easily visualize where each key is on the physical device. Plain keyboard scancodes are prefixed with KC_, while &quot;special&quot; keys are not. The upper left key activates custom function 0 (F(0)) The &quot;Fn&quot; key is defined with MO(_FL), which moves to the _FL layer while that key is being held down. Function Overlay Layer Our function layer is, from a code point of view, no different from the base layer. Conceptually, however, you will build that layer as an overlay, not a replacement. For many people this distinction does not matter, but as you build more complicated layering setups it matters more and more. [_FL] = KEYMAP( KC_GRV, KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, KC_F7, KC_F8, KC_F9, KC_F10, KC_F11, KC_F12, _______, KC_DEL, BL_STEP, \\ _______, _______, _______,_______,_______,_______,_______,_______,KC_PSCR,KC_SLCK, KC_PAUS, _______, _______, _______, _______, \\ _______, _______, MO(_CL),_______,_______,_______,_______,_______,_______,_______, _______, _______, _______, _______, \\ _______, _______, _______,_______,_______,_______,_______,_______,_______,_______, _______, _______, _______, _______, KC_PGUP, \\ _______, _______, _______, _______, _______,_______, _______, _______, _______, MO(_FL), KC_HOME, KC_PGDN, KC_END), Some interesting things to note: We have used our _______ definition to turn KC_TRNS into _______. This makes it easier to spot the keys that have changed on this layer. While in this layer if you press one of the _______ keys it will activate the key in the next lowest active layer. Custom Functions At the bottom of the file we've defined a single custom function. This function defines a key that sends KC_ESC when pressed without modifiers and KC_GRAVE when modifiers are held. There are a couple pieces that need to be in place for this to work, and we will go over both of them. fn_actions[] We define the fn_actions[] array to point to custom functions. F(N) in a keymap will call element N of that array. For the Clueboard's that looks like this: const uint16_t PROGMEM fn_actions[] = { [0] = ACTION_FUNCTION(0), \/\/ Calls action_function() }; In this case we've instructed QMK to call the ACTION_FUNCTION callback, which we will define in the next section. This fn_actions[] interface is mostly for backward compatibility. In QMK, you don't need to use fn_actions[]. You can directly use ACTION_FUNCTION(N) or any other action code value itself normally generated by the macro in keymaps[][MATRIX_ROWS][MATRIX_COLS]. N in F(N) can only be 0 to 31. Use of the action code directly in keymaps unlocks this limitation. You can get a full list of Action Functions in action_code.h. action_function() To actually handle the keypress event we define an action_function(). This function will be called when the key is pressed, and then again when the key is released. We have to handle both situations within our code, as well as determining whether to send\/release KC_ESC or KC_GRAVE. void action_function(keyrecord_t *record, uint8_t id, uint8_t opt) { static uint8_t mods_pressed; switch (id) { case 0: \/* Handle the combined Grave\/Esc key *\/ mods_pressed = get_mods()&amp;GRAVE_MODS; \/\/ Check to see what mods are pressed if (record-&gt;event.pressed) { \/* The key is being pressed. *\/ if (mods_pressed) { add_key(KC_GRV); send_keyboard_report(); } else { add_key(KC_ESC); send_keyboard_report(); } } else { \/* The key is being released. *\/ if (mods_pressed) { del_key(KC_GRV); send_keyboard_report(); } else { del_key(KC_ESC); send_keyboard_report(); } } break; } } Nitty Gritty Details This should have given you a basic overview for creating your own keymap. For more details see the following resources: Keycodes Keymap FAQ We are actively working to improve these docs. If you have suggestions for how they could be made better please file an issue!","tags":"","url":"Reference\/Keymap_Overview.html"},{"title":"Unit Testing","text":"Unit Testing Google Test and Google Mock Use of C++ Adding Tests for New or Existing Features Running the Tests Debugging the Tests Full Integration Tests Tracing Variables Unit Testing If you are new to unit testing, then you can find many good resources on internet. However most of it is scattered around in small pieces here and there, and there's also many different opinions, so I won't give any recommendations. Instead I recommend these two books, explaining two different styles of Unit Testing in detail. &quot;Test Driven Development: By Example: Kent Beck&quot; &quot;Growing Object-Oriented Software, Guided By Tests: Steve Freeman, Nat Pryce&quot; If you prefer videos there are Uncle Bob's Clean Coders Videos, which unfortunately cost quite a bit, especially if you want to watch many of them. But James Shore has a free Let's Play video series. Google Test and Google Mock It's possible to Unit Test your code using Google Test. The Google Test framework also includes another component for writing testing mocks and stubs, called &quot;Google Mock&quot;. For information how to write the actual tests, please refer to the documentation on that site. Use of C++ Note that Google Test and therefore any test has to be written in C++, even if the rest of the QMK codebases is written in C. This should hopefully not be a problem even if you don't know any C++, since there's quite clear documentation and examples of the required C++ features, and you can write the rest of the test code almost as you would write normal C. Note that some compiler errors which you might get can look quite scary, but just read carefully what it says, and you should be ok. One thing to remember, is that you have to append extern &quot;C&quot; around all of your C file includes. Adding Tests for New or Existing Features If you want to unit test some feature, then take a look at the existing serial_link tests, in the quantum\/serial_link\/tests folder, and follow the steps below to create a similar structure. If it doesn't already exist, add a test subfolder to the folder containing the feature. Create a testlist.mk and a rules.mk file in that folder. Include those files from the root folder testlist.mkand build_test.mk respectively. Add a new name for your testgroup to the testlist.mk file. Each group defined there will be a separate executable. And that's how you can support mocking out different parts. Note that it's worth adding some common prefix, just like it's done for the serial_link tests. The reason for that is that the make command allows substring filtering, so this way you can easily run a subset of the tests. Define the source files and required options in the rules.mk file. _SRC for source files _DEFS for additional defines _INC for additional include folders Write the tests in a new cpp file inside the test folder you created. That file has to be one of the files included from the rules.mk file. Note how there's several different tests, each mocking out a separate part. Also note that each of them only compiles the very minimum that's needed for the tests. It's recommend that you try to do the same. For a relevant video check out Matt Hargett &quot;Advanced Unit Testing in C &amp; C++ Running the Tests To run all the tests in the codebase, type make test. You can also run test matching a substring by typing make test:matchingsubstring Note that the tests are always compiled with the native compiler of your platform, so they are also run like any other program on your computer. Debugging the Tests If there are problems with the tests, you can find the executable in the .\/build\/test folder. You should be able to run those with GDB or a similar debugger. Full Integration Tests It's not yet possible to do a full integration test, where you would compile the whole firmware and define a keymap that you are going to test. However there are plans for doing that, because writing tests that way would probably be easier, at least for people that are not used to unit testing. In that model you would emulate the input, and expect a certain output from the emulated keyboard. Tracing Variables Sometimes you might wonder why a variable gets changed and where, and this can be quite tricky to track down without having a debugger. It's of course possible to manually add print statements to track it, but you can also enable the variable trace feature. This works for both for variables that are changed by the code, and when the variable is changed by some memory corruption. To take the feature into use add VARIABLE_TRACE=x to the end of you make command. x represents the number of variables you want to trace, which is usually 1. Then at a suitable place in the code, call ADD_TRACED_VARIABLE, to begin the tracing. For example to trace all the layer changes, you can do this void matrix_init_user(void) { ADD_TRACED_VARIABLE(&quot;layer&quot;, &amp;layer_state, sizeof(layer_state)); } This will add a traced variable named &quot;layer&quot; (the name is just for your information), which tracks the memory location of layer_state. It tracks 4 bytes (the size of layer_state), so any modification to the variable will be reported. By default you can not specify a size bigger than 4, but you can change it by adding MAX_VARIABLE_TRACE_SIZE=x to the end of the make command line. In order to actually detect changes to the variables you should call VERIFY_TRACED_VARIABLES around the code that you think that modifies the variable. If a variable is modified it will tell you between which two VERIFY_TRACED_VARIABLES calls the modification happened. You can then add more calls to track it down further. I don't recommend spamming the codebase with calls. It's better to start with a few, and then keep adding them in a binary search fashion. You can also delete the ones you don't need, as each call need to store the file name and line number in the ROM, so you can run out of memory if you add too many calls. Also remember to delete all the tracing code once you have found the bug, as you wouldn't want to create a pull request with tracing code.","tags":"","url":"Reference\/Unit_Testing.html"},{"title":"For Makers And Modders","text":"Hand Wiring Guide ISP Flashing Guide","tags":"","url":"For_Makers_And_Modders\/index.html"},{"title":"Hand Wiring Guide","text":"Quantum Hand-Wiring Guide How the Matrix Works (Why We Need Diodes) The Actual Hand-Wiring Getting Things in Place Preparing the Diodes Soldering the Diodes Soldering the Columns Wiring Things to the Teensy Getting Some Basic Firmware Set Up config.h &lt;project_name&gt;.h keymaps\/&lt;variant&gt;\/default.c Compiling Your Firmware Testing Your Firmware Securing the Teensy, Finishing Your Hardware, Getting Fancier Firmware Quantum Hand-Wiring Guide Parts list: x keyswitches (MX, Matias, Gateron, etc) x diodes Keyboard plate (metal, plastic, cardboard, etc) Wire (strained for wiring to the Teensy, anything for the rows\/columns) Soldering iron set at 600\u00baF or 315\u00baC (if temperature-controlled) Rosin-cored solder (leaded or lead-free) Adequate ventilation\/a fan Tweezers (optional) Wire cutters\/snippers How the Matrix Works (Why We Need Diodes) The microcontroller (in this case, the Teensy 2.0) will be setup up via the firmware to send a logical 1 to the columns, one at a time, and read from the rows, all at once - this process is called matrix scanning. The matrix is a bunch of open switches that, by default, don't allow any current to pass through - the firmware will read this as no keys being pressed. As soon as you press one key down, the logical 1 that was coming from the column the keyswitch is attached to gets passed through the switch and to the corresponding row - check out the following 2x2 example: Column 0 being scanned Column 1 being scanned x x col0 col1 col0 col1 | | | | row0 ---(key0)---(key1) row0 ---(key0)---(key1) | | | | row1 ---(key2)---(key3) row1 ---(key2)---(key3) The x represents that the column\/row associated has a value of 1, or is HIGH. Here, we see that no keys are being pressed, so no rows get an x. For one keyswitch, keep in mind that one side of the contacts is connected to its row, and the other, its column. When we press key0, col0 gets connected to row0, so the values that the firmware receives for that row is 0b01 (the 0b here means that this is a bit value, meaning all of the following digits are bits - 0 or 1 - and represent the keys in that column). We'll use this notation to show when a keyswitch has been pressed, to show that the column and row are being connected: Column 0 being scanned Column 1 being scanned x x col0 col1 col0 col1 | | | | x row0 ---(-+-0)---(key1) row0 ---(-+-0)---(key1) | | | | row1 ---(key2)---(key3) row1 ---(key2)---(key3) We can now see that row0 has an x, so has the value of 1. As a whole, the data the firmware receives when key0 is pressed is col0: 0b01 col1: 0b00 \u2502\u2514row0 \u2514row1 A problem arises when you start pressing more than one key at a time. Looking at our matrix again, it should become pretty obvious: Column 0 being scanned Column 1 being scanned x x col0 col1 col0 col1 | | | | x row0 ---(-+-0)---(-+-1) x row0 ---(-+-0)---(-+-1) | | | | x row1 ---(key2)---(-+-3) x row1 ---(key2)---(-+-3) Remember that this ^ is still connected to row1 The data we get from that is: col0: 0b11 col1: 0b11 \u2502\u2514row0 \u2514row1 Which isn't accurate, since we only have 3 keys pressed down, not all 4. This behavior is called ghosting, and only happens in odd scenarios like this, but can be much more common on a bigger keyboard. The way we can get around this is by placing a diode after the keyswitch, but before it connects to its row. A diode only allows current to pass through one way, which will protect our other columns\/rows from being activated in the previous example. We'll represent a dioded matrix like this; Column 0 being scanned Column 1 being scanned x x col0 col1 col0 col1 \u2502 \u2502 | \u2502 (key0) (key1) (key0) (key1) ! \u2502 ! \u2502 ! | ! \u2502 row0 \u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 row0 \u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 | \u2502 (key2) (key3) (key2) (key3) ! ! ! ! row1 \u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 row1 \u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 In practical applications, the black line of the diode will be placed facing the row, and away from the keyswitch - the ! in this case is the diode, where the gap represents the black line. A good way to remember this is to think of this symbol: &gt;| Now when we press the three keys, invoking what would be a ghosting scenario: Column 0 being scanned Column 1 being scanned x x col0 col1 col0 col1 \u2502 \u2502 \u2502 \u2502 (\u250c\u2500\u25240) (\u250c\u2500\u25241) (\u250c\u2500\u25240) (\u250c\u2500\u25241) ! \u2502 ! \u2502 ! \u2502 ! \u2502 x row0 \u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 x row0 \u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 (key2) (\u250c\u2500\u25183) (key2) (\u250c\u2500\u25183) ! ! ! ! row1 \u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 x row1 \u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Things act as they should! Which will get us the following data: col0: 0b01 col1: 0b11 \u2502\u2514row0 \u2514row1 The firmware can then use this correct data to detect what it should do, and eventually, what signals it needs to send to the OS. The Actual Hand-Wiring Getting Things in Place When starting this, you should have all of your stabilisers and keyswitches already installed (and optionally keycaps). If you're using a Cherry-type stabiliser (plate-mounted only, obviously), you'll need to install that before your keyswitches. If you're using Costar ones, you can installed them afterwards. To make things easier on yourself, make sure all of the keyswitches are oriented the same way (if they can be - not all layouts support this). Despite this, it's important to remember that the contacts on the keyswitches are completely symmetrical. We'll be using the keyswitch's left side contact for wiring the rows, and the right side one for wiring the columns. Get your soldering iron heated-up and collect the rest of the materials from the part list at the beginning of the guide. Place your keyboard so that the bottoms of the keyswitches are accessible - it may be a good idea to place it on a cloth to protect your keyswitches\/keycaps. Before continuing, plan out where you're going to place your Teensy. If you're working with a board that has a large (6.25u) spacebar, it may be a good idea to place it in-between switches against the plate. Otherwise, you may want to trim some of the leads on the keyswitches where you plan on putting it - this will make it a little harder to solder the wire\/diodes, but give you more room to place the Teensy. Preparing the Diodes It's a little easier to solder the diodes in place if you bend them at a 90\u00ba angle immediately after the black line - this will help to make sure you put them on the right way (direction matters), and in the correct position. The diodes will look like this when bent (with longer leads): \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2510 \u2500\u2500\u2500\u2524 \u2502 \u251c\u2500\u2510 \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2518 \u2502 \u2502 We'll be using the long lead at the bent end to connect it to the elbow (bent part) of the next diode, creating the row. Soldering the Diodes Starting at the top-left switch, place the diode (with tweezers if you have them) on the switch so that the diode itself is vertically aligned, and the black line is facing toward you. The straight end of the diode should be touching the left contact on the switch, and the bent end should be facing to the right and resting on the switch there, like this: \u2502o \u250c\u2534\u2510 o \u2502 \u2502 O \u251c\u2500\u2524 \u2514\u252c\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Letting the diode rest, grab your solder, and touch both it and the soldering iron to the left contact at the same time - the rosin in the solder should make it easy for the solder to flow over both the diode and the keyswitch contact. The diode may move a little, and if it does, carefully position it back it place by grabbing the bent end of the diode - the other end will become hot very quickly. If you find that it's moving too much, using needle-nose pliers of some sort may help to keep the diode still when soldering. The smoke that the rosin releases is harmful, so be careful not to breath it or get it in your eyes\/face. After soldering things in place, it may be helpful to blow on the joint to push the smoke away from your face, and cool the solder quicker. You should see the solder develop a matte (not shiny) surface as it solidifies. Keep in mind that it will still be very hot afterwards, and will take a couple minutes to be cool to touch. Blow on it will accelerate this process. When the first diode is complete, the next one will need to be soldered to both the keyswitch, and the previous diode at the new elbow. That will look something like this: \u2502o \u2502o \u250c\u2534\u2510 o \u250c\u2534\u2510 o \u2502 \u2502 O \u2502 \u2502 O \u251c\u2500\u2524 \u251c\u2500\u2524 \u2514\u252c\u2518 \u2514\u252c\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 After completing a row, use the wire cutters to trim the excess wire from the tops of the diodes, and from the right side on the final switch. This process will need to completed for each row you have. When all of the diodes are completely soldered, it's a good idea to quickly inspect each one to ensure that your solder joints are solid and sturdy - repairing things after this is possible, but more difficult. Soldering the Columns You'll have some options in the next process - it's a good idea to insulate the column wires (since the diodes aren't), but if you're careful enough, you can use exposed wires for the columns - it's not recommended, though. If you're using single-cored wire, stripping the plastic off of the whole wire and feeding it back on is probably the best option, but can be difficult depending on the size and materials. You'll want to leave parts of the wire exposed where you're going to be solder it onto the keyswitch. If you're using stranded wire, it's probably easiest to just use a lot of small wires to connect each keyswitch along the column. It's possible to use one and melt through the insulation, but this isn't recommended, will produce even more harmful fumes, and can ruin your soldering iron. Before beginning to solder, it helps to have your wire pre-bent (if using single-cored), or at least have an idea of how you're going to route the column (especially if you're making a staggered board). Where you go in particular doesn't matter too much, as we'll be basing our keymap definitions on how it was wired - just make sure every key in a particular row is in a unique column, and that they're in order from left to right. If you're not using any insulation, you can try to keep the column wires elevated, and solder them near the tips of the keyswitch contacts - if the wires are sturdy enough, they won't short out to the row wiring an diodes. Wiring Things to the Teensy Now that the matrix itself is complete, it's time to connect what you've done to the Teensy. You'll be needing the number of pins equal to your number of columns + your number of rows. There are some pins on the Teensy that are special, like D6 (the LED on the chip), or some of the UART, SPI, I2C, or PWM channels, but only avoid those if you're planning something in addition to a keyboard. If you're unsure about wanting to add something later, you should have enough pins in total to avoid a couple. The pins you'll absolutely have to avoid are: GND, VCC, AREF, and RST - all the others are usable and accessible in the firmware. Place the Teensy where you plan to put it - you'll have to cut wires to length in the next step, and you'll want to make sure they reach. Starting with the first column on the right side, measure out how much wire you'll need to connect it to the first pin on the Teensy - it helps to pick a side that you'll be able to work down, to keep the wires from overlapping too much. It may help to leave a little bit of slack so things aren't too tight. Cut the piece of wire, and solder it to the Teensy, and then the column - you can solder it anywhere along the column, but it may be easiest at the keyswitch. Just be sure the wire doesn't separate from the keyswitch when soldering. As you move from column to column, it'll be helpful to write the locations of the pins down. We'll use this data to setup the matrix in the future. When you're done with the columns, start with the rows in the same process, from top to bottom, and write them all down. Again, you can solder anywhere along the row, as long as it's after the diode - soldering before the diode (on the keyswitch side) will cause that row not to work. As you move along, be sure that the Teensy is staying in place - recutting and soldering the wires is a pain! Getting Some Basic Firmware Set Up From here, you should have a working keyboard once you program a firmware. Before we attach the Teensy permanently to the keyboard, let's quickly get some firmware loaded onto the Teensy so we can test each keyswitch. To start out, download the firmware - we'll be using my (Jack's) fork of TMK called QMK\/Quantum. We'll be doing a lot from the Terminal\/command prompt, so get that open, along with a decent text editor like Sublime Text. The first thing we're going to do is create a new project using the script in the root directory of the firmware. In your terminal, run this command with &lt;project_name&gt; replaced by the name of your project - it'll need to be different from any other project in the keyboards\/ folder: util\/new_project.sh &lt;project_name&gt; You'll want to navigate to the keyboards\/&lt;project_name&gt;\/ folder by typing, like the print-out from the script specifies: cd keyboards\/&lt;project_name&gt; config.h The first thing you're going to want to modify is the config.h file. Find MATRIX_ROWS and MATRIX_COLS and change their definitions to match the dimensions of your keyboard's matrix. Farther down are MATRIX_ROW_PINS and MATRIX_COL_PINS. Change their definitions to match how you wired up your matrix (looking from the top of the keyboard, the rows run top-to-bottom and the columns run left-to-right). Likewise, change the definition of UNUSED_PINS to match the pins you did not use (this will save power). &lt;project_name&gt;.h The next file you'll want to look at is &lt;project_name&gt;.h. You're going to want to rewrite the KEYMAP definition - the format and syntax here is extremely important, so pay attention to how things are setup. The first half of the definition are considered the arguments - this is the format that you'll be following in your keymap later on, so you'll want to have as many kxy variables here as you do keys. The second half is the part that the firmware actually looks at, and will contain gaps depending on how you wired your matrix. We'll dive into how this will work with the following example. Say we have a keyboard like this: \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2534\u2500\u252c\u2500\u2534\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 This can be described by saying the top row is 3 1u keys, and the bottom row is 2 1.5u keys. The difference between the two rows is important, because the bottom row has an unused column spot (3 v 2). Let's say that this is how we wired the columns: \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510 \u2502 \u250b \u2502 \u250b \u2502 \u250b \u2502 \u251c\u2500\u250b\u2500\u2534\u2500\u252c\u2500\u2534\u2500\u250b\u2500\u2524 \u2502 \u250b \u2502 \u250b \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 The middle column is unused on the bottom row in this example. Our KEYMAP definition would look like this: #define KEYMAP( \\ k00, k01, k02, \\ k10, k11, \\ ) \\ { \\ { k00, k01, k02 }, \\ { k10, KC_NO, k11 }, \\ } Notice how the top half is spaced to resemble our physical layout - this helps us understand which keys are associated with which columns. The bottom half uses the keycode KC_NO where there is no keyswitch wired in. It's easiest to keep the bottom half aligned in a grid to help us make sense of how the firmware actually sees the wiring. Let's say that instead, we wired our keyboard like this (a fair thing to do): \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510 \u2502 \u250b \u2502 \u250b\u2502 \u250b \u2502 \u251c\u2500\u250b\u2500\u2534\u2500\u252c\u250b\u2534\u2500\u2500\u2500\u2524 \u2502 \u250b \u2502\u250b \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 This would require our KEYMAP definition to look like this: #define KEYMAP( \\ k00, k01, k02, \\ k10, k11, \\ ) \\ { \\ { k00, k01, k02 }, \\ { k10, k11, KC_NO }, \\ } Notice how the k11 and KC_NO switched places to represent the wiring, and the unused final column on the bottom row. Sometimes it'll make more sense to put a keyswitch on a particular column, but in the end, it won't matter, as long as all of them are accounted for. You can use this process to write out the KEYMAP for your entire keyboard - be sure to remember that your keyboard is actually backwards when looking at the underside of it. keymaps\/&lt;variant&gt;\/default.c This is the actual keymap for your keyboard, and the main place you'll make changes as you perfect your layout. default.c is the file that gets pull by default when typing make, but you can make other files as well, and specify them by typing make handwired\/&lt;keyboard&gt;:&lt;variant&gt;, which will pull keymaps\/&lt;variant&gt;\/keymap.c. The basis of a keymap is its layers - by default, layer 0 is active. You can activate other layers, the highest of which will be referenced first. Let's start with our base layer. Using our previous example, let's say we want to create the following layout: \u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510 \u2502 A \u2502 1 \u2502 H \u2502 \u251c\u2500\u2500\u2500\u2534\u2500\u252c\u2500\u2534\u2500\u2500\u2500\u2524 \u2502 TAB \u2502 SPC \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518 This can be accomplished by using the following keymaps definition: const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = { [0] = KEYMAP( \/* Base *\/ KC_A, KC_1, KC_H, \\ KC_TAB, KC_SPC \\ ), }; Note that the layout of the keycodes is similar to the physical layout of our keyboard - this make it much easier to see what's going on. A lot of the keycodes should be fairly obvious, but for a full list of them, check out Keycodes - there are also a lot of aliases to condense your keymap file. It's also important to use the KEYMAP function we defined earlier - this is what allows the firmware to associate our intended readable keymap with the actual wiring. Compiling Your Firmware After you've written out your entire keymap, you're ready to get the firmware compiled and onto your Teensy. Before compiling, you'll need to get your development environment set-up - you can skip the dfu-programmer instructions, but you'll need to download and install the Teensy Loader to get the firmware on your Teensy. Once everything is installed, running make in the terminal should get you some output, and eventually a &lt;project_name&gt;.hex file in that folder. If you're having trouble with this step, see the end of the guide for the trouble-shooting section. Once you have your &lt;project_name&gt;.hex file, open up the Teensy loader application, and click the file icon. From here, navigate to your QMK\/keyboards\/&lt;project_name&gt;\/ folder, and select the &lt;project_name&gt;.hex file. Plug in your keyboard and press the button on the Teensy - you should see the LED on the device turn off once you do. The Teensy Loader app will change a little, and the buttons should be clickable - click the download button (down arrow), and then the reset button (right arrow), and your keyboard should be ready to go! Testing Your Firmware Carefully flip your keyboard over, open up a new text document, and try typing - you should get the characters that you put into your keymap. Test each key, and note the ones that aren't working. Here's a quick trouble-shooting guide for non-working keys: Flip the keyboard back over and short the keyswitch's contacts with a piece wire - this will eliminate the possibility of the keyswitch being bad and needing to be replaced. Check the solder points on the keyswitch - these need to be plump and whole. If you touch it with a moderate amount of force and it comes apart, it's not strong enough. Check the solder joints on the diode - if the diode is loose, part of your row may register, while the other may not. Check the solder joints on the columns - if your column wiring is loose, part or all of the column may not work. Check the solder joints on both sides of the wires going to\/from the Teensy - the wires need to be fully soldered and connect to both sides. Check the &lt;project_name&gt;.h file for errors and incorrectly placed KC_NOs - if you're unsure where they should be, instead duplicate a kxy variable. Check to make sure you actually compiled the firmware and flashed the Teensy correctly. Unless you got error messages in the terminal, or a pop-up during flashing, you probably did everything correctly. If you've done all of these things, keep in mind that sometimes you might have had multiple things affecting the keyswitch, so it doesn't hurt to test the keyswitch by shorting it out at the end. Securing the Teensy, Finishing Your Hardware, Getting Fancier Firmware Now that you have a working board, it's time to get things in their permanent positions. I've often used liberal amounts of hot glue to secure and insulate things, so if that's your style, start spreading that stuff like butter. Otherwise, double-sided tape is always an elegant solution, and electrical tape is a distant second. Due to the nature of these builds, a lot of this part is up to you and how you planned (or didn't plan) things out. There are a lot of possibilities inside the firmware - explore docs.qmk.fm for a full feature list, and dive into the different project (Planck, Clueboard, Ergodox EZ, etc) to see how people use all of them. You can always stop by the OLKB subreddit for help!","tags":"","url":"For_Makers_And_Modders\/Hand_Wiring_Guide.html"},{"title":"ISP Flashing Guide","text":"ISP Flashing Guide Software Needed Wiring The ISP Firmware The .hex File Flashing Your Firmware ISP Flashing Guide If you're having trouble flashing\/erasing your board, and running into cryptic error messages like any of the following: libusb: warning [darwin_transfer_status] transfer error: timed out dfu.c:844: -ETIMEDOUT: Transfer timed out, NAK 0xffffffc4 (-60) atmel.c:1627: atmel_flash: flash data dfu_download failed. atmel.c:1629: Expected message length of 1072, got -60. atmel.c:1434: Error flashing the block: err -2. ERROR Memory write error, use debug for more info. commands.c:360: Error writing memory data. (err -4) dfu.c:844: -EPIPE: a) Babble detect or b) Endpoint stalled 0xffffffe0 (-32) Device is write protected. dfu.c:252: dfu_clear_status( 0x7fff4fc2ea80 ) atmel.c:1434: Error flashing the block: err -2. ERROR Memory write error, use debug for more info. commands.c:360: Error writing memory data. (err -4) You're likely going to need to ISP flash your board\/device to get it working again. Luckily, this process is pretty straight-forward, provided you have any extra programmable keyboard, Arduino, or Teensy 2.0\/Teensy 2.0++. There are also dedicated ISP flashers available for this, but most cost &gt;$15, and it's assumed that if you are googling this error, this is the first you've heard about ISP flashing, and don't have one readily available (whereas you might have some other AVR board). We'll be using a Teensy 2.0 with Windows 10 in this guide - if you are comfortable doing this on another system, please consider editing this guide and contributing those instructions! Software Needed The Arduino IDE Teensyduino (if you're using a Teensy) WinAVR (Windows) Wiring This is pretty straight-forward - we'll be connecting like-things to like-things in the following manner: Flasher B0 &lt;-&gt; Keyboard RESET Flasher B1 &lt;-&gt; Keyboard B1 (SCLK) Flasher B2 &lt;-&gt; Keyboard B2 (MOSI) Flasher B3 &lt;-&gt; Keyboard B3 (MISO) Flasher VCC &lt;-&gt; Keyboard VCC Flasher GND &lt;-&gt; Keyboard GND The ISP Firmware Make sure your keyboard is unplugged from any device, and plug in your Teensy. Run Arduino after you have everything installed Select Tools &gt; Board * &gt; Teensy 2.0 Click File &gt; Examples &gt; 11.ArduinoISP &gt; ArduinoISP Then scroll down until you see something that looks like this block of code: \/\/ Configure which pins to use: \/\/ The standard pin configuration. #ifndef ARDUINO_HOODLOADER2 #define RESET 0 \/\/ Use 0 (B0) instead of 10 #define LED_HB 11 \/\/ Use 11 (LED on the Teensy 2.0) #define LED_ERR 8 \/\/ This won't be used unless you have an LED hooked-up to 8 (D3) #define LED_PMODE 7 \/\/ This won't be used unless you have an LED hooked-up to 7 (D2) And make the changes in the last four lines. If you're using something besides the Teensy 2.0, you'll want to choose something else that makes sense for LED_HB. We define RESET as 0\/B0 because that's what's close - if you want to use another pin for some reason, you can use the pinouts to choose something else. Once you've made your changes, you can click the Upload button (right arrow), which will open up the Teensy flasher app - you'll need to press the reset button on the Teensy the first time, but after that, it's automatic (you shouldn't be flashing this more than once, though). Once flashed, the orange LED on the Teensy will flash on and off, indicating it's ready for some action. The .hex File Before flashing your firmware, you're going to need to and do a little preparation. We'll be appending this bootloader (also a .hex file) to the end of our firmware by opening the original .hex file in a text editor, and removing the last line, which should be :00000001FF (this is an EOF message). After that's been removed, copy the entire bootloader's contents and paste it at the end of the original file, and save it. It's possible to use other bootloaders here in the same way, but you need a bootloader, otherwise you'll have to ISP to write new firmware to your keyboard. Flashing Your Firmware Make sure your keyboard is unplugged from any device, and plug in your Teensy. Open cmd and navigate to your where your modified .hex file is. We'll pretend this file is called main.hex, and that your Teensy 2.0 is on the COM3 port - if you're unsure, you can open your Device Manager, and look for Ports &gt; USB Serial Device. Use that COM port here. You can confirm it's the right port with: avrdude -c avrisp -P COM3 -p atmega32u4 and you should get something like the following output: avrdude: AVR device initialized and ready to accept instructions Reading | ################################################## | 100% 0.02s avrdude: Device signature = 0x1e9587 avrdude: safemode: Fuses OK avrdude done. Thank you. Since our keyboard uses an atmega32u4 (common), that is the chip we'll specify. This is the full command: avrdude -c avrisp -P COM3 -p atmega32u4 -U flash:w:main.hex:i You should see a couple of progress bars, then you should see: avrdude: verifying ... avrdude: 32768 bytes of flash verified avrdude: safemode: Fuses OK avrdude done. Thank you. Which means everything should be ok! Your board may restart automatically, otherwise, unplug your Teensy and plug in your keyboard - you can leave your Teensy wired to your keyboard while testing things, but it's recommended that you desolder it\/remove the wiring once you're sure everything works. If you have any questions\/problems, feel free to open an issue!","tags":"","url":"For_Makers_And_Modders\/ISP_Flashing_Guide.html"},{"title":"IDEs","text":"Eclipse","tags":"","url":"IDEs\/index.html"},{"title":"Eclipse","text":"Setting up Eclipse for QMK Development Prerequisites Build Environment Java Install Eclipse and Its Plugins Download and Install Eclipse CDT First Launch Install the Necessary Plugins The AVR Plugin ANSI Escape in Console Configure Eclipse for QMK Importing the Project Build Your Keyboard Setting up Eclipse for QMK Development Eclipse is an open-source Integrated Development Environment (IDE) widely used for Java development, but with an extensible plugin system that allows to customize it for other languages and usages. Using an IDE such as Eclipse provides many advantages over a plain text editor, such as: intelligent code completion convenient navigation in the code refactoring tools build automation (no need for the command-line) a GUI for GIT static code analysis many other tools such as debugging, code formatting, showing call hierarchies etc. The purpose of the is page is to document how to set-up Eclipse for developing AVR software, and working on the QMK code base. Note that this set-up has been tested on Ubuntu 16.04 only for the moment. Prerequisites Build Environment Before starting, you must have followed the Getting Started section corresponding to your system. In particular, you must have been able to build the firmware with the make command. Java Eclipse is a Java application, so you will need to install Java 8 or more recent to be able to run it. You may choose between the JRE or the JDK, the latter being useful if you intend to do Java development. Install Eclipse and Its Plugins Eclipse comes in several flavours depending on the target usage that you will have. There is no package comprising the AVR stack, so we will need to start from Eclipse CDT (C\/C++ Development Tooling) and install the necessary plugins. Download and Install Eclipse CDT If you already have Eclipse CDT on your system, you can skip this step. However it is advised to keep it up-to-date for better support. If you have another Eclipse package installed, it is normally possible to install the CDT plugin over it. However it is probably better to reinstall it from scratch to keep it light and avoid the clutter of tools that you don't need for the projects you will be working on. Installation is very simple: follow the 5 Steps to Install Eclipse, and choose Eclipse IDE for C\/C++ Developers at Step 3. Alternatively, you can also directly download Eclipse IDE for C\/C++ Developers (direct link to current version) and extract the package to the location of your choice (this creates an eclipse folder). First Launch When installation is complete, click the Launch button. (If you extracted the package manually, open the Eclipse installation folder and double-click the eclipse executable) When you are prompted with the Workspace Selector, select a directory that will hold Eclipse metadata and usually your projects. Do not select the qmk_firmware directory, this will be the project directory. Select the parent folder instead, or another (preferably empty) folder of your choice (the default is fine if you do not use it yet). Once started, click the Workbench button at the top right to switch to the workbench view (there is a also checkbox at the bottom to skip the welcome screen at startup). Install the Necessary Plugins Note: you do not need to restart Eclipse after installing each plugin. Simply restart once all plugins are installed. The AVR Plugin This is the most important plugin as it will allow Eclipse to understand AVR C code. Follow the instructions for using the update site, and agree with the security warning for unsigned content. ANSI Escape in Console This plugin is necessary to properly display the colored build output generated by the QMK makefile. Open Help &gt; Eclipse Marketplace\u2026 Search for ANSI Escape in Console Click the Install button of the plugin Follow the instructions and agree again with the security warning for unsigned content. Once both plugins are installed, restart Eclipse as prompted. Configure Eclipse for QMK Importing the Project Click File &gt; New &gt; Makefile Project with Existing Code On the next screen: Select the directory where you cloned the repository as Existing Code Location; (Optional) Give a different name to the project\u00b9, e.g. QMK or Quantum; Select the AVR-GCC Toolchain; Keep the rest as-is and click Finish The project will now be loaded and indexed. Its files can be browsed easily through the Project Explorer on the left. \u00b9 There might be issues for importing the project with a custom name. If it does not work properly, try leaving the default project name (i.e. the name of the directory, probably qmk_firmware). Build Your Keyboard We will now configure a make target that cleans the project and builds the keymap of your choice. On the right side of the screen, select the Make Target tab Expand the folder structure to the keyboard of your choice, e.g. qmk_firmware\/keyboards\/ergodox Right-click on the keyboard folder and select New\u2026 (or select the folder and click the New Make Target icon above the tree) Choose a name for your build target, e.g. clean &lt;your keymap&gt; Make Target: this is the arguments that you give to make when building from the command line. If your target name does not match these arguments, uncheck Same as target name and input the correct arguments, e.g. clean &lt;your keymap&gt; Leave the other options checked and click OK. Your make target will now appear under the selected keyboard. (Optional) Toggle the Hide Empty Folders icon button above the targets tree to only show your build target. Double-click the build target you created to trigger a build. Select the Console view at the bottom to view the running build.","tags":"","url":"IDEs\/Eclipse.html"},{"title":"For a Deeper Understanding","text":"How Keyboards Work Understanding QMK","tags":"","url":"For_a_Deeper_Understanding\/index.html"},{"title":"How Keyboards Work","text":"How Keys Are Registered, and Interpreted by Computers Schematic View 1. You Press a Key 2. What the Firmware Sends 3. What the Operating System Does Back to the Firmware List of Characters You Can Send How to (Maybe) Enter Unicode Characters How Keys Are Registered, and Interpreted by Computers In this file, you can will learn the concepts of how keyboards work over USB, and you'll be able to better understand what you can expect from changing your firmware directly. Schematic View Whenever you type on 1 particular key, here is the chain of actions taking place: +------+ +-----+ +----------+ +----------+ +----+ | User |--------&gt;| Key |------&gt;| Firmware |-----&gt;| USB wire |----&gt;| OS | +------+ +-----+ +----------+ +----------+ |----+ This scheme is a very simple view of what's going on, and more details follow in the next sections. 1. You Press a Key Whenever you press a key, the firmware of your keyboard can register this event. It can register when the key is pressed, held and released. This usually happens with a periodic scan of key presses. This speed often is limited by the mechanical key response time, the protocol to transfer those key presses (here USB HID), and by the software it is used in. 2. What the Firmware Sends The HID specification tells what a keyboard can actually send through USB to have a chance to be properly recognised. This includes a pre-defined list of scancodes which are simple numbers from 0x00 to 0xE7. The firmware assigns a scancode to each key of the keyboard. The firmware does not send actually letters or characters, but only scancodes. Thus, by modifying the firmware, you only can modify what scancode is sent over USB for a given key. 3. What the Operating System Does Once the keycode reaches the operating system, a piece of software has to have it match an actual character thanks to a keyboard layout. For example, if your layout is set to QWERTY, a sample of the matching table is as follow: keycode character 0x04 a\/A 0x05 b\/B 0x06 c\/C ... ... 0x1C y\/Y 0x1D z\/Z ... ... Back to the Firmware As the layout is generally fixed (unless you create your own), the firmware can actually call a keycode by its layout name directly to ease things for you. This is exactly what is done here with KC_A actually representing 0x04 in QWERTY. The full list can be found in keycodes. List of Characters You Can Send Putting aside shortcuts, having a limited set of keycodes mapped to a limited layout means that the list of characters you can assign to a given key only is the ones present in the layout. For example, this means that if you have a QWERTY US layout, and you want to assign 1 key to produce \u20ac (euro currency symbol), you are unable to do so, because the QWERTY US layout does not have such mapping. You could fix that by using a QWERTY UK layout, or a QWERTY US International. You may wonder why a keyboard layout containing all of Unicode is not devised then? The limited number of keycode available through USB simply disallow such a thing. How to (Maybe) Enter Unicode Characters You can have the firmware send sequences of keys to use the software Unicode Input Method of the target operating system, thus effectively entering characters independently of the layout defined in the OS. Yet, it does come with multiple disadvantages: Tied to a specific OS a a time (need recompilation when changing OS); Within a given OS, does not work in all software; Limited to a subset of Unicode on some systems.","tags":"","url":"For_a_Deeper_Understanding\/How_Keyboards_Work.html"},{"title":"Understanding QMK","text":"Understanding QMK's Code Startup The Main Loop Matrix Scanning Matrix to Physical Layout Map Keycode Assignment State Change Detection Process Record Understanding QMK's Code This document attempts to explain how the QMK firmware works from a very high level. It assumes you understand basic programming concepts but does not (except where needed to demonstrate) assume familiarity with C. It assumes that you have a basic understanding of the following documents: Introduction How Keyboards Work FAQ Startup You can think of QMK as no different from any other computer program. It is started, performs its tasks, and then ends. The entry point for the program is the main() function, just like it is on any other C program. However, for a newcomer to QMK it can be confusing because the main() function appears in multiple places, and it can be hard to tell which one to look at. The reason for this is the different platforms that QMK supports. The most common platform is lufa, which runs on AVR processors such at the atmega32u4. We also support chibios and vusb. We'll focus on AVR processors for the moment, which use the lufa platform. You can find the main() function in tmk_core\/protocol\/lufa\/lufa.c. If you browse through that function you'll find that it initializes any hardware that has been configured (including USB to the host) and then it starts the core part of the program with a while(1). This is The Main Loop. The Main Loop This section of code is called &quot;The Main Loop&quot; because it's responsible for looping over the same set of instructions forever. This is where QMK dispatches out to the functions responsible for making the keyboard do everything it is supposed to do. At first glance it can look like a lot of functionality but most of the time the code will be disabled by #define's. keyboard_task(); This is where all the keyboard specific functionality is dispatched. The source code for keyboard_task() can be found in tmk_core\/common\/keyboard.c, and it is responsible for detecting changes in the matrix and turning status LED's on and off. Within keyboard_task() you'll find code to handle: Matrix Scanning Mouse Handling Serial Link(s) Visualizer Keyboard status LED's (Caps Lock, Num Lock, Scroll Lock) Matrix Scanning Matrix scanning is the core function of a keyboard firmware. It is the process of detecting which keys are currently pressed, and your keyboard runs this function many times a second. It's no exaggeration to say that 99% of your firmware's CPU time is spent on matrix scanning. While there are different strategies for doing the actual matrix detection, they are out of scope for this document. It is sufficient to treat matrix scanning as a black box, you ask for the matrix's current state and get back a datastructure that looks like this: { {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0} } That datastructure is a direct representation of the matrix for a 4 row by 5 column numpad. When a key is pressed that key's position within the matrix will be returned as 1 instead of 0. Matrix Scanning runs many times per second. The exact rate varies but typically it runs at least 10 times per second to avoid perceptible lag. Matrix to Physical Layout Map Once we know the state of every switch on our keyboard we have to map that to a keycode. In QMK this is done by making use of C macros to allow us to separate the definition of the physical layout from the definition of keycodes. At the keyboard level we define a C macro (typically named KEYMAP()) which maps our keyboard's matrix to physical keys. Sometimes the matrix does not have a switch in every location, and we can use this macro to pre-populate those with KC_NO, making the keymap definition easier to work with. Here's an example KEYMAP() macro for a numpad: #define KEYMAP( \\ k00, k01, k02, k03, \\ k10, k11, k12, k13, \\ k20, k21, k22, \\ k30, k31, k32, k33, \\ k40, k42 \\ ) { \\ { k00, k01, k02, k03, }, \\ { k10, k11, k12, k13, }, \\ { k20, k21, k22, KC_NO, }, \\ { k30, k31, k32, k33, }, \\ { k40, KC_NO, k42, KC_NO } \\ } Notice how the second block of our KEYMAP() macro matches the Matrix Scanning array above? This macro is what will map the matrix scanning array to keycodes. However, if you look at a 17 key numpad you'll notice that it has 3 places where the matrix could have a switch but doesn't, due to larger keys. We have populated those spaces with KC_NO so that our keymap definition doesn't have to. You can also use this macro to handle unusual matrix layouts, for example the Clueboard rev 2. Explaining that is outside the scope of this document. Keycode Assignment At the keymap level we make use of our KEYMAP() macro above to map keycodes to physical locations to matrix locations. It looks like this: const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = { [0] = KEYMAP( KC_NLCK, KC_PSLS, KC_PAST, KC_PMNS, \\ KC_P7, KC_P8, KC_P9, KC_PPLS, \\ KC_P4, KC_P5, KC_P6, \\ KC_P1, KC_P2, KC_P3, KC_PENT, \\ KC_P0, KC_PDOT) } Notice how all of these arguments match up with the first half of the KEYMAP() macro from the last section? This is how we take a keycode and map it to our Matrix Scan from earlier. State Change Detection The matrix scanning described above tells us the state of the matrix at a given moment, but your computer only wants to know about changes, it doesn't care about the current state. QMK stores the results from the last matrix scan and compares the results from this matrix to determine when a key has been pressed or released. Let's look at an example. We'll hop into the middle of a keyboard scanning loop to find that our previous scan looks like this: { {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0} } And when our current scan completes it will look like this: { {1,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0} } Comparing against our keymap we can see that the pressed key is KC_NLCK. From here we dispatch to the process_record set of functions. Process Record The process_record() function itself is deceptively simple, but hidden within is a gateway to overriding functionality at various levels of QMK. The chain of events is described below, using cluecard whenever we need to look at the keyboard\/keymap level functions. void process_record(keyrecord_t *record) bool process_record_quantum(keyrecord_t *record) Map this record to a keycode bool process_record_kb(uint16_t keycode, keyrecord_t *record) bool process_record_user(uint16_t keycode, keyrecord_t *record) bool process_midi(uint16_t keycode, keyrecord_t *record) bool process_audio(uint16_t keycode, keyrecord_t *record) bool process_music(uint16_t keycode, keyrecord_t *record) bool process_tap_dance(uint16_t keycode, keyrecord_t *record) bool process_leader(uint16_t keycode, keyrecord_t *record) bool process_chording(uint16_t keycode, keyrecord_t *record) bool process_combo(uint16_t keycode, keyrecord_t *record) bool process_unicode(uint16_t keycode, keyrecord_t *record) bool process_ucis(uint16_t keycode, keyrecord_t *record) bool process_printer(uint16_t keycode, keyrecord_t *record) bool process_auto_shift(uint16_t keycode, keyrecord_t *record) bool process_unicode_map(uint16_t keycode, keyrecord_t *record) Identify and process quantum specific keycodes At any step during this chain of events a function (such as process_record_kb()) can return false to halt all further processing.","tags":"","url":"For_a_Deeper_Understanding\/Understanding_QMK.html"},{"title":"README","text":"Quantum Mechanical Keyboard Firmware What is QMK Firmware? How to Get It How to Compile How to Customize Quantum Mechanical Keyboard Firmware What is QMK Firmware? QMK (Quantum Mechanical Keyboard) is an open source community that maintains QMK Firmware, QMK Flasher, qmk.fm, and these docs. QMK Firmware is a keyboard firmware based on the tmk_keyboard with some useful features for Atmel AVR controllers, and more specifically, the OLKB product line, the ErgoDox EZ keyboard, and the Clueboard product line. It has also been ported to ARM chips using ChibiOS. You can use it to power your own hand-wired or custom keyboard PCB. How to Get It If you plan on contributing a keymap, keyboard, or features to QMK, the easiest thing to do is fork the repo through Github, and clone your repo locally to make your changes, push them, then open a Pull Request from your fork. Otherwise, you can either download it directly (zip, tar), or clone it via git (git@github.com:qmk\/qmk_firmware.git), or https (https:\/\/github.com\/qmk\/qmk_firmware.git). How to Compile Before you are able to compile, you'll need to install an environment for AVR or\/and ARM development. Once that is complete, you'll use the make command to build a keyboard and keymap with the following notation: make planck\/rev4:default This would build the rev4 revision of the planck with the default keymap. Not all keyboards have revisions (also called subprojects or folders), in which case, it can be omitted: make preonic:default How to Customize QMK has lots of features to explore, and a good deal of reference documentation to dig through. Most features are taken advantage of by modifying your keymap, and changing the keycodes.","tags":"","url":"README.html"}]}